# linux 中断子系统 - 上下半部机制概述
从最简单的单片机裸机系统到现在非常复杂的操作系统，中断一直扮演着非常重要的角色。  

对于裸机系统而言，函数的主程序是一个执行流，中断是另一个执行流，它们之间的区别是主程序流程的控制是完全可预期、可控制的，对于中断而言，尽管程序员可以控制中断的执行逻辑，却不无法确定中断什么时候到来。  

为什么需要中断？或者说为什么我们会允许预期之外的事情发生？

这是个有意思的问题，中断的产生应该是在一定程度上来说也是可预期的，我们知道这个中断会发生，但是我们并不知道它什么时候发生，它的意义在于：提供了一种通知机制。  

在人类的世界中，人们总是倾向于同时做多件事，严格地说是让自己处于多件事情的跟进状态，以提高自己的时间利用率，比如在煮饭的时候，将饭放到电饭锅之后就去炒菜，红烧肉在收汁的时候把碗洗一洗，擦擦餐桌准备吃饭，而不是等饭熟了再炒菜，菜准备好了再去准备餐桌，无论是聪明人还是笨蛋都知道这是常识。   

CPU 既然是人造的，当然也承载着人们对它的期望，随着硬件的发展，人们总是希望 CPU 能够做更多的事，一方面是提升执行频率，一方面是塞满它的"行程"，让它"同时"处理多个事情，人需要人权，但是计算机并不会讲"机权"，程序员优化代码的目的就是榨干计算机的每一滴性能，如果你做到了，人们并不会说你是个残忍的人，而会夸你是个优秀的程序员。  

比如 CPU 发送给其它器件一个信号，然后等待器件的回复，但是程序员作为一个苛刻的监工，并不会让 CPU 就此闲着，而是先让它去处理其他任务，等对端器件回复了再让 CPU 回来处理。又比如用户通过键盘鼠标来控制计算机，对于 CPU 这种时间精度为纳秒级别的处理器，人类的按键速度简直是慢得出奇，同样地，在没有接收到用户的键盘鼠标操作时，CPU 会被安排去做其它事，等检测到了输入操作时再来进行处理。   

对于煮饭这件事来说，怎么知道饭熟了，或者红烧肉已经煮好了？最常用的做法就是过一段时间去看一次，对于有条件的呢，他们会使用带定时功能的电饭煲、炒菜锅，这样的好处是不用定时地去看，饭菜好了自然就会得到通知，通常是 "嘀嘀嘀" 的响声，或者是清脆的电铃声。    

对于 CPU 来说，也是一样的问题，CPU 怎么知道对端器件回复了我的信号，或者又怎么知道用户在键盘上敲打了字符，也是两个方法：一个是定时地去查，另一个是通过某一种通知机制来实现。可以明确地感受到，定时地查这件事肯定是更浪费时间且效率低下的，而对程序员这名苛刻的监工而言，自然是需要让 CPU 创造更多的价值，所以需要使用通知机制来实现，这个机制在 CPU 中的实现就是中断。   

其实，几乎所有计算机中的逻辑实现，都可以在生活中找到相对应的场景，同时，计算机中的某些处理方法，也可以应用到生活中，所以才有了那句话："知识都是相通的"。  




## 计算机中中断是怎么产生的

CPU 的中断分为两种：硬件中断和软件中断。   

硬件中断和软件中断的另一种说法是中断和异常，硬件中断是由硬件信号产生的，而软件中断(异常)是由 CPU 内部指令产生的，linux 中从用户空间跳转到内核空间就是通过软件中断实现的。   

而对于硬件中断，每一个CPU硬件上都会存在一根中断线，通过监测该中断线的电平变化来确定是否产生了中断，而每一个可以产生中断信号的硬件控制器都会有一条名为 IRQ 的中断输出线，硬件控制器通过 IRQ 信号线发出信号，CPU 根据检测中断线的状态变化就可以判断是否有中断发生。  

那么，CPU负责硬件中断的中断线通常只有1根，而 CPU 上连接的硬件控制器通常有多个，硬件资源明显是不够用的。回头想想，其实我们在很多情况下也会遇到类似的问题，比如墙上只引出一个网络插口，但是要连接多台设备上网怎么办，我们使用一个交换机，由交换机引出多个网口，同时由交换机来处理数据流量的转发。  

对于硬件中断而言，也是使用了这种策略，这个针对于硬件中断的交换机我们称他为：可编程中断控制器。  

中断控制器对上引出一根 IRQ 输出信号线连接到 CPU 的中断线上，对下提供多个输入的 IRQ 线，供各硬件控制器的中断线连接，每一根线分配一个中断号用作识别。每当硬件中断产生中断时，通过信号线传递给中断控制器，中断控制器再将其传递给 CPU，CPU 在处理时也可以通过中断控制器查询是哪个硬件设备发生了中断以做出相应的处理。  

该中断控制器是可编程的，意味着它可以对某些中断进行屏蔽，和其它硬件控制器一样响应 CPU 的操作指令。  

对于硬件中断的产生，我们可以举一个简单的例子：对于一个简单的串口控制器而言，为了操作的灵活性，它需要产生多种中断，比如数据发送完成中断、数据接收中断、流控中断，作为实现，可以为每种中断类型匹配一根硬件上的中断线，也可以让这些中断共用一根中断线。   

当串口接收到一个数据时，如果该硬件控制器支持该中断的产生，它将通过中断信号线发送一个中断给中断控制器，中断控制器记录产生中断的中断号，然后发送给 CPU，如果 CPU 目前没有屏蔽中断信号，它会查询当前发生中断的 irq 是哪一个，然后从中断向量表中找到对应执行函数来执行。  

中断的传递分为多级，所以中断的屏蔽也分为多种：



* CPU 对发过来的中断视而不见：CPU 感知并确认中断信号是通过内部寄存器完成的，它可以通过屏蔽中断寄存器中负责管理中断的某一位来实现。  
* 中断控制器对某些中断输入线上的输入中断信号视而不见：同样和中断控制器中的内部寄存器相关。
* 硬件控制器不发送某些事件的中断信号：硬件控制器通过内部寄存器的某些屏蔽字来屏蔽某一类型中断，发生该事件时不发送中断信号。




## 为什么中断不能睡眠
几乎所有做嵌入式的工程师都知道的一个概念：中断程序中不能睡眠，同时也不能执行耗时较长的任务，那么，为什么中断不支持耗时的任务？   

首先我们来看看中断的应用场景，在一个系统中，中断只是惊鸿一瞥，而进程才是永恒的，进程是执行程序的主要载体，也就是说，编写程序需要实现的业务逻辑都是由进程来完成的，所以，进程必然要占据系统执行的大部分时间，而中断只是作为一种通知和同步机制，进程和中断有明显的主次关系。

如果非要问中断睡眠和执行耗时任务会导致怎样的后果，其实这是一种由结果反推原因的行为，linux 中的睡眠会导致调度的发生，调度的基本单位是线程或者进程，而中断并不属于任何线程或者进程，也没有相应的上下文，所以根本就无从调度。

既然讲到这里，就再聊一聊中断调度的问题，实际上在内核的实现中，中断的处理并不是完全独立于进程执行环境的，current 指针依旧指向中断发生前正在执行的进程，在 arm 架构中，执行中断处理使用的栈甚至还是借用了发生中断前进程的栈空间(x86 中有独立的中断栈)，这样看起来就像中断运行在当前进程的内核环境，如果在中断处理函数中执行调度，其实调度可以正常执行，当前的 current 进程会被切换到另一个进程，而 current 进程的上下文中依旧会保存着未处理完的中断程序数据，进入睡眠，直到下一次被调度回来，只是在该进程执行的期间内，进程的上下文状态会变得混乱，因为中断没有正常执行完，至于会不会出现死锁、oops 等问题，就需要看软件上怎么设计了，如果你没看过中断子系统和调度子系统的源代码，对这部分可能不会太理解，没关系，这两部分子系统都将在后面的文章中进一步介绍。

如果中断执行耗费太多的时间，而中断的触发又比较频繁，产生中断风暴，势必会造成进程得不到执行(饿死)，或者非常卡慢，这无疑是一种本末倒置，尤其是在进程带有看门狗的情况下，这时候系统就会复位。  

这其中的本质问题在于，所有的系统在设计之初，就默认了一个原则就是：中断不允许睡眠和执行耗时的任务而导致抢占主程序过多的执行时间，基于这个原则设计出来的系统自然是不支持执行耗时任务的。如果从系统设计之初改变中断与进程之间的主次关系，让中断上下文可以参与调度，那样的系统中断睡眠也是可以实现的，虽然这完全没必要，也会带来很多应用上的问题，但是逻辑上总归是可以实现的。   

所以，中断中执行耗时的任务或者睡眠为什么会导致系统出问题，可能是中断丢失、可能是进程饿死导致复位，这取决于软件层面的实现，只是可以明确的是，大概率下它会出问题。    

当然，既然是取决于软件的实现，也有可能不出问题，解决方法就是你设计一个可以允许中断睡眠的系统即可，我曾经在裸机系统中测试在中断服务程序中进程长达 1s 的 delay 也能正常运行，当时的情况是主程序中没有执行太多其他的任务，也没有加看门狗，自然就不会有什么问题。



## 中断为什么要分为上下半部
讨论这一点需要大家达成一个共识：中断中不能执行耗时的任务。   

中断的执行要求快速，但是通常事情常常不随人愿，并不是所有中断的执行都可以快速的结束，而且，更麻烦的是，由于 linux 的中断不支持中断嵌套，在正式处理中断之前会屏蔽掉其它中断，直到中断处理完成，再打开继续接收中断，如果中断执行太慢，这就势必造成一些问题。  

比如网口接收到一个数据包，CPU 响应中断，设置屏蔽，然后开始处理，将数据拷贝到内存，再解析数据，解析完成之后退出中断，重新使能接收中断，在网络比较繁忙的时候，数据接收中断可能一个接一个，导致 CPU 一直在处理中断而无暇顾及进程，就导致进程的延迟，毕竟中断是可以随意抢占进程执行的。   

于是，解决方案就是将中断的处理分为两部分：上下半部。上半部分在中断服务程序中快速地完成，而对于耗时较多的任务，可以进行推迟处理。  

一方面中断快速地执行完成可以保证系统对下一次中断的快速响应，另一方面，将耗时的任务推迟执行可以保证低优先级的进程也可以分到执行时间，尽管系统非常繁忙时进程会表现得卡慢，但是至少不会出问题。  

linux 中下半部主要分为三种：softirq、tasklet、workqueue，需要注意的是，softirq 被翻译为软中断，和 CPU 中的软件中断是有区别的，软件中断通常是 CPU 内部指令来实现的，通常又被称为异常。而软中断是内核在软件上实现的一种延迟执行的机制。  

在上文中有提到，下半部的出现带来了两个好处：



* 中断快速响应
* 即使中断繁忙，也不会让进程饿死

为什么下半部要分为三种，而不是由一种兼顾所有场景？

对于某些中断应用，它要求快速执行，但是为了系统的响应性能，需要考虑中断快速响应的问题，所以不能把所有任务放到中断中执行而需要将耗时部分推迟执行，在中断执行完成的时候立马执行下半部，对于这种中断，这是最好的解决方案，既保证了系统响应性，也保证了整个中断任务的快速执行，这种下半部就是 softirq。  

而对于某些中断应用，对执行时间要求不高，甚至在处理时还会导致阻塞，很显然，睡眠在中断中是不允许的，就需要把睡眠放到下半部完成，对于这种对执行时间不严格的、耗时的甚至导致睡眠的部分，就需要使用另一种下半部：workqueue。

softirq 依旧工作在中断上下文中，它的执行优先级比进程高，所以可以抢占进程执行，用于处理对实时性要求高的任务，但是 softirq 使用起来比较麻烦，体现在两点：

* 同一个 softirq 可能在不同的 CPU 上并发执行，这会对编程带来一定的困难，处理数据同步向来是一个棘手的问题
* softirq 只允许静态地编译到内核中，不能动态地添加到系统中，非常不方便。

所以，在性能和使用便捷性的矛盾下，产生了另一种下半部机制：tasklet，tasklet 同样是基于 softirq 实现的，但是它的实现不允许不同 CPU 上的并发执行，同时可以动态地添加到系统中，简化了开发者的工作，同时也因为不支持 CPU 并发执行，会造成一定的性能损失。tasklet 可以算是性能和使用便捷性矛盾调和下的一个产物。  

softirq 通常是用于需要快速处理的中断任务，但是又由于它依旧运行在中断上下文，可以随意地抢占进程执行，所以大量的 softirq 也完全可能会造成进程饿死的问题，这又涉及到 softirq 的另一种调和手段：当 softirq 繁忙的时候，将 softirq 放到内核线程中执行，内核线程会和线程公平地进行调度，从而让进程得以执行。  

而 workqueue 总是工作在内核线程中，和进程进行公平地调度，基于效率的考虑，workqueue 反而是三种下半部实现中最为复杂的一种，在后续的文章中我们会详细讲到。



## 小结
要理解中断的实现特性，首先我们要理解的是中断和主程序之间的关系：它们之间存在明显的主次关系，要时刻记得，主程序才是程序逻辑实现的主体。   

原则是中断只是主程序实现应用逻辑的一种辅助通知机制，所以中断的执行不应该过多地影响主程序的执行，理解了这个，你就会明白为什么中断中不能执行耗时任务、为什么不能睡眠。  

这一篇是中断下半部机制系列的开篇，在后续的文章中，博主将详细介绍中断下半部三种实现机制的原理。  



### 参考

4.14 内核代码

BiscuitOs 微信群的技术讨论





[专栏首页(博客索引)](https://zhuanlan.zhihu.com/p/362640343)
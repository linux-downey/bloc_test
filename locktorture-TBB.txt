## 背景
在日常的优化工作中，一个优化项、或者说一个社区的 patch 并入内核代码中是否最终有效，这是一个需要验证的问题，如果完全依靠工程师的直觉，并不是一个很好的选择。

因此，需要一个标准的测试手段来来衡量针对锁的修改，这种测试手段重点不在于量化地获取锁在使用过程中的各项参数指标，而旨在对比多个版本在指定场景下的性能表现。 

一方面是指定场景，指定场景的含义在于这个测试工具需要能够通过参数来制造场景，通常就是构建不同程度的锁竞争。
于是，参照内核提交者的提供的测试信息，我们对 microbenchmark 提出了以下需求：
1、可以调整请求锁的线程数量
2、可以调整持锁临界区的长度，临界区的长度对锁吞吐量的影响比较大
3、可以调整单个线程的尝试持锁频率
4、可以统计输出持锁延迟
5、可以一定程度地模拟用户场景

另一方面是性能表现，对于性能表现，通常以锁的平均吞吐量和持锁延迟来衡量。

实际上，内核中有一个自带的 locktorture 模块用于做内核中各类锁的压力测试，在一定程度上它可以满足我们上述的需求，而不能满足的部分，我们也可以对它进行相应的改造。  

接下来就看一看 locktorture 模块的相关信息。

## 如何使用 locktorture
首先，它默认的用法是编译成一个模块，在加载时开启测试，在卸载时停止测试，并使用 printk 输出测试数据。

如果你想以其它方式来执行开始测试、停止测试的操作，比如通过文件操作，也可以修改它的源代码来实现，并不复杂。这里主要还是讲它的标准实现。

locktorture 依赖于内核中的 torture 模块，在编译的时候需要注意一下，至于如何编译模块这里就不讲了。

如果只需要知道怎么使用，就可以从黑盒的角度来看，只观察它的输入输出即可。

### 输入参数

输入的参数是以 module_param 的形式定义在模块中的，用法：

insmod locktorture.ko param1=val1 param2=val2

其中参数以及对应的值包括：
torture_type : 要测试的锁类型，其中包含:"lock_busted"、"spin_lock"、"spin_lock_irq"、"rw_lock"、"rw_lock_irq"、"mutex_lock"、"ww_mutex_lock"、"rtmutex_lock"、"rwsem_lock"、"percpu_rwsem_lock"。第一个其实不是内核锁，它只是模拟一种有问题的锁来做测试，它的 lock/unlock 函数实现就是一个空函数，至于它要实现什么测试目的，目前还不清楚。而其它的 torture type，都是一些内核锁，这里就不多做介绍了。

nreaders_stress/nwriters_stress：用于测试的读/写端线程数量。对于不区分读写的诸如 spin_lock、mutex_lock，其 lock/unlock 操作都视为写操作，不存在读操作。
	当锁不支持读操作时，nwriters_stress 默认为 2*num_online_cpus
	当锁支持读操作时，nreaders_stress 和 nwriters_stress 分别被设置为 2*num_online_cpus

onoff_holdoff：开始测试 cpu-hotplug 的等待时间，这个通常只用在 locktorture 编译进内核时在 CPU 启动的时候用到。
	默认为 0，也就是不支持这个功能

onoff_interval：每次开始随机的 cpu-hotplug 操作的间隔时间，主要是用于 cpu 热插拔的测试，对于普通的内核锁来说其实必要性不大，RCU 场景测 cpu 热插拔比较多。
	默认为 0，表示默认情况下不引入 cpu 热插拔的测试。

stat_interval：输出打印的间隔时间
	默认60s。

shuffle_interval：shuffle 是洗牌的意思，shuffle 操作其实就是定时地将特定 tasks 绑定到不同的 cpu 上，在普通的内核锁测试中必要性不大。
	默认为 3。

stutter：线程运行之间的间隔，线程运行其实就是尝试持锁，如果设置为 0，那就是线程不停地尝试持锁。
	默认值为 5，单位为 jiffies。
	
verbose：详细的打印输出信息。
	默认为 true，通过 printk 输出。
	
shutdown_secs：关机时间，单位为 s，在自动化测试下常用，倒计时结束就关机。
	默认为 0，单位为 s。


### 输出
locktorture 的输出比较简单，下面是个输出示例：
TODO.

其中，最主要的指标就是 Total，也就是所有线程获取锁的总次数。
而 Min/Max 指标的意思是在多个测试线程中，多个线程获取锁的次数是不一样的，这里输出的就是最少的和最多的次数，理论上所有线程优先级一样，不应该有较大差异，如果存在较大差异，可能是系统存在一定的问题。
而 Fail 指标则用于测试锁本身的实现是否有 bug，是否存在 lock/unlock 不匹配的情况。



## 实现
locktorture 从原理上来看其实并不复杂，也就是起特定数量的线程，然后让多个线程不断地执行 lock/unlock 操作，然后再记录下来所有线程获取锁的次数，也就是吞吐量。  

但是如果要做一个相对成熟的内核锁测试工具，就需要考虑其它方面的需求，比如：
* 兼容内核中多种锁的测试，通过不同的输入来控制不同内核锁的测试
* 可设置测试负载，其中包含：线程数量、线程临界区长度、线程非临界区长度(也就是尝试持锁的频率)
* 可检测异常情况

按照内核的风格，不难想到它的实现方式：将公共的部分抽象出来，作为框架，将差异性的数据部分以参数的形式传入，而操作部分则以回调函数的形式注册到框架中，比如所有的锁的关键操作都是 init、lock、unlock，而差异部分则是有些锁区分读写。
同时呢，在整个内核中，除了 lock 需要执行 torture(折磨，意为压力测试) 操作，还有其它东西，比如 RCU(RCU 严格来说不算一种内核锁，因此也就没有和这些锁厮混到一起)，后续也可能扩展到其它的同步模块，因此除了将 lock  层的共性进行抽象，在线程的层面同样可以将线程相关的操作抽象出来，比如线程创建、等待、停止、定期绑定到不同 cpu 之类的操作，因此，整个 locktorture 的实现框架是这样的：

			xxx xxx xxx
     rcu	locktorture
	   torture

每一种锁在 locktorture 的实现中都抽象成一个 struct lock_torture_ops 结构，从 ops 后缀不难看出这其实是一系列的回调函数，其中包含：
struct lock_torture_ops {
	void (*init)(void);
	int (*writelock)(void);
	void (*write_delay)(struct torture_random_state *trsp);
	void (*task_boost)(struct torture_random_state *trsp);
	void (*writeunlock)(void);
	int (*readlock)(void);
	void (*read_delay)(struct torture_random_state *trsp);
	void (*readunlock)(void);

	unsigned long flags; /* for irq spinlocks */
	const char *name;
};

回调函数对应的内容也是一目了然，其中稍微特殊一点的有：
* task_boost: 这个是用于 rt_mutex 的，因为 rt_mutex 涉及到优先级的继承问题。
* write_delay/read_delay：因为是测试程序，因此临界区也需要测试者自己提供，这两个函数就是分别在读写临界区调用的函数，也就是临界区的负载。实际上，在 locktorture 标准的实现中，这两个函数并不是简单的 delay，而是分出几个 delay 等级，每次执行其中一种 delay 等级，以此来模拟在真实用户场景下相对随机的临界区长度。
	注：在做标准的测试中，这种随机可能带来一些不确定性，这部分可以改成固定的 delay，以实现可控的临界区长度。


在 locktorture 中，静态定义所有内核锁对应的 ops 结构，然后再根据模块加载时传入的 type 来确定要执行哪种 lock 的测试，包括开启多少个读写线程、每个线程多长的测试间隔、测试多长时间等等，这些代码的实现很流水化，没什么好讲的。



## 待改进
虽然 locktorture 的代码看起来有点儿长，1000 多行的代码，但是它的逻辑十分简单，很好理解。

而对于我们而言，使用和了解 locktorture 的实现其实只是第一步，进一步的，我们需要根据我们自己的需求，来改造 locktoture 以达到我们的测试目的，比如：
1、支持可设置的固定临界区
2、如果更好地模拟实际应用场景下的锁测试
3、当区分线程优先级时，如何保证测试的准确性
4、改造成支持嵌套锁场景下的测试
5、支持统计持锁时延
6...


TODO：测试时间单位是 jiffies 还是 secs。
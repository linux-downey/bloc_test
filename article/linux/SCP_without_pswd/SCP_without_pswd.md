# SCP文件传输协议
在linux下开发时，经常需要登录到其他的设备上，例如虚拟机内ubuntu、树莓派等等，经常涉及到传输文件的操作，传输文件有很多中方法，如物理磁盘拷贝，基于网络的samba服务、SCP传输、ftp文件传输等等，今天我们就来聊聊出场频率最高的SCP传输。
## SCP的使用
在linux环境中，当我们需要在两台机器之间传输数据时，经常会用到SCP指令，(SCP指令其实就是基于SCP(secure copy)协议实现的应用程序)，SCP的使用示例：

    scp a.out downey@192.168.1.101:/home/donwey  

从示例可以看出，上述示例为：*将a.out这个文件传送给IP为192.168.1.101目标机器的/home/downey目录下*，如果是第一次传输，终端会显示：

    The authenticity of host '192.168.4.77 (192.168.4.77)' can't be established.ECDSA key fingerprint is 7f:d8:d6:37:4f:a7:6f:8d:a3:00:45:7f:0d:xx:xx:xx.Are you sure you want to continue connecting (yes/no)?  

接着键入：

    yes  

然后系统会提示你输入账户和密码，注意这个密码指的是目标机器上用户的账号密码，正确输入之后传输完成。

## 背后的实现原理
知道怎么做，当然还需要知道为什么这么做，所以我们需要来探究scp指令背后的秘密。  

### 预备知识
在介绍SCP协议之前，我们先得了解一下SSH协议，和计算机中的加密方式。  

### 对称加密
对称加密，即在数据传输过程中对数据进行加密和解密的算法使用同一个密钥，这种加密算法有什么弊端呢？   

当客户端需要与服务器端进行数据传输时，不管是由客户端还是由服务端产生的密钥，都得将这个密钥传给对方才能实现加解密，而在传输的过程中就可能造成密钥的泄漏。  

那么有些人就要说了，那我不用网络传输秘钥，我可以使用口头传输或者u盘拷贝的方法。  

是的，这样就可以保证安全，但是在大多数互联网应用中，通信双方是陌生设备，无法做到上述的方式。  

### 非对称加密  
针对对称加密带来的风险，非对称加密则解决了这个问题。  

将加解密使用的密钥分为公钥和私钥，公钥可以公开，而私钥则由密钥生成者保存，客户端使用公钥进行加密，而服务端用私钥进行解密，且目前来说还没有出现能从公钥推算出私钥的的破解机制。  

所以相对于对称加密而言，这种加密方式更加安全，但是这种加密方式的缺点是会占用更多的计算机资源，而且这种资源的耗费量是巨大的。    

### 常见的加密方式

#### 对称加密：
* DES(Data Encryption Standard):加密速度较快，适合加密大量数据的场合。

* 3DES：基于DES的加密算法，顾名思义，这是对一块数据用三个不同的密钥进行三次加密，显而易见强度更高，更安全。

* RC2和RC4：用变长密钥对大量数据进行加密，速度比DES更快

* IDEA:（International Data Encryption Algorithm）国际数据加密算法，使用 128 位密钥提供非常强的安全性；

* AES:高级加密标准，是下一代的加密算法标准，速度快，安全级别高，这个加密算法被广泛应用。  

#### 非对称加密：

* RSA:是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的，目前使用最广的加密算法

* Diff ieˉHellman：每次交换数据的时候都使用一组新的密钥，有效地防止了第三方获得私钥后解密所有信息，但是同时对中间人攻击的防护比较薄弱。

#### SSH协议
SSH是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境，最常见的运用是远程登录。SSH的交互流程是这样的：  

1. 客户端发送请求：这个请求其实就是ssh登录请求，即发起者拥有服务器上的某个用户的账号密码，以远程登录的方式来操作服务器。  

2. 服务器将公钥发送给客户端，这个公钥是给客户端进行数据加密用的  

3. 客户端收到服务器公钥，确定是否继续连接？为什么会有这么一个流程呢，既然我指定了就是要连接服务器，为什么还要让我确认一次,这会不会是多此一举呢？其实不然，这是为了防范中间人攻击。  

4. 客户端用公钥对密码进行加密，再发送给服务器  

5. 服务器用私钥对密码进行解密，返回登录结果  

####中间人攻击  

刚刚提到中间人攻击，我们就来看看什么是中间人攻击？  

我们大可以想一想，在一个不安全的网络中，如果我发送的请求被第三方截获，而第三方把他的公钥发给我，而我用他的公钥对密码进行加密，然后再发送给他，他就获得了完整的账号密码，这时候他就可以拿着从我这儿窃取来的信息登录服务器。  

那么，在一个不安全的网络中，我们该怎样防范这种攻击方式呢？一般有两种方法：  

1. 服务器将公钥公布在官方或者以其他方式公开，让用户可以查到进行对比，如果不匹配，就在第三步的时候取消登录即可。  

2. CA证书，由一个权威机构CA对公钥进行认证，CA机构的数字签名使得攻击者不能伪造和篡改证书。在SET交易中，CA不仅对持卡人、商户发放证书，还要对获款的银行、网关发放证书，CA 也拥有一个证书（内含公钥）和私钥。网上的公众用户通过验证 CA 的签字从而信任 CA ，任何人都可以得到 CA 的证书（含公钥），用以验证它所签发的证书。如果一个用户想鉴别另一个证书的真伪，他就用 CA 的公钥对那个证书上的签字进行验证，一旦验证通过，该证书就被认为是有效的。  

###SCP的传输  

说回到SCP的传输，SCP的传输第一步就是进行SSH的登录动作，然后再基于SSH协议进行文件的传输，整个传输过程是加密的。  

在上面提到的ssh登录流程中，是最基本的登录流程，特点在登录时服务器要求客户端提供账号密码进行验证，其实这样是非常麻烦的，在每次登录或者传输文件时，都要输入账号密码，这对于以偷懒为终极目标的程序员来说这是不能忍受的。  

### SCP的免密传输
我们可以想一想，为什么在每次登录的时候都需要用户输入密码？  

所有人都知道这是为了验证登录者的是否有操作权限，那换一个思路想一下，有没有另外一种方法也能验证登录者有这个登录权限呢？  

ssh协议提供了这样一个机制：  

如果你在服务器拥有一个账号，名为downey  

在某一时刻你需要用一台客户机A登录到服务器上进行操作  

在客户机A的家目录下的.ssh目录下生成一对秘钥，linux下的指令为：

    ssh-keygen -t rsa -P ""
    #ssh-keygen为秘钥生成应用程序
    -t rsa 表示加密类型为rsa

执行上述命令后，系统会提示选择生成秘钥放置的目录和密码，一般为默认选择，一路回车。(但是如果你要追求更高的安全性，你可以选择添加上私钥密码),然后在/home/downey/.ssh目录下就会生成两个文件:id_rsa和id_rsa.pub,其中id_rsa为私钥，而id_rsa.pub为公钥。  


在服务器端的/home/downey/.ssh/目录下新建文件authorized_keys(如果有则不用创建)，将客户端A上刚刚生成的id_rsa.pub文件中的内容复制到服务器端/home/downey/.ssh/authorized_keys文件中(如果里面有内容则另起一行)     

这样就可以直接用scp指令进行文件传输而不用进行账号密码验证了，相当于客户机(操作机器)与服务器建立了安全连接(原理见下文)，如果换一台机器登录，依旧需要验证(因为服务器端的公钥只与这台机器上私钥相匹配)。  

### 注意  

**在这些文件操作的时候，特别需要注意的就是文件的权限问题，很多朋友就是把文件从其他地方复制过来，然后修改文件确保文件内容与目标一致就可以，但是发现这样的操作并没有达到免密传输的效果，很可能就是文件权限出了问题**
### 免密传输的原理
上面提到的SSH登录流程为SSH首次登录的大概讲解，我们不妨来详细探究在免密传输时发生了什么：  

1. 客户端向服务端发送连接请求，消息中附带了代表客户端公钥的摘要信息  

2. 服务端收到客户端的请求，获取客户端公钥的摘要信息，然后遍历authorized_keys这个文件中是否能找到匹配的客户端公钥  

3. 如果能找到匹配的客户端公钥，服务端生成一个随机数，并将这个随机数用匹配的公钥加密，发送给客户端  

4. 客户端收到服务端发来的消息，用私钥进行解密，客户机将解密的数字与用于加密通信的共享会话密钥结合起来，并计算该值的MD5散列，并将散列发送给服务端  

5. 服务端接收到信息，如果返回的消息正确，即完成登录流程。  

SSH详细流程[参考地址](https://www.digitalocean.com/community/tutorials/understanding-the-ssh-encryption-and-connection-process)

####github的免密传输
用过github的盆友可能对免密传输有种熟悉的感觉，没错！在github的配置中，如果需要进行免密传输，流程是：  

1. 在客户机生成一对秘钥，同样是id_rsa,id_rsa.pub  

2. 将id_rsa.pub里的内容添加到github的settings的SSH and GPG keys选项页面中  


同样的，相当于github服务端与机器已经建立用户识别机制，不需要再用账号密码来识别。

好了，关于SCP传输的讨论就到此为止啦，如果朋友们对于这个有什么疑问或者发现有文章中有什么错误，欢迎留言

***原创博客，转载请注明出处！***

祝各位早日实现项目丛中过，bug不沾身.
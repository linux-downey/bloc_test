# Kbuild框架概述
既然我们要来理清楚linux的整个Kbuild系统，那么就免不了要深入到每个控制编译过程的文件中，查看它们到底是如何影响整个makefile的编译过程的。   

先从一个俯瞰的角度来了解一下整个Kbuild系统的框架。  


## 参与编译的文件总览

### 控制文件

#### Top makefile
从语法和使用上和其他的子目录下makefile并无二致，为什么要单独列出来呢，因为它是一切的开始，控制着整个内核编译过程。  

通常情况下，对于内核编译，我们用得最多的，也几乎只用到的几条指令：
```
make *config
make 
make install
....
```

如果你从没有研究过 Kbuild 系统的 top makefile，但是又想跨出第一步，这里就可以是你的开始。  

按照博主的学习思路，学习一个较复杂框架的开始其实最好先不要进入其中，我们可以先把 Kbuild 系统看成一个黑匣子，看它到底提供了什么功能，当我们熟悉它的接口之后，自然就会对它背后的机制和原理充满疑惑，这个时候我们就可以真正打开这个黑匣子，带着自己的问题去研究。(该建议纯属个人经验，如有不到之处，请轻喷，求指导)。  

按照上面的思路，我们可以先执行下面的命令：
```
make help
```
是的，第一步就寻求 help，这并不丢人，这样我们可以很快地了解内核编译所支持的各种参数，通常情况下，终端将输出一大堆help选项,具体的输出结果都有较为详细的解释，这里就不进行具体分析了。  

**** 

##### scripts/
仅仅是靠makefile的功能是很难完成整个内核的编译的，scripts/目录下有相当多的脚本对整个内核编译进行控制，其中列出几个非常重要的文件：
* Kbuild.include : 定义了常用的一系列通用变量与函数，在top Makefile开始时就被include包含，作用于整个内核的编译过程。  
* scripts/Makefile.build : 根据用户传入的参数完成真正核心的编译工作，包括编译目标的确定、递归进入子目录的编译工作等等，作用与整个内核的编译过程。   
* scripts/Makefile.lib ：负责根据用户配置或者top makefile传入的参数，对各类待编译文件进行分类处理，以确定最后需要被编译的文件、需要递归编译的子目录，将结果赋值给相应的变量以供真正的编译程序使用。  
* scripts/link-vmlinux.sh : 对于每一个递归进入的编译目录，编译完成之后，都将在该目录下生成一个build-in.a文件，这个build-in.a文件就是由该目录下或子目录下需要编译进内核的模块打包而成，link-vmlinux.sh将这些文件统一链接起来，生成对应的镜像。  
* scripts/Makefile.host : 这个文件主要控制生成主机程序，严格来说，主机程序并不参与编译过程，它只是作为辅助，比如menuconfig的界面实现，fixdep检查工具等等。 

****  

#### 各级子目录下的Kconfig和Makefile
linux下的Kbuild系统是一个分布式的编译系统，每个模块负责自己的编译和配置选项的提供，这种模块化的分布可以支持非常方便的移植、裁剪和维护。  

所以几乎每个目录下都存在Makefile和Kconfig文件，Kconfig负责该模块下的配置工作，Makefile负责该模块下的编译工作，通常情况下，子目录下的 Makefile 并不负责编译工作，只是提供当前目录下需要编译的目标文件或者需要递归进入的目录(arch目录除外)，交由 scripts/Makefile.build 和 scripts/Makefile.lib 统一处理。  

****  

### 生成文件
在Makefile的编译过程中，将生成各类中间文件，通常情况下，大部分生成的中间文件是可以不用关系的，只需要关注最后生成的 vmlinux，System.map, 系统dtb以及各类外部模块等启动常用文件即可。   

但是，如果要真正了解内核编译背后的原理，了解这些文件的作用是非常有必要的。下面列出一些值得关注的生成文件：  
* System.map : 该文件相当于镜像文件的符号表，记录了内核镜像中所有的符号地址，文件中对应的函数地址对应了程序运行时函数真实的地址，在调试的时候是非常有用的。
* \*/built-in.a : Kbuild系统会根据配置递归地进入到子目录下进行编译工作，最后将所有目标文件链接生成一个总的vmlinux.o,背后的实现机制是这样的：
	对于某一个需要进入编译的目录，将在该目录下生成一个 built-in.a 文件，该 built-in.a 由本目录中所有目标文件以及一级子目录下的 built-in.a 文件使用ar指令打包而成。  
	其二级子目录下的所有目标文件以及三级子目录的 built-in.a 被打包到二级子目录下的 built-in.a 文件中，同样的，二级子目录下的 built-in.a 被打包进一级子目录的 built-in.a 中，层层递归，最后所有子目录下的目标文件都被打包进一级子目录中。
	到根目录下时，只需要将所有一级子目录中的 built-in.a 文件链接到一起即可。  
* .\*.o.d 和 .\*.o.cmd : 不知道你有没有疑惑过内核 Kbuild 系统是如何处理依赖问题的，它处理头文件依赖就是通过这两个文件来记录所有的依赖头文件，对于依赖的目标文件，自然是在编译规则中指定。  
* modules.order 、 modules.build 和 modules.builtin.modinfo : 这两个文件主要负责记录编译的模块，modules.builtin.modinfo记录模块信息，以供 modprobe 使用。  
*  arch/$(ARCH)/boot : 通常在嵌入式的开发中，这个目录下的文件就是开发板对应的启动文件，会因平台的不同而有差异，一般包含这几部分：镜像、内核符号表、系统dtb。   
* .config ：记录用户对内核模块的配置。
* include/generate/* : 内核编译过程将会生成一些头文件，其中比较重要的是 autoconf.h，这是 .config 的头文件版本，以及uapi/目录下的文件，这个目录下的保存着用户头文件。  
* include/config/* ： 为了解决 autoconf.h 牵一发而动全身的问题(即修改一个配置导致所有依赖 autoconf.h 的文件需要重新编译)，将 autoconf.h 分散为多个头文件放在 include/config/ 下，以解决 autoconf.h 的依赖问题。


### 小结
本文旨在对Kbuild系统建立一个大概的印象，作为深入Kbuild系统的一道开胃菜。  








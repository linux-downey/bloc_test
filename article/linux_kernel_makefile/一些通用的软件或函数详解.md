# 通用函数或程序
研究Kbuild系统，了解完它的大致框架，接下来就非常有必要去了解它的一些通用的变量、规则及函数。  

这样，在一头扎进去时，才不至于在各种逻辑中迷路，这一篇博客，就专门聊一聊整个Kbuid系统中常用的一些"套路";

## top makefile中的"套路"
说到常用，首当其冲的自然是top makefile，它是一切的起点。  

### 打印信息中的奥秘
一个软件也好，一份代码也好，如果要研究它，一个最常用的技巧就是尽量获取更多关于它的打印信息。  

幸运的是，top makefile 提供这么一个参数，我们可以执行下面的命令获取更详细的打印信息：
```
make V=1
``` 
或
```
make V=2
```
V 的全拼为 verbose，表示详细的，即打印更多的信息，在编译时不指定V时，默认 V=0 ，表示不输出编译。  

值得注意的是，V=1 和  V=2 并不是递进的关系，V=1时，它会打印更多更详细的信息，通常是打印出所有执行的指令，当V=2时，它将给出重新编译一个目标的理由。而不是我们自以为的 V=2 比 V=1 打印更多信息。  

同时，我们经常能在 top makefile 中发现这样的指令：
```
$(Q)$(MAKE) ...
```
这个 \$(Q) 就是根据 V 的值来确定的，当 V=0 时，\$(Q)为空，当 V=1 时，\$(Q)为@。  

在学习makefile语法时可以知道，在命令部分前添加@，表示执行命令的同时打印该命令到终端。  

**** 


### CONFIG_SHELL
在执行命令时，CONFIG_SHELL 的出场率也非常高，它的原型是这样的：
```
CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
	  else if [ -x /bin/bash ]; then echo /bin/bash; \
	  else echo sh; fi ; fi)
```
其实它的作用就是确定当前Kbuild使用机器上的哪个shell解释器。  

在阅读makefile的时候，为了理解方便，我们可以直接将 CONFIG_SHELL 看成是 /bin/bash。

****  


### FORCE
经常在makefile中能看到这样的依赖:
```
foo : FORCE
    ...
```

这算是makefile中的一个使用技巧，FORCE的定义是这样的：
```
FORCE:
```
是的，它是一个目标，没有依赖文件且没有命令部分，由于它没有命令生成FORCE，所以每次都会被更新。  

所以它的作用就是：当FORCE作为依赖时，就导致依赖列表中每次都有FORCE依赖被更新，导致目标每次被重新编译生成。  



## host 软件






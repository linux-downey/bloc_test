1、makefile usage。
2、makefile 的大致编译框架(需要后面写)。
3、 先将所有相关的小函数部分写出来，根据makefile的规则详细解释清楚(这部分较容易 可以先写)。

4、将所有的小零件拼起来，就可以组成一个个功能的编译完成。



### 交叉编译
本机(目标机)编译是比较方便的，但是无法改变生成的镜像，当然也可以将源码下载到本机(目标机)中进行编译，就可以生成相应的linux镜像。  

但是一般情况下，在嵌入式开发中，不论是网络、内存还是执行速率，目标主机的性能一般不会太高，如果需要编译完整的源码时，用户会更倾向于在PC端构建编译环境以获取更好的编译性能。  

选择在开发机上编译而不是本机编译时，需要注意的一点就是：通常嵌入式开发都是基于arm、mips等嵌入式架构，而PC常用X86架构，在编译时就不能使用开发机上的gcc编译器，因为开发机上编译器是针对开发平台(X86)，而非运行平台(arm、mips)，所以需要使用交叉编译工具链，同时在编译时指定运行的主机平台。  

指令是这样的：

        make arch=arm CROSS_COMPILE=$COMPILE_PATH/$COMPILE_TOOL

也可以在makefile中给相应的arch和CROSS_COMPILE变量赋值，直接执行make指令即可。  

显然，这种交叉编译方式是对linux内核源码的完整编译，主要生成这一些目标文件：
* 生成linux的可启动镜像，通常是zImage或者vmlinuz，这是一个可boot执行的压缩文件
* 伴随着的还有镜像对应的map文件，这个文件对应镜像中的编译符号以及符号的地址信息
* 未编译进内核的模块,也就是在配置时被选为M的选项
* linux内核头文件等等  

在上文中有提到，目标主机中，linux的启动镜像放置在/boot目录下，所以如果我们需要替换linux的镜像，需要替换/boot目录下的以下两个文件：
* linux的可启动镜像,也就是生成的zImage或者vmlinuz
* .map文件

在主机中，模块一般被放置在/lib/modules目录中，如果交叉编译出的版本与本机中模块版本不一致，将无法识别，所以编译出的模块也需要替换。   
## 编译平台
***注：在以下的讨论中，目标主机和本机指加载运行驱动程序的机器，是开发的对象。而开发机指只负责编译的机器，一般指PC机。***

### 本机编译
在对驱动程序进行编译时，一般会有两种不同的做法：
* 直接在目标主机上编译
* 在其他平台上构建交叉编译环境，一般是在PC机上编译出可在目标板上运行的驱动程序

直接在目标主机上编译是比较方便的做法，本机编译本机运行。  

通常，本机系统中一般不会自带linux内核源码的头文件，我们需要做的就是在系统中安装头文件：

        sudo apt-get install linux-headers-$(uname -r)

$(uname -r)获取当前主机运行的linux版本号。  

有了头文件，那么源代码从哪里来呢？答案是并不需要源代码，或者说是并不需要C文件形式的源代码，而是直接引用当前运行的镜像，在编译时，将/boot/vmlinuz-$(version)镜像当成库文件进行链接即可。  

值得注意的是，/boot/vmlinuz-\$(version)是linux启动时读取的镜像，但是在本机中进行驱动程序编译的时候并不会影响到这个镜像，换句话说，即使是指定了obj-y，驱动程序也不会编译到/boot/vmlinuz-$(version)镜像中，自然达不到将驱动编译进内核的效果。    


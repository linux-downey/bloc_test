## C语言数组与指针的那些事儿
在C语言中，要说到哪一部分最难搞，首当其冲就是指针，指针永远是个让人又爱又恨的东西，用好了可以事半功倍，用不好，就会有改不完的bug和通不完的宵。但是程序员一般都有一种迷之自信，总认为自己是天选之人，明知山有虎，偏向虎山行，直到最后大部分用C的人都要被指针虐一遍，所以博主在这里含泪总结当初踩过的坑。

## 指针
首先，明确一个概念，指针是什么，一旦提到这个老生常谈且富有争议性的话题，那真是1000个人有1000种看法。  
在国内的很多教材中，给出的定义一般就是"指针就是地址"，从初步理解指针的角度来说，这种说法是最容易理解的，但是这种说法明显有它的缺陷所在。  
"指针就是地址"这种说法相当于"指针=字面值地址(或者说一个具体的右值)"，这种说法的错误所在就是弄错了指针的本质属性：指针是变量！  
试想一下，如果指针是地址成立，那么二级指针怎么理解呢？地址的地址吗，这明显是错误的。  
下面我们从指针是变量这个原则出发，来分析什么是指针：
1. 作为一个变量，肯定有自己的地址
2. 作为一个变量，肯定有自己的值，和普通变量的区别就是指针变量的值是地址。
3. 从第二点延伸过来，既然指针变量的值是地址，那么那个地址上的内容就是指针变量指向的数据，指针的类型就是指针变量指向数据的类型。
4. 指针有本身的类型，这个本身的类型区别于指向对象的类型。

在这里，最容易弄混的就是指针本身的类型和指针的类型，指针本身的类型是int型，同一平台上所有类型指针都是一样的，长度则是平台相关，经典32位机中为四字节，64位机中为8字节。  
而指针指向数据的类型则是在定义时指定的，比如int *ptr,char *str,在这里，ptr指针所指向的数据类型就是int型，而str指针指向的类型是char型。  
指针的地址：如果一个指针变量存储的值是另一个指针的地址，那这个指针就是二级指针，同样的定义可以递推到多级指针。  

### 指针的操作
解引用：用*来获取指针指向的数据，这个不用多说。
指针的运算：加减运算，需要注意的是，指针的加减运算的粒度是基于指针类型的长度，在下例中：

    int *p = (int*)0x1000;
    char *str = (char*)0x1000;
    p++;
    str++;
    print("p=%d,str=%d\r\n",p,str);
输出结果：
    p=0x1004,str=0x1001
可以看到，p指向int型数据，p++就相当于p+sizeof(int),而str++就相当于str+sizeof(char).

### 关于指针定义的争议
怎么样定义一个指针大家都知道，但是事实上有两种写法：

    int* ptr;
    int *ptr;
咋一看，这俩不是一样吗？其实不一样，第一种定义方法中*靠近类型，而第二种*靠近变量，看到这里，有些朋友就要说了，你个杠精！这不就是个写法问题吗，至于这么纠结吗！  
嘿嘿，这还真不仅仅是个写法问题。背后的逻辑容我细细道来：
* 第一种写法的背后的逻辑是，将int*作为一个整体，将其视为一个类型，即int*、char*与int、char这些一样，都是一种独立的类型，再用这些类型来定义指针变量，从这个角度来看，指针是比较好理解的，而且看起来更能解释得通。
* 第二种写法的背后逻辑是，在指针的定义中，*仅仅是一个标识符，如int *p，表明*后面所接的变量p是一个指针变量，指向数据类型为int型。
其实在早期，大家一直都更倾向于通过第一种去理解指针，为什么后来又有第二种看起来比较生涩的理解，为什么会这样呢？我们来看下面的例子：

    int* p1,p2;
    p2=p1;
我们来编译这个例子，结果是这样：

    warning: assignment makes integer from pointer without a cast [-Wint-conversion]
编译信息显示，p2为普通int型变量，而p1是int型指针变量，这明显违背我们的初衷。如果要定义两个指针变量，我们应该这么做：

    int *p1,*p2;
    p2=p1;
相信到这里，大家能够看出来了，第一种写法背后逻辑的缺陷所在。  
所以现在越来越多的专业书籍都推荐第二种写法，毕竟作为一门底层语言，严谨性比易读性要重要。  

### 对教材错误写法的小看法
说实话，博主学习C语言也是从国内教材开始，一开始接触到的也是指针就是地址的概念，其实于我而言，这种说法让我快速地理解了指针，后来慢慢接触到复杂的逻辑，看了一些更好的教材，慢慢地理解了这些东西的本质，其实博主更倾向于这样去理解这个事情：就像小学老师会告诉我们0是最小的数，这个概念当然是错的，但是这种教法正是可以剥去语言的外壳，让我们避免陷入繁杂的分支和细节中，快速地理解使用和培养兴趣，至于后面的进阶，自然会有进阶的书籍来纠正，就像高中或者大学以至于更高的平台，总会告诉你你之前建立的部分概念并不完全正确，关键是重新建立这个概念并不会太难，因为需要重新建立的时候往往是初级到中级的进阶过程。至于网络上的一些比较过激的言论，我是不抱以支持态度的，无论如何，在我们没有能力接触国外教材的时候，是它们帮我们入了门。


## 指针和数组的区别
废话说了那么多，我们来回到正题，看看指针和数组。不得不说，指针和数组就像孪生兄弟，有时候让人分不清楚，这种情况主要发生在函数参数传递的时候，当一个函数需要一个数组作为一个参数时，我们并不会将整个数组作为参数传递给函数，而是传入一个同类型指针p，然后在函数中就可以使用p[N]来访问数组中元素(这个大家都懂，就不放示例了)。
那么，指针和数组到底是不是同一个东西呢？
我们来看看下面的例子：

    file1.c:
    int buf[10];
    file2.c:
    extern int *buf;
编译结果：

    error: conflicting types for ‘buf’。
从这里可以看出，数组和指针并不相等。至于具体的区别，且听我细细道来。

### 数据访问的本质区别
毫无疑问，我们经常使用指针的数组，也经常混用。但是我们有没有关注过它们背后的执行原理呢？我们看下面的代码：

    int buf[10] = {5};
    int *p = buf;
    *p = 10;
首先，有必要来讲讲数组的初始化，在定义时，如果我们不对数组进行初始化操作，有两种情况：
* 数组为全局变量或者静态变量时，在程序加载阶段默认所有元素都被初始化为0。
* 数组为局部变量，因为数组数据在栈上分配，就延续了了栈上上一次的值，所以这个值是不确定的。
同时，我们可以对其进行初始化，可以全部初始化或者部分初始化，部分初始化时，未被初始化部分全部默认被初始化为0.所以我们常用buf[N]={0}来在定义时初始化一个数组。  
根据C语言的规定，***数组名=数组首元素指针***，所以直接可以用数组名的解引用*buf来访问第一个元素，也可以使用*(buf+N)来访问第N个元素。  
我们需要知道的是，在程序编译的时候，会对所有的变量分配一个地址，这个地址和变量的对应在符号表中被呈现，数组和指针在符号表中的区别就体现在这里：
* 对于数组而言，符号表中存在的地址为数组首元素地址，所以当我们使用素组下标访问元素N时，它执行的是这样的操作
    * 先找到数组首元素地址
    * 目标地址=首地址+sizeof(type)*N，得到被访问元素的地址，type是指针指向数据类型，指针加法参考上面。
    * 解引用(相当于在变量前加*)，从地址上取出被访问元素。
* 对于指针变量而言，符号表中存储的是指针变量的地址，它访问元素时这样的过程：
    * 取出指针变量的地址，从而获取指针变量的值
    * 因为指针变量的值也是一个地址，所以再使用这个地址进行解引用，获取目标元素的值。  
看到这里，我想你已经知道了指针和数组访问数据的本质区别，但是，我们在这里需要讨论的情况并非这两种.  
而是：参数定义为指针，但是以数组的方式引用。这个在函数调用时才是发生得最频繁的，那这时候会发生什么呢?  
这个时候其实就是两种访问方式的结合了，假设定义了指针buf,那么在符号表中存在的就是buf指针的地址(注意是buf的地址，而且buf本身是个指针)，参考上述指针的访问方式.
* 首先，根据buf变量的地址，获取buf变量的值，这个值依旧是个地址。
* 使用第一步中获取的地址进行偏移，得到目标数组元素的地址
* 解引用(相当于在变量前加*)，从地址上取出被访问元素。
到这里，我想你已经大概清楚了数组和指针的区别，以及参数传递时，指针的下标引用背后的原理。
## 数组指针和数组元素指针
在上一小节中，我指出了***数组名=数组首元素指针***的概念，如果朋友们不仔细看，或者自己不去写代码尝试，很容易把它记成了***数组名=数组的指针***这个概念，请特别注意，***数组名=数组的指针***这个概念是完全错误的，这也是数组中非常容易混淆和犯错的地方，我们不妨来看下面的例子：

    char buf[5]={0};
	printf("address of origin buf = %x\r\n",buf);
	printf("address of changed buf = %x\r\n",&buf+1);
输出结果：

    address of origin buf = de157880
    address of changed buf = de157885
我们先定义一个长度为5的buf，buf中首元素地址为0xde157880，然后再打印&buf+1的值，显示为0xde157885，那么问题就来了，为什么明明只是+1，而地址却加了5,5正好是sizeof(buf)。我们再来看看下面的例子：

    char buf[5]={0};
	printf("address of changed buf = %x\r\n",(&buf+1)-buf);
编译时信息如下：

    error: invalid operands to binary - (have ‘char (*)[5]’ and ‘char *’)
从这个报错信息，我们可以看出，&buf的类型为char (*)[5]，为数组指针类型，而buf类型为char *，字符指针类型。  
看到这里，问题也就慢慢地清晰了。在C语言中，数组名是一个特殊的存在，与我们惯有的思维相反，数组名代表数组首元素的指针，而不是数组指针，如果要声明一个数组指针，我们可以这样来声明：char (*p)[5] = buf;
说了这么多，那么，区分数组指针和数组元素指针的意义在哪里呢？参考上面所说的指针的加减运算，即：指针的加减运算的粒度是基于指针类型的长度，数组指针的长度为sizeof(数组)，而数组元素指针是sizeof(单个元素)(再啰嗦一次！数组名为数组元素指针而不是数组指针)。

## 指针数组和二维数组
数组指针是一个指针类型为数组的指针，比如定义一个带有5个char元素数组的指针：char (*buf)[5]，那么指针数组又是什么东西呢？其实指针数组要比数组指针容易理解，它就是一个普通数组，只不过特殊的是数组内所有元素都是指针，比如定义一个字符指针数组：char *buf[5]，注意它们之间的区别;数组指针是一个指针，指针数组是一个数组。  
二维数组，大家可能没有使用过，但是一定听过，二维数组的定义：char buf[x][y]，其中x可缺省，y不能缺省。对于二维数组，我们可以这样理解：***二维数组是一维数组的嵌套，即一个数组的元素为同类型数组。***例如：char array[3][3],我们可以将其理解成array[0],array[1],array[2]是三个char [3]型数组，这种理解可以递推到多维数组，从而来理解二维数组的内存模型：


## 二维数组和二级指针

    "既然一维数组和指针在一定程度上可以"混合使用",那么二维数组肯定也是可以使用二维指针来访问了" —— 某不知名程序员语录  
问：上面这句话有没有什么问题？  
答：大错特错！
很惭愧，博主曾经也是这么认为的，二维数组肯定是可以像一维数组那样使用指针访问，只不过要用二级指针(二维嘛)。  
话不多说，我们先看下面代码：

    char buf[2][2]={{1,2},{3,4}};
	char **p = buf;
	printf("buf[] = %d,%d,%d,%d\r\n",p[0][0],p[0][1],p[1][1],p[1][2]);
输出结果：

    Segmentation fault (core dumped)
在这个示例中，博主的本意是使用二级指针p赋值为二维数组名，然后使用p访问数组中元素，但是结果明显跑偏了，这是为什么?  
有些朋友可能在学习上面的"数组和指针数据访问的本质区别"的时候会想，我只要会用就行了，我要去关注这些底层细节有什么作用？在简单的应用中当然没什么作用，但是在这种时刻就需要对底层扎实的理解了。  
我们来详细分析一下上面代码中的背后访问逻辑：  
* 第一点，我们需要确认的是，二维数组的数组名到底是什么类型的指针。是二维数组中第一个char型元素的指针吗?还是按照上一节"指针数组和二维数组"中说的那样，将二维数组看成一个一维数组，从一维数组的角度看，首元素为buf[0]，那二维数组名就是一个数组指针，类型为char (*)[2]。要验证这个很简单，我们分别编译两份代码：

    代码1：
    char buf[2][2]={{1,2},{3,4}};
	char *p = buf;
编译结果：

    warning: initialization from incompatible pointer type [-Wincompatible-pointer-types]

    代码2：
    char buf[2][2]={{1,2},{3,4}};
	char (*p)[2] = buf;
编译结果：
    无警告信息
 所谓实践出真知，结果很显然，答案是第二种：我们应该将二维数组当成嵌套的一维数组，而数组名为首元素地址，注意，这里的首元素是从一维数组的角度出发，这个首元素的类型可能是普通变量，数组甚至是多维数组。

* 第二点，char **p = buf;这一条怎么去理解呢？根据上面的结论二维数组名buf是char (*)[2]类型，而p是char型二级指针，参数自然不匹配。
* 即使是参数不匹配，但是编译只是警告，而非报错，我们仍然可以执行它。那么执行这个程序的时候又发生了什么呢？我们根据"指针与数组数据访问的本质区别"小节部分来分析：
    * 首先，p的地址是在编译时已知的，程序运行时，通过指针p的地址得到p的值，经过上面的分析，此时p = &buf[0],虽然&buf[0]是数组指针，但是p为char** 类型，所以&buf[0]被强制转换成char**型指针。
    * 在printf函数中访问p[0][0]，事实上访问P[0][0]就先得访问p[0],那么就先找到*p的值，那么*p的值又是多少呢？答案是*p=buf[0][0],*p不是一个地址，而是一个字面值1，访问*p[0]自然会导致Segmentation fault (core dumped)。
鉴于上面的解析部分非常难以理解，而且仅仅是字面讲解几乎无法讲清楚，博主就尝试通过几个示例来进行讲解：

示例1：
    char buf[2][2]={{1,2},{3,4}};
    char **p = buf;
    printf("array name--buf address = %x\r\n",buf);
    printf("&buf[0] address = %x\r\n",&buf[0]);
    printf("Secondary pointer address = %x\r\n",p);
输出：

    array name--buf address = a836a2c0
    &buf[0] address = a836a2c0
    &buf[0][0] address = a836a2c0
    Secondary pointer address = a836a2c0
尽管编译过程有好几个Warning，暂时不去理会，结果显示，至少从数值上来说 p = buf = &buf[0] = &buf[0][0]。

示例2：

    char buf[2][2]={{1,2},{3,4}};
    char **p = buf;
    printf("p[0] = %x\r\n",p[0]);
输出：
    p[0] = 04030201
这个结果就非常有意思了，可以看到，指针p[0]的值，正好是数组buf的四个元素的值(内存中存储顺序将01020304反序存储，这里涉及到大小端的存储问题，不过多赘述)。可想而知，访问p[0][0]的时候会发生什么？按照之前的讲解，我们先将p[0]做相应位移，即p[0]=p[0]+sizeof(char)*0,然后再解引用获取地址上的值，那就是直接取0x04030201地址上的值，结果当然不会是我们所期待的！
再回到示例，为什么p[0]的值会是0x04030201?  
* 首先，我们要知道，p[0]是什么类型，p[0]即为*p,p是二级指针，*p也是一个指针，所以*p的本身的类型为int*，所以它的值为4个字节。
* 根据前面的分析，p = buf = &buf[0] = &buf[0][0]，对p解引用(即*p)相当于取出p地址处的数据，根据int*类型，取四个字节数据，而这四个字节正好就是buf中四个元素。

那如果我们要使用指针来访问二维数组中的元素，该怎么做呢？  
看下面的代码：

    #define ROW     2
    #define COLUMN  2
    char buf[ROW][COLUMN]={{1,2},{3,4}};
	char *p = (char*)buf;
    //访问buf[x][y],即访问p[x*COLUMN+y]
	printf("buf = %d,%d,%d,%d\r\n",p[COLUMN*0+0],p[COLUMN*0+1],p[COLUMN*1+0],p[COLUMN*1+1]);

如果你看懂了之前博主介绍的内容，理解这一份代码是非常简单的。 


好了，关于C语言中指针和数组的讨论就到此为止了，如果朋友们对于这个有什么疑问或者发现有文章中有什么错误，欢迎留言

***个人邮箱：linux_downey@sina.com***
***原创博客，转载请注明出处！***

祝各位早日实现项目丛中过，bug不沾身.
（完）

结语：为了写这一篇博文，感觉发际线又往上走了一公分...


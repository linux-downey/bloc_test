# linux驱动程序——将模块编译进内核
## 模块的加载
通常来说，在驱动模块的开发阶段，一般是将模块编译成.ko文件，再使用

        sudo insmod module.ko
或者
        depmod -a
        modprobe module
将模块加载到内核，相对而言，modprobe要比insmod更加智能，它会检查并自动处理模块的依赖，而insmod出现依赖问题时仅仅是告诉你安装失败，自己想办法吧。  

## 将模块编译进内核
这一章节我们并不关注模块的运行时加载，我们要讨论的是将模块编译进内核。  

在学习内核的Makefile规则的时候就可以知道，将驱动程序编译成模块时，只需要使用：

        obj-m += module.o
指定相应的源代码(源代码为module.c)即可，所以很多朋友就简单地得出结论：如果要将模块编译进内核，只要执行下面的的指令就可以了：

        obj-y += module.o
事实上，这样是行不通的，要明白怎么将驱动程序编译进内核，我们还是得先了解linux源码的编译规则。   

关于linux源码的编译规则和部分细节可以查看我的另一篇博客[linux内核Makefile概览](https://www.cnblogs.com/downey-blog/p/10486863.html)  
***本篇博客的所有实验基于arm平台，beagle bone开发板，内核版本为4.14.79***


## 编译平台
***注：在以下的讨论中，目标主机和本机指加载运行驱动程序的机器，是开发的对象。而开发机指只负责编译的机器，一般指PC机。***

### 本机编译
在对驱动程序进行编译时，一般会有两种不同的做法：
* 直接在目标主机上编译
* 在其他平台上构建交叉编译环境，一般是在PC机上编译出可在目标板上运行的驱动程序

直接在目标主机上编译是比较方便的做法，本机编译本机运行。  

通常，本机系统中一般不会自带linux内核源码的头文件，我们需要做的就是在系统中安装头文件：

        sudo apt-get install linux-headers-$(uname -r)

$(uname -r)获取当前主机运行的linux版本号。  

有了头文件，那么源代码从哪里来呢？答案是并不需要源代码，或者说是并不需要C文件形式的源代码，而是直接引用当前运行的镜像，在编译时，将/boot/vmlinuz-$(version)镜像当成库文件进行链接即可。  

值得注意的是，/boot/vmlinuz-$(version)是linux运行的完整镜像，linux启动时依赖这个文件，但是在本机中进行驱动程序编译的时候并不会影响到这个镜像，换句话说，即使是指定了obj-y，驱动程序也不会编译到/boot/vmlinuz-$(version)镜像中。  


### 交叉编译
本机(目标机)编译是比较方便的，但是无法改变生成的镜像，当然也可以将源码下载到本机(目标机)中进行编译，就可以生成相应的linux镜像。  

但是一般情况下，在嵌入式开发中，不论是网络、内存还是执行速率，主机的性能一般不会太高，如果需要编译完整的源码时，用户会更倾向于在PC端构建编译环境以获取更好的编译性能。  

选择在开发机上编译而不是本机编译时，需要注意的一点就是：通常嵌入式开发都是基于arm、mips等嵌入式架构，而PC常用X86架构，在编译时就不能使用开发机上的gcc编译器，因为开发机上编译器是针对开发平台(X86)，而非运行平台(arm、mips)，所以需要使用交叉编译工具链，同时在编译时指定运行的主机平台。  

指令是这样的：

        make arch=arm CROSS_COMPILE=$COMPILE_PATH/$COMPILE_TOOL

也可以在makefile中给相应的arch和CROSS_COMPILE变量赋值，直接执行make指令即可。  

显然，这种交叉编译方式是对linux内核源码的完整编译，主要生成这一些目标文件：
* 生成linux的可启动镜像，通常是zImage或者vmlinuz，这是一个压缩文件
* 伴随着的还有镜像对应的map文件，这个文件对应镜像中的编译符号
* 未编译进内核的模块,也就是在配置时被选为M的选项
* linux内核头文件等等  

在上文中有提到，linux的完整镜像放置在/boot目录下，/boot目录下放置着linux的启动文件，所以如果我们需要替换linux的镜像，需要替换/boot目录下的以下两个文件：
* linux的可启动镜像,也就是生成的zImage或者vmlinuz
* .map文件

在主机中，模块一般被放置在/lib/modules目录中，如果交叉编译出的版本与本机中模块版本不一致，将无法识别，所以编译出的模块也需要替换。   


## 驱动程序编译进内核
根据上文，可以得出的结论是：在试图将驱动程序编译进内核时，我们需要编译完整的linux内核源码以生成相应的镜像文件，然后将其替换到目标主机的/boot目录下即可。  

那么，怎样将驱动的源码C文件编译进内核呢？  

这个问题得从makefile的执行流程说起：
### make的执行
首先，如果你有基本的linux内核编译经验，就知道在编译linux源码前，需要进行config(配置)，以决定哪些部分编译进内核、哪些部分编译成模块，  

通常使用make menuconfig，不同的config方式通常只是选择界面的不同，其中稍微特殊的make oldconfig则是沿用之前的配置。

在配置完成之后将生成一个.config文件，makefile根据.config文件选择性地进入子目录中执行编译工作。  

流程基本上是这样，但是我们需要知道更多的细节：
* make menuconfig执行的原理是什么？
* 顶层makefile是怎样执行子目录中的编译工作的？

答案是这样的：
* make menuconfig肯定是读取某个配置文件来陈列出所有的配置选项，递归地进入到子目录中，发现几乎每个子目录中都有一个名为Kconfig的文件，这个文件负责配置驱动在配置菜单中的行为，make menuconfig就是读取这些文件来显示配置项。  
* 递归地进入到每个子目录中，发现其中都有一个makefile中，可以想到，makefile递归地进入子目录，然后通过调用子目录中的makefile来执行各级子目录的编译。  

整个linux内核的编译都是采用一种分布式的思想，需要需要添加一个驱动到模块中，我们需要做的事情就是：
* 将驱动源文件放在内核对应目录中，一般的驱动文件放在drivers目录下，字符设备放在drivers/char中，块设备就放在drivers/blok中，文件的位置遵循这个规律，如果是单个的字符设备源文件，就直接放在drivers/char目录下，如果内容较多足以构成一个模块，则新建一个文件夹。  
* 如果是新建文件夹，因为是分布式编译，需要在文件夹下添加一个Makefile文件和Kconfig文件并修改成指定格式，如果是单个文件直接添加，则直接修改当前目录下的Makefile和Kconfig文件将其添加进去即可。  
* 如果是新建文件夹，需要修改上级目录的Makefile和Kconfig，以将文件夹添加到整个源码编译树中。  
* 执行make menuconfig，执行make
* 将生成的新镜像以及相应boot文件拷贝到目标主机中，测试。  

## 编译示例










# systemd-5-timer 的使用
在 systemd 的简介篇中，我们就知道，systemd 并不仅仅是 Upstart 或者 sysvinit 的替代品，相对来说，它有更大的野心：试图统一整个系统上用户空间的服务，因此，对于传统 linux 系统上相对独立的服务比如：syslog、udev、crontab 等，或是将其移植到 systemd 中，或是开发出替代方案。  

在传统的 linux 机器上，crontab 通常都是使用 crontab 实现的，而现在在部署了 systemd 的系统上，可以使用 的 systemd timer 服务，同时，旧版的 crontab 也还是支持的。  

如果你的系统上确实使用了 systemd，建议使用 timer 而不是旧版的 crontab，一方面，针对具体服务而言，基于 systemd 实现的 timer 定时服务配置更加方便且不失灵活性，另一方面，针对使用者而言，由于依附于 systemd 系统，直接通过 systemd 的命令来操作，对用户来说使用更方面，且日志被统一记录，维护起来也更得心应手。  


## systemd timer 简介
每个定时服务都对应一个定时单元，定时单元提供基于时间的事件，当事件产生时，定时单元对应的服务就会执行相应的动作，至于定时事件如何产生、产生之后执行怎样的动作，这由管理员的配置决定。  

定时单元是一个以 .timer 为后缀的文件，该文件符合单元文件的格式(单元文件介绍可以参考前面的章节：TODO)，定时单元匹配的服务可以通过 Unit= 选项显式指定。 若未指定，则默认是与该单元名称相同的 .service 单元,例如 foo.timer 默认匹配 foo.service 单元。  

**需要特别注意的是：如果在启动时间点到来的时候，匹配的单元已经被启动， 那么将不执行任何动作，也不会启动任何新的服务实例。 因此，那些设置了 RemainAfterExit=yes(当该服务的所有进程全部退出之后，依然将此服务视为处于活动状态) 的服务单元一般不适合使用基于定时器的启动。 因为这样的单元仅会被启动一次，然后就永远处于活动(active)状态了，当然，也不要周期性地执行那些可能长时间执行的服务，重复的启动是无效的。**  


## 依赖
各种类型的单元文件有不同的隐含依赖和默认依赖，对应定时服务而言，它的依赖如下。  

### 隐含依赖
定时器单元自动获得对匹配服务的 Before= 依赖。也就是相当于 foo.service 中添加 Before=foo.timer. 

### 默认依赖
除非明确设置了 DefaultDependencies=no ，否则 timer 单元将会自动添加下列依赖关系：

* Requires=sysinit.target, After=sysinit.target, Before=timers.target 依赖； 以及 Conflicts=shutdown.target, Before=shutdown.target 依赖(确保在关机前干净的停止)。 只有那些在系统启动的早期就必须启动的定时器，以及那些必须在关机动作的结尾才能停止的定时器才需要设置 DefaultDependencies=no 。

* 如果在 timer 单元中设置了至少一个 OnCalendar= 选项， 那么将会自动获得 After=time-sync.target 依赖， 以避免在系统时间尚未正确设置的情况下启动定时器。


## timer 的操作
上文中有提到,systemd 定时服务对应的定时单元文件为 .timer 后缀的文件, .timer 文件中通用配置可以参考单元文件的通用介绍([Unit] 和 [Install] 小节),同时, .timer 文件中必须包含一个 [Timer] 小节,该小节主要是针对定时方面的配置,具体的配置可以参考下文.  

当 .timer 文件被配置完成时,需要使用 systemctl daemon-reload 重新加载 systemd 配置,随后的操作方式就和 systemd 中其它的操作一样了,比如 start/stop/enable 等等.start 一个定时服务也就代表开启这个定时器(这个定时器是逻辑上的概念).   

需要注意的是,对于一个 .service 文件比如 foo.service,执行 systemctl start foo 和 systemctl start foo.service 是同样的效果,而对于其它后缀的文件,不要省略后缀,必须写成 systemctl start foo.timer.  


## [Timer]配置选项

### OnActiveSec=, OnBootSec=, OnStartupSec=, OnUnitActiveSec=, OnUnitInactiveSec=
定义相对于特定时间点之后一段时间的单调定时器： 
* OnActiveSec= 相对于该单元自身被启动的时间点； 
* OnBootSec= 相对于机器被启动的时间点，也就是内核开始运行的时间点； 
* OnStartupSec= 相对于 systemd 被首次启动的时间点，也就是内核启动init进程的时间点； 
* OnUnitActiveSec= 相对于匹配单元最后一次被启动的时间点； 
* OnUnitInactiveSec= 相对于匹配单元最后一次被停止的时间点；

可以组合使用这些指令(既可以将某个指令使用多次，也可以将多个指令一起使用)， 例如，通过同时使用 OnBootSec= 与 OnUnitActiveSec= 指令， 就可以实现在系统启动后的某个时间点启动匹配单元， 并且之后每隔一段时间周期性的反复启动匹配单元。  

指令的值是一个时间长度， 可以使用下面的时间单位后缀：us(微秒), ms(毫秒), s(秒), m(分), h(时), d(天), w(周) 。 如果省略了时间单位，那么表示使用默认单位"秒"。 可以同时使用多个时间单位，例如 "OnBootSec=5h 30min" 表示系统启动之后的5小时30分钟。 

如果定时器单元在启动时已经超过了 OnBootSec= 或 OnStartupSec= 指定的时间， 那么将会立即启动匹配的单元。 但是对于使用其他指令定义的定时器， 超过了就等于错过了，不会尝试去补救。

这几个指令定义的定时器都是基于单调时间的单调定时器(monotonic timer)，所谓"单调时间"的意思是从开机那一刻(零点)起， 只要系统正在运行，该时间就不断的单调均匀递增(但在系统休眠时此时间保持不变)，永远不会往后退，并且与时区也没有关系。 即使在系统运行的过程中，用户向前/向后修改系统时间，也不会对"单调时间"产生任何影响。

如果给某个指令赋予一个空字符串， 则表示 撤销该指令之前已设置的所有定时器。

注意， 这些指令设置的定时器并不必然在所设置的精准时间点上启动匹配单元， 因为它们还受到下文 AccuracySec= 选项的影响。  


### OnCalendar=
定义基于挂钟时间(wallclock)的日历定时器，值是一个日历事件表达式， 这是与传统cron任务类似的定时器。如果定时器单元在启动时已经超过了该指令设置的某个触发时间，那么错过就错过了，不会尝试去补救，只能等待下一个触发时间。  

可以多次使用此指令以设置多个定时器，如果被赋予了一个空字符串，则表示撤销该指令之前已设置的所有定时器。  

该指令定义的定时器是基于挂钟时间(wallclock)的，所谓"挂钟时间"是指真实世界中墙上挂钟的时间，在操作系统中实际上就是系统时间，这个时间是操作系统在启动时从主板的时钟芯片中读取的， 在系统的运行过程中，时间同步服务会不断的根据NTP时间服务器提供的时间对系统时间进行校准，而系统管理员也可能会手动的向前/向后修改系统时间，所以，这个时间既不一定是单调递增的、也不一定是均匀递增的。

注意，该指令设置的定时器并不必然在所设置的精准时间点上启动匹配单元， 因为它们还受到下文 AccuracySec= 选项的影响。

可以多次设置此选项。

### AccuracySec=
设置定时器的触发精度。默认值是一分钟。定时器并不必然在所设置的精准时间点上启动匹配单元， 而是在所设置的精准时间点为起点的一小段时间窗口范围内的某个时间点上启动匹配单元， 这个时间窗口的起点由 OnCalendar=, OnActiveSec=, OnBootSec=, OnStartupSec=, OnUnitActiveSec=, OnUnitInactiveSec= 中设置的时间点决定， 而这个时间窗口的长度则由当前选项决定。   

例如设置定时为 00:00:00 时执行某服务,当定时触发时,并不能保证马上执行对应的服务,默认情况下只能确保这个服务会在 00:00:00 到 00:00:01 之间被执行,至于具体什么时候被执行,这是随机且不确定的.如果需要达到更高精度的执行效果,可以将当前选项设置为 1us.  

### RandomizedDelaySec=
将此单元的定时器随机延迟一小段时间， 这一小段时间的长度 介于零到该指令设置的时间长度之间， 以均匀概率分布。 默认值是零，表示不延迟。 

定时器单元在每次迭代前确定这个随机值的大小， 并简单的把它加到下一次启动匹配单元的时间点上， 此选项可以将大量在同一时间点触发的定时器 均匀的分摊到一小段时间范围内触发， 以避免造成资源竞争。 

AccuracySec= 允许将一段时间内分散的定时器事件集中到一点，以减少CPU唤醒。 而本指令正好相反， 允许将集中在一点的定时器事件分散到一小段时间范围内。如果同时使用 RandomizedDelaySec= 与 AccuracySec= 选项， 那么首先添加一个随机的时间， 然后结果可能进一步被平移， 以和系统上其他定时器事件合并。 因为默认设置 AccuracySec=1min, RandomizedDelaySec=0 鼓励将多个定时器事件聚合在一起。 所以如果希望尽可能均匀分散定时器事件，那么应该将 RandomizedDelaySec= 设为一个较大的值，同时设置 AccuracySec=1us

### OnClockChange=, OnTimezoneChange=
boolean 类型参数。如果为true，则当系统时钟（CLOCK_REALTIME）相对于单调时钟（CLOCK_MONOTONIC）跳变时，或在修改本地系统时区时，将触发服务单元。这些选项可以单独使用，也可以与同一计时器单元中的其他计时器表达式（请参见上文）结合使用。这些选项默认为false。  

### Unit=
该定时器单元的匹配单元， 也就是要被该定时器启动的单元。参数是一个不以 ".timer" 结尾的单元名。 默认值是 与此定时器单元同名的服务单元(见上文)。 建议将定时器单元的名字 与被该定时器启动的匹配单元的名字保持一致 (也就是仅单元后缀名不同)。

### Persistent=
此选项仅对 OnCalendar= 指令定义的日历定时器有意义。 若设为"yes"，则表示将匹配单元的上次触发时间永久保存在磁盘上。  
保留到磁盘上是为了预防关机的的情况,在这种情况下,定时服务本该是要被触发的,但是因为关机或者 timer 服务处于 inactive 的状态而错过了服务的启动,

因此，当定时器单元再次被启动时，如果检测到有服务定时任务被错过，就会立即启动对应服务。这样就不会因为关机而错过必须执行的任务。 默认值为 no.  

### WakeSystem=
若设为"yes"， 则表示当某个定时器到达触发时间点时， 唤醒正在休眠的系统并阻止系统进入休眠状态。 注意， 此选项仅确保唤醒系统， 而不关心任务执行完成之后是否需要再次休眠系统。 默认值为 no  

### RemainAfterElapse=
接受一个布尔值。 若设为"yes"(默认值)， 则表示保持已过期定时器单元的已加载(loaded)状态，并且依然允许查询其状态。 若设为"no"，则表示卸载已过期并且将来也不会被继续触发的定时器单元。 对于那些仅需要临时执行一次、随后即被丢弃的定时器单元来说，设为"no"是首选。 但是需要注意， 对于那些仅需要触发一次的定时器单元来说， 如果 RemainAfterElapse=yes ， 那么该定时器将不会被再次触发，也就是可以确保仅被触发一次； 如果 RemainAfterElapse=no ， 那么该定时器就有可能会被再次触发，也就是有可能被多次触发。 所以将此选项设为"no"时应该特别小心谨慎。 默认值为 yes


## 时间与日期的规范
定时服务自然是和时间相关的,如何表示时间需要进行规范,下列是 systemd 中对时间的规范:  

### 时长的规范
时长就是时间长度,又被称为时间间隔,表示一段时间的长度.格式为一个空格分隔的带有时间单位的时长序列,比如:2h 30min,这种定义方式是非常容易理解的,需要注意的是,时长的现实使用使用英文单位,不受系统本地化设置的影响(比如注意全角与半角符号的区分).  

systemd 在解析时长字符串(用于赋值)的时候，可以接受的时间单位如下：
* usec, us, µs                微秒
* msec, ms                    毫秒
* seconds, second, sec, s     秒
* minutes, minute, min, m     分钟
* hours, hour, hr, h          小时
* days, day, d                天
* weeks, week, w              周
* months, month, M            月
* years, year, y              年

如果没有指定时间单位，一般默认为秒，但是偶尔也有例外,这种例外情况会被标记出来。 此外，在某些场合还可以接受纳秒单位("ns", "nsec")。 注意，时长的赋值不受系统本地化设置的影响，必须只能使用英文时间单位， 不可使用例如"小时/分钟/秒"之类的非英文时间单位。  

下面是一些有效的时长字符串实例：

```
2 h
2hours
48hr
1y 12month
55s500ms
300ms20s 5day
```

### 墙上时钟事件
墙上时钟事件是在 .timer 文件中由 OnCalendar= 指定的事件,事件对应的墙上时间规范同样是非常易懂的,可以把它想象成一种专门用于时间的正则表达式,例如:

Thu,Fri 2012-*-1,5 11:12:13

表示： 2012年任意月份的1号或5号 且为周三或周五的日子的11点12分13秒

"星期"部分是可选的。 若指定， 则必须使用英文三字母缩写(例如"Wed")或英文全称(例如"Wednesday")， 大小写无关。可以使用 "," 依次列出多个日子， 也可以使用 ".." 表示一个范围， 还可以将多个范围( ".." ) 用 "," 依次列出。  

对于"年-月-日"与"时:分:秒"两部分中的 每个子部分， 都可以： 使用 "*" 表示匹配任意值、 使用 "," 依次列出多个值、 使用 "/整数" 后缀表示以此整数为间隔不断向后重复跳跃(例如在表示分钟的部分"3/10"等价于"3,13,23,33,43,53")、 使用 ".." 表示一个范围。 最后， 还可以用逗号(,)依次列出多个重复(/)与范围(..)。

在日期部分还可以使用 "~" 表示一个月中的"倒数第几天"。 例如 "*-02~03" 表示"2月的倒数第3天"， "Mon *-05~07/1" 表示"5月的最后一个星期一"。

注意，"秒"部分比较特殊， 可以使用十进制小数以表示更高的精度(最多六位小数)， 例如"3.33/10.05"等价于"3.33,13.38,23.43,33.48,43.53,53.58"。

若省略了"年-月-日" 则等价于当前日期； 若省略了"时:分:秒"则等价于"00:00:00"； 若省略了":秒"则等价于":00".  

"时区"部分遵守与时间戳一样的规则， 要么必须省略、要么必须丝毫不差的设为"UTC"三个大写字母、要么必须设为一个符合IANA格式的时区。 省略时区表示使用本机时区，为了保持最佳的兼容性，强烈建议使用"UTC"时区(世界统一时间)。  

下面这些左侧的特殊表达式可以用作右侧的标准化形式的缩写：
```
    每分钟 → *-*-* *:*:00
    每小时 → *-*-* *:00:00
    每天   → *-*-* 00:00:00
    每月   → *-*-01 00:00:00
    每周   → Mon *-*-* 00:00:00
    每年   → *-01-01 00:00:00
    每季度 → *-01,04,07,10-01 00:00:00
    半年度 → *-01,07-01 00:00:00
```
出于测试和验证目的，可以使用 systemd-analyze(1) 的 calendar 命令规范化给定的日历事件。 此工具还会计算出给定日历事件的下一个过期时间。例如:

```
systemd-analyze calendar *-*-* *:*:00
```












测试一条指令设置多次

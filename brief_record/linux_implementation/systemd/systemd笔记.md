systemd 笔记,纯翻译:
如果你有良好的人脉关系或者擅长阅读的话,你可能已经知道这篇博客将要讲什么.即使这样你可能依旧会发现这篇博客其实很有趣.所以,拿上一杯咖啡,然后坐下,听我细细道来.  

这个博客的故事有点长,用一句话总结就是:我们正在尝试一个新的初始化系统,而且这很有趣.  

## 1号进程
在每个类 unix 系统上都会存在一个特殊的 1 号进程,它由内核创建,是所有进程的父类,不属于任何进程的子进程.所以它可以做很多其它进程做不了的事,同时也存在相应的责任,比如在系统启动阶段启动和维护用户空间.  

历史上 linux 中的 1 号进程是 sysvinit 的软件包,它也存在相当长一段时间了,很多替代品被发明出来,其中 Upstart 脱颖而出,几乎在所有的主要发行版中使用,用作系统用户空间的启动. 

正如上文提到的,一个初始化系统的核心功能就是启动系统的用户空间,同时,一个好的初始化系统应该是快速的,不幸的是,传统的 sysv 初始化系统并没有达到预期.  

一个高效的初始化系统应该具备两种特征:
* 减少启动工作
* 将启动工作更多地并行化

这两点是什么意思呢?  
减少启动工作的理念在于服务应该只有在需要的时候才会启动,有些服务是在系统一开始就需要的,比如 syslog,D-bus 系统等等,而有些服务并不是这样,比如蓝牙守护进程只有用户在需要使用时才会用到,没有必要在开机时就提供,打印机可以如此,只有在用户需要打印的时候,打印机的服务才应该启动,同时,如果系统没有连接到网络,依赖于网络的一些组件也可以不启动.  

将启动工作并行化指的是如果我们要运行某些服务,我们不必要串行地运行(sysvinit是这么做的),而是同时地将这些服务一并运行,这时候就可以将 CPU 和磁盘 IO 的利用率大大提升,以降低启动时间.  

## 动态化的硬件和软件
无论是从软件还是硬件来说,现代的操作系统是高度动态化的,在系统运行时,硬件重复地接入或者移除,与硬件相关的软件也必须重复这种过程,初始化系统负责监听这些动态的修改,维护这些服务.  

当前大多数尝试并行化启动的系统还是会存在一系列的序列化,比如 Avahi 依赖于 D-Bus,就需要 D-bus 先启动,然后 Avahi 再启动,其它的服务也是类似.实际上 linux 中存在很多的依赖关系,所以也就存在序列化的现象.  

或许我们应该考虑,我们说的 Avahi 依赖于 D-Bus 到底依赖的是什么,很可能就是依赖于两者之间的通信接口,比如 socket,如果是这样,被依赖的服务可以先将通信用的 socket 启动,其它的依赖进程也就不需要等依赖进程完全启动,也可以同步启动,并不会影响实际的结果.  

举个例子,大部分的进程都会依赖于 syslog,启动 syslog 之前先启动通信使用到的 scoket,然后再启动 syslog ,其它进程也可以同时启动,其它进程向 syslog 打印信息时,只是将信息放在 syslog 对应 socket 的缓冲区中,只要缓冲区没有满,其它进程就不会阻塞,当 syslog 进程启动时,再统一处理缓冲区中的内容,这并不会有什么问题,但是却大大地加速了系统的启动.  

套接字可以集中被一次性创建,然后可以通过 exec() 函数进行传递

这并不是什么崭新的想法,这种做法在苹果的 MacOS 上实现了,但是这种巧妙的设计并没有在苹果阵营之外的系统上应用过.   


现代的 linux 倾向于使用 D-Bus 而不是 AF_UNIX socket.  
总而言之,socket 和 D-Bus 的组合使得我们可以并发地启动各个守护进程,不需要其它的同步手段.  同时可以做一些 lazy-loading,如果某个进程使用得很少,我们大可以在第一次使用的时候启动,而不是在 boot 阶段就将其启动.  

## 文件系统的并行化
如果查看当前发行版引导过程的序列化图，则同步点不仅仅是守护程序启动：最为显着的是文件系统相关的工作：挂载，fscking，配额。现在，在启动时会花费大量时间空闲，直到/ etc / fstab中列出的所有设备都显示在设备树中，然后对其进行fsck'，挂载和配额检查（如果启用）。只有在完全完成之后，我们才能继续启动实际的服务。 我们可以改善吗？事实证明我们可以。 Harald Hoyer提出了使用古老的autofs系统的想法： 就像connect（）调用表明服务对另一个服务感兴趣一样，open（）（或类似调用）表明服务对特定文件或文件系统感兴趣。因此，为了提高并行化的程度，我们可以让那些应用程序仅在它们正在寻找的文件系统尚未挂载且随时可用时才等待：我们设置了一个autofs挂载点，然后设置了文件系统由于正常启动完成了fsck和quota，我们将其替换为实际安装。当文件系统尚未准备好时，访问将由内核排队，并且访问进程将被阻止，但是只有一个守护程序和只有一个访问。这样一来，我们甚至可以在所有文件系统完全可用之前就开始启动守护程序-不让它们丢失任何文件并最大化并行化。 毕竟，通常将服务二进制文件存储在其中，对于/而言，并行化文件系统作业和服务作业就没有意义。但是，对于文件系统（例如/ home）来说，它们通常更大，甚至被加密，并且可能是远程的，并且很少由通常的启动守护程序访问，这可以大大缩短启动时间。可能没有必要提及这一点，但是虚拟文件系统（例如procfs或sysfs）绝对不应通过autofs挂载。 如果有些读者会发现将autofs集成到init系统中有点脆弱甚至奇怪，甚至在事物的“疯狂”方面，我也不会感到惊讶。但是，经过广泛的研究，我可以告诉您这实际上感觉很正确。在这里使用autofs只是意味着我们可以创建挂载点，而不必立即提供支持的文件系统。因此，实际上它仅延迟访问。如果应用程序尝试访问autofs文件系统，而我们用很长时间将其替换为真实文件系统，它将挂起可中断的睡眠，这意味着您可以安全地取消它，例如通过C-c。还要注意，在任何时候，如果挂载点最终都不能挂载（可能是因为fsck失败），我们可以告诉autofs返回一个干净的错误代码（例如ENOENT）。因此，我想我想说的是，尽管乍一看将autofs集成到init系统中似乎很冒险，但是我们的实验代码表明，这种想法在实践中出奇地好-如果这样做是出于正确的理由，并且正确的方法。 还要注意，这些应该是直接的autofs挂载，这意味着从应用程序角度来看，经典挂载点和基于autofs的挂载点之间没有什么有效的区别

使用 autofs 创建一个临时挂载点

## 让第一个可用的用户进程尽量小
另一个从 MacOS 中学到的逻辑是:在启动过程中尽量地少创建进程,在 linux 的启动中,大量地使用 shell 脚本来执行某些任务,每次 shell 脚本都会创建新的进程,这会让整个启动变得缓慢,比如 grep,awk,cut,sed 等命令的频繁使用,或者我们可以使用 C 重写这些 shell 脚本.  

在系统启动之后我们可以使用 echo $$ 来查看当前可用的进程号,linux 上通常是 1500+,而 MacOS 上是 150+,这种进程启动数量的差异是巨大的.  

## 跟踪进程
启动和维护服务的系统的中心部分应该是过程保姆：它应该监视服务。如果它们关闭，请重新启动它们。如果它们崩溃了，它应该收集有关它们的信息，并留给管理员使用，并将该信息与崩溃转储系统（如abrt）以及日志系统（如syslog或审计系统）中的可用信息进行交叉链接。 它还应该能够完全关闭服务。这听起来很容易，但是比您想的要难。传统上，在Unix上，执行双叉处理的进程可以逃避其父进程的监视，而旧的父进程将不会了解新进程与其实际启动的进程之间的关系。例如：当前，当您关闭Apache时，具有双重分支的行为异常的CGI脚本不会终止。此外，除非您通过名称和用途知道它与Apache的关系，否则您甚至无法弄清楚它与Apache的关系。 因此，我们如何跟踪流程，以使它们无法脱离保姆，并且即使它们分叉了数十亿次，我们也可以将它们作为一个单元进行控制？ 不同的人为此提出了不同的解决方案。我在这里不做详细介绍，但至少可以说基于ptrace或netlink连接器的方法（一个内核接口，它允许您每次系统fork（）s或exit（）上的任何进程都获得netlink消息。 s）有些人已经调查并实施，被批评为丑陋且扩展性不强。 那么我们该怎么办？好吧，因为相当长一段时间以来，内核都知道控制组（也称为“ cgroups”）。基本上，它们允许创建一组流程组的层次结构。层次结构直接暴露在虚拟文件系统中，因此易于访问。组名基本上是该文件系统中的目录名。如果某个进程属于特定的cgroup fork（），则其子进程将成为同一组的成员。除非它具有特权并有权访问cgroup文件系统，否则它无法转出其组。最初，cgroup是出于容器目的而引入内核的：某些内核子系统可以对某些组的资源实施限制，例如限制CPU或内存使用。传统资源限制（由setrlimit（）实现）是（大多数）每个进程。另一方面，cgroups使您可以对整个进程组实施限制。 cgroups还可用于在即时容器用例之外实施限制。例如，您可以使用它来限制总的内存或Apache及其所有子级可以使用的CPU。然后，行为不正常的CGI脚本不再能够通过简单地分叉来逃避setrlimit（）资源控制。 除了对容器和资源进行限制外，cgroup对跟踪守护进程也非常有用：cgroup成员资格由子进程安全地继承，它们无法逃脱。有一个可用的通知系统，以便当cgroup空运行时可以通知主管进程。您可以通过阅读/ proc / $ PID / cgroup找到进程的cgroup。因此，cgroups是跟踪保姆过程的一个很好的选择。




# systemd-2-systemd 守护进程
通过前面两章的铺垫,相信各位对 systemd 的基本概念已经有了一定的了解:systemd 是一个专用于 linux 操作系统的系统与服务管理器,在大部分支持 systemd 的机器上,它都是作为 PID 为 1 的 init 进程启动的,启动并维护各种用户空间的服务.  

作为验证,你可以通过 ps -ef | head 指令查看当前系统中的进程列表,在我的 ubuntu18 机器上,PID 为 1 的进程为 /sbin/init,而 /sbin/init 是指向 /lib/systemd/systemd 的一个软链接.   

因此,systemd 系统的守护进程就是 /lib/systemd/systemd,作为系统的 init 进程启动.因此 systmed 代表一个管理系统,同时也表示该管理系统对应的执行程序,所以为了避免混淆,systemd 依旧表示整个管理系统,而对应的守护进程统一使用 /lib/systemd/systemd 来表示.  


## 概念
systemd 将各种系统启动和运行相关的对象， 表示为各种不同类型的单元(unit)，并提供了处理不同单元之间依赖关系的能力.大部分单元都静态的定义在单元文件中 ， 但是有少部分单元则是动态自动生成的： 其中一部分来自于其他传统的配置文件(为了兼容性)， 而另一部分则动态的来自于系统状态或可编程的运行时状态。 单元既可以处于活动(active)状态也可以处于停止(inactive)状态， 当然也可以处于启动中(activating)或停止中(deactivating)的状态。 还有一个特殊的失败(failed)状态， 意思是单元以某种方式失败了 (退出时返回了错误代码、进程崩溃、操作超时、触碰启动频率限制)。 当进入失败(failed)状态时， 导致故障的原因 将被记录到日志中以方便日后排查。 需要注意的是， 不同的单元可能还会有各自不同的"子状态"， 但它们都被映射到上述五种状态之一。  

各种不同的单元类型如下:
* service 单元。用于封装一个后台服务进程。
* ket 单元。 用于封装一个系统套接字(UNIX)或互联网套接字(INET/INET6)或FIFO管道。
* target 单元。 用于将多个单元在逻辑上组合在一起。
* device 单元。用于封装一个设备文件，可用于基于设备的启动。
* mount 单元。 用于封装一个文件系统挂载点(也向后兼容传统的 /etc/fstab 文件)。
* automount 单元。 用于封装一个文件系统自动挂载点，也就是仅在挂载点确实被访问的情况下才进行挂载。 它取代了传统的 autofs 服务。
* timer 单元。 用于封装一个基于时间触发的动作。它取代了传统的 atd, crond 等任务计划服务。
* p 单元。 用于封装一个交换分区或者交换文件。 它与 mount 单元非常类似。
* path 单元。 用于根据文件系统上特定对象的变化来启动其他服务。
* slice 单元。 用于控制特定 CGroup 内(例如一组 service 与 scope 单元)所有进程的总体资源占用。
* scope 单元。它与 service 单元类似，但是由 systemd 根据 D-bus 接口接收到的信息自动创建， 可用于管理外部创建的进程。

systemd 能够处理各种类型的依赖关系， 包括依赖与冲突(也就是 Requires= 与 Conflicts= 指令)， 以及先后顺序(也就是 After= 与 Before= 指令)。 注意， 上述两种类型的依赖关系(依赖与冲突、先后顺序)之间是相互独立的(无关的)。 举例来说，假定 foo.service 依赖于(Requires) bar.service 但并未指定先后顺序， 那么这两个服务将被同时并行启动。 不过在两个单元之间 既存在依赖关系也存在先后顺序的情形也很常见。 另外需要注意的是， 大多数依赖关系都是由 systemd 隐式创建和维护的， 因此没有必要额外手动创建它们。  

应用程序和单元(透过依赖关系)可能会查询其他单元的状态变化.在 systemd 中， 这种查询被包装为"任务"(job)并被作为"任务队列"进行管理。 任务的执行结果可能成功也可能失败，但是任务的执行顺序是依照任务所属单元之间的先后顺序确定的。

在系统启动时，systemd 默认启动 default.target 单元， 该单元中应该包含所有你想在开机时默认启动的单元。 但实际上，它通常只是一个指向 graphical.target (图形界面) 或 multi-user.target (命令行界面，常用于嵌入式或服务器环境， 一般是 graphical.target 的一个子集) 的符号连接。

systemd 只在内存中加载最小化的一组单元。 只有至少满足下列条件之一的单元，才会被加载到内存中：

* 处于 活动(active)、启动中(activating)、停止中(deactivating)、失败(failed) 状态之一(也就是停止(inactive)之外的状态)

* 至少有一个作业正在作业队列中

* 至少有一个其他已经加载到内存中的单元依赖于它

* 仍然占有某些资源 (例如一个已停止的服务单元的进程忽略了终止请求，仍在逗留)

* 被 D-Bus 调用以程序化的方式固定到了内存中

只要有需要，systemd 就会自动从磁盘加载所需的单元。 因此实际上用户并不能显而易见的看到某个单元是否已被加载到内存。 使用 systemctl list-units --all 命令可以显示当前已加载到内存中的所有单元。 不满足加载条件(见上文)的单元会被立即从内存中卸载，并且它的记帐数据(accounting data)也会被清空。 不过，因为每当一个单元关闭时，都会生成一条日志记录声明该单元所消耗的资源， 所以这些数据通常不会彻底消失。  

systemd 依赖于 内核提供的 cgroups.txt 特性控制进程的派生， 从而确保可以追踪到所有子进程。 cgroups 信息由内核负责维护， 并且可以通过 /sys/fs/cgroup/systemd/ 接口进行访问。此外，还可以通过 systemd-cgls(1) 或 ps(1) 之类的工具 进行查看 (ps xawf -eo pid,user,cgroup,args).  

systemd 几乎完全兼容 传统的 SysV init 系统： SysV init 脚本可以作为另一种配置文件格式被识别； 提供与 SysV 兼容的 /dev/initctl 接口； 提供各种 SysV 工具的兼容实现； 依然兼容例如 /etc/fstab 或者 utmp 之类传统的 Unix 特性。

systemd 还有一个小型的事务系统： 如果要启动或关闭一个单元， 那么该单元所依赖的所有其他单元都会被一起加入到同一个临时事务中。这样， 就可以校验整个事务的一致性， 也就是检查是否存在循环依赖。 如果存在循环依赖， 那么 systemd 将会尝试通过 去掉弱依赖(want) 来解决这个问题， 如果最终实在无法解决循环依赖的问题， 那么 systemd 将会报错。

注意， 因为事务的生成独立于单元的状态， 所以， 即使启动一个 已经处于活动(active)状态的单元， 也仍然会生成一个事务， 并启动任何非活动的依赖单元， 而且还会更进一步追随依赖关系， 导致 启动其他被依赖的非活动单元。


## /lib/systemd/systemd 控制选项
以下列出控制 /lib/systemd/systemd 守护进程运行的元素。  


### 信号
下面定义了当 systemd 收到不同信号时，该如何动作：
* SIGTERM：systemd 系统实例将会保存其当前状态， 然后重新执行它自身，再恢复到先前保存的状态。 基本上相当于 执行 systemctl daemon-reexec 命令。systemd 用户实例将会启动 exit.target 单元。 基本上相当于执行 systemctl --user start exit.target --job-mode=replace-irreversible 命令。
* SIGINT：systemd 系统实例将会启动 ctrl-alt-del.target 单元。基本上相当于执行 systemctl start ctrl-alt-del.target --job-mode=replace-irreversible 命令。 在控制台上按 Ctrl+Alt+Del 组合键即可触发这个信号。 但是，如果在2秒内连续收到超过7次这个信号，那么将会不顾一切的立即强制重启。 因此，如果系统在重启过程中僵死，那么可以通过在2秒内快速连按7次 Ctrl+Alt+Del 组合键来强制立即重启。systemd 用户实例处理此信号的方式与 SIGTERM 相同。
* SIGWINCH：systemd 系统实例 将会启动 kbrequest.target 单元。 基本上相当于执行 systemctl start kbrequest.target 命令。systemd 用户实例将会 完全忽略此信号。
* SIGUSR1：ystemd 将会尝试 重新连接到 D-Bus 总线。
* SIGHUP：重新加载守护进程的配置文件。 基本上相当于执行 systemctl daemon-reload 命令。
* ... 更多信号处理可以参考[官方文档](https://www.freedesktop.org/software/systemd/man/systemd.html#)

### 环境变量
环境变量可以用于控制 systemd 的行为，但是环境变量通常可以被针对同一项设置的命令行设置选项所覆盖：
* SYSTEMD_LOG_LEVEL：systemd 日志等级。
* SYSTEMD_LOG_TARGET：systemd 日志目标。
* SYSTEMD_LOG_LOCATION： systemd 是否应该在日志信息中包含代码位置(code location)。
* SYSTEMD_UNIT_PATH：单元目录
* SYSTEMD_SYSVRCND_PATH：SysV 运行级目录
* ... 更多环境变量的设置可以参考[官方文档](https://www.freedesktop.org/software/systemd/man/systemd.html#)

### 内核引导选项
当作为系统实例运行的时候， systemd 能够接受下面列出的内核引导选项。
* systemd.unit=, rd.systemd.unit=：设置默认启动的单元。 默认值是 default.target 。 可用于临时修改启动目标(例如 rescue.target 或 emergency.target )。有 "rd." 前缀的参数专用于 initrd(initial RAM disk) 环境，而无前缀的参数则用于 常规环境。
* systemd.dump_core：既可以明确设为一个布尔值，也可以仅使用此选项而不设置任何参数(相当于设为 yes )。 设为 yes 表示 systemd(PID=1) 将会在崩溃时进行内存转储，否则不进行任何转储。 默认值是 yes 。 
* systemd.setenv=：接受 VARIABLE=VALUE 格式的字符串， 可用于为派生的子进程设置默认环境变量。 可以多次使用以设置多个变量。

* quiet：关闭启动过程中的状态输出。相当于 systemd.show_status=no 的效果。 注意，因为此选项也同样被内核所识别， 并用于禁止输出内核日志， 所以使用此选项会导致同时关闭内核与 systemd 的输出。
* debug：开启调试输出， 等价于设置了 systemd.log_level=debug 。 注意，因为此选项也同样被内核所识别， 并用于开启内核的调试输出， 所以使用此选项会导致 同时开启内核与 systemd 的调试输出。
* ... 更多内核引导选项可以参考[官方文档](http://www.jinbuguo.com/systemd/systemd.html#)



## systemd 的系统实例与用户实例
/lib/systemd/systemd 是一个静态的二进制程序被放在根文件系统中,当它被加载到内存中运行就对应一个进程,也可以说这个执行进程是对应 /lib/systemd/systemd 的一个执行实例,相对于其它服务进程来说,systemd 的一个特殊之处在于:它不仅仅只运行系统实例,同时在系统中还可能运行着多个用户实例.   

系统实例只有一个,用于管理整个系统的服务,同时以 root 权限启动,而用户实例是针对用户的,也就是每当有一个新的用户登录上系统时,系统会执行 
/lib/systemd/systemd --user 产生一个新的进程,这个新进程对应当前登录的新用户,这个新的用户实例对系统和其它用户来说都是完全独立的,也就是当用户使用 systemctl --user status foo.service 时,是与新产生的用户实例进行交互,而不是与系统实例进程进行交互.  

区分系统实例和用户实例需要注意以下几点:
* 只有当用户第一次登录到系统中时,才会产生新的实例,实际上是将 /lib/systemd/system/user@.service 模板实例化一个服务并启动.执行 ExecStart 命令:/lib/systemd/systemd --user.早期的版本中用户实例针对的是 session 而不是用户,只要存在登录系统的行为就会创建一个用户实例,现在更新为针对用户,从 systemd 226 版本之后改为针对用户.    
* 用户与系统,用户与用户之间是独立的,对系统实例使用 systemctl enable 时,是设置开机启动,而对用户实例使用同样的操作时,只有用户实例启动后才会按照 enable 的规则启动对应服务,这里有必要说说 systemctl enable 的原理,它实际是建立启动的依赖关系,只不过对于系统实例而言,enable 的操作将会设置为被一个开机启动的服务所依赖,所以所操作的服务也就会在开机的时候被启动.  
* 只要用户还有会话存在，这个进程就不会退出；用户所有会话退出时，进程将会被销毁。  
* 操作系统实例的修改操作通常需要 root 权限才能实现,而用户实例不需要,但是这并不意味着普通用户使用 systemctl status 操作的就是用户实例,实际上普通用户使用该指令操作的还是系统实例,看到的是系统状态,如果需要操作用户实例,需要指定 --user 选项.    
* 系统实例存在对应的系统目录,通常是 /lib/systemd/system 或者是 /usr/lib/systemd/system 等(位于system目录下),而所有用户实例的系统目录在 /lib/systemd/user 或者 /usr/lib/systemd/user 下.即使所有用户实例共用一份系统配置文件,因为运行的是不同的进程,因此也是可以做到独立的.例如:系统中存在两个用户 foo 和 bar,在系统开机时只会执行系统实例,当用户 foo 登录到系统时,会为 foo 启动一个系统实例,foo 用户开启了原本处于关闭状态的 test.service,此时登录 bar,在 bar 用户下查看 test.service 的状态时依旧处于关闭状态.  


使用用户实例主要是方便针对某个用户进行特定的配置,比如邮件服务,mpd 等等.  

### 随系统启动的 systemd 用户实例
用户实例只有在对应用户登录的时候才会被生成，在某些情况下，既需要使用用户实例来执行某些服务，又希望该用户实例在开机时随系统一起启动，在会话全部结束时，也不停止用户实例。  

这种情况下就需要用到使用下列的命令将用户驻留在系统中，即即使该用户没有登录，也会生成对应的用户实例：

```
loginctl enable-linger $USERNAME
```

这种用户驻留行为对用户实例的影响相当于用户在启动之初就登录到系统。  




## systemd 针对其它服务的启动
linux 系统中大部分需要系统开机启动的服务都是一些守护进程，systemd 负责启动这些守护进程，在传统的 sysvinit 系统上，各个守护进程严格地按照一定的顺序启动，而 systemd 则是采用并行启动、按需启动两种策略，具体的启动过程也有着比较大的差别。  

### sysvinit 启动过程
传统的 sysvinit 系统启动一个进程遵循以下的步骤：
* 关闭当前进程除标准错误、标准输入、标准输出之外的所有文件描述符，这样就保证不会将额外的文件描述符信息传递到新的进程中
* 重置所有的信号处理为默认状态
* 重置所有信号掩码
* 清理环境变量，前面四个步骤主要是为了创建一个干净的进程环境，以创建一个新的子进程
* 调用 fork() 创建一个子进程
* 在子进程中调用 setsid() 从终端脱离并创建一个独立的会话
* 在子进程中再一次调用 fork() 以确保守护进程永远无法获取任何终端。
* 第一个子进程主动退出， 只有第二个子进程(实际的守护进程)保持运行， 并且以 init(PID=1) 为父进程。
* 守护进程(第二个子进程)将 STDIN STDOUT STDERR 连接到 /dev/null 虚拟设备
* 守护进程将 umask 设为 0
* 守护进程将当前目录切换到根目录(/)
* 守护进程将自身的PID记录到例如 /run/foobar.pid 这样的文件中
* 守护进程丢弃自己不需要的权限 
* 守护进程通知最初的父进程：初始化工作已完成
* 最初的父进程自身退出


### systemd 启动守护进程
在 systemd 中启动守护进程要相对简洁得多，systemd 直接提供了干净的上下文环境：环境变量已经被清理、信号处理器与信号掩码已经被重置、 没有遗留的文件描述符、守护进程自动在其专属的会话中执行、标准输入(STDIN)已被连接到 /dev/null 虚拟设备(除非另有配置)、 标准输出(STDOUT)与标准错误(STDERR)已被连接到 systemd-journald.service日志服务(除非另有配置)、umask 已经被重置 … 等等

每一个守护进程的启动都由这个干净的上下文而来，将重复的事情抽象出来，以提升系统的启动效率。  

既然享受了 systemd 的便利，同时也要接受 systemd 带来的限制，也就是：如果你要编写一个守护进程，就需要遵循 systemd 提供的接口，或者是参考 systemd 提出的一些建议：
* 进程收到 SIGTERM 信号后 关闭进程并确保干净的退出
* 进程收到 SIGHUP 信号后 重新加载配置文件(如果进程有重载配置文件的需求)
* 主守护进程 在退出时 应该按照 [LSB recommendations for SysV init scripts](https://refspecs.linuxbase.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic/iniscrptact.html) 的要求返回恰当的退出码，以便于 systemd 判断服务的退出状态。
* 如果可行的话，通过 dbus IPC 机制导出守护进程的控制接口，同时作为初始化的最后一步，并获取总线名称。
* 提供一个 .service 单元文件， 包含如何启动/停止/维护该服务的配置。
* 尽可能 依赖于 systemd 的资源控制与权限升降功能 (CPU与内存占用/文件访问等等)， 而不要自己实现它们。
* 若使用了 D-Bus ， 则强烈推荐使用基于 D-Bus 的启动机制。 这样做有许多好处： 
    (1)守护进程可以按需延迟启动； 
    (2)可以和依赖于它的进程并行启动 (提升启动速度)； 
    (3)守护进程可以在失败时被自动重启 而不丢失D-Bus总线上的请求。
* 若守护进程通过套接字提供服务， 则强烈推荐使用 基于套接字的启动机制。 这样做有许多好处： 
    (1)守护进程可以按需延迟启动； 
    (2)可以和依赖于它的进程并行启动(提升启动速度)； 
    (3)对于无状态协议(例如 syslog, DNS)， 守护进程可以在失败时被自动重启而不丢失套接字上的请求
* 若可能， 守护进程应该通过 sd_notify 接口通知 systemd "启动已完成"或"状态已更新"这样的消息。
* 不要使用 syslog() 记录日志， 只需简单的使用 fprintf() 向 STDERR 输出日志即可。 如果必须指明日志等级， 则可以在日志的行首加上类似 "<4>" 这样的前缀即可(这里表示4级"WARNING")。  

实际上，对于 systemd 启动的守护进程而言，有多种进程启动方式，在 service 文件的介绍中有详细讲解，其中 Type=forking 启动进程就是传统的 sysvinit 启动方式，从上文的分析可以看到，这种方式的启动效率是不高的，而且对于 systemd 来说，不利于进程的追踪，如果必须要使用传统的进程启动方式，则需要使用 PIDFile= 指令提供主进程的 PID 以便 systemd 进行进程追踪。  




## 服务启动流程
systemd 提供了多种启动机制(见下文)， 而服务单元也经常同时使用其中的几种。 例如 bluetoothd.service 可以在插入蓝牙硬件时被启动， 也可以在某进程访问其 D-Bus 接口时被启动。 又如打印服务可以在IPP端口有流量接入时被启动， 也可以在插入打印机硬件时被启动， 还可以在有文件进入打印机 spool 目录时被启动。 甚至对于必须在系统启动时无条件启动的服务， 为了尽可能并发启动， 也应该使用某些启动机制。 如果某守护进程实现了一个 D-Bus 服务或者监听一个套接字， 那么使用基于 D-Bus 或基于套接字的启动机制， 将允许该进程与其客户端同时并行启动(从而加快启动速度)。 因为所有的通信渠道都已事先建立， 并且不会丢失任何客户端请求， 同时 D-Bus 总线或者内核会将客户端请求排入队列等候， 直到完成启动。


### 开机自启动
传统的守护进程一般是在系统启动时通过SysV初始化脚本自动启动， systemd 也支持这种启动方式。 对于 systemd 来说，如果希望确保某单元在系统启动时自动启动， 那么最佳的做法是在默认启动目标 (通常是 multi-user.target 或 graphical.target)的 .wants/ 目录中为该单元建立软链接。  

systemctl enable 指令就是基于这种原理设置开机自启动。  

### 基于套接字的启动
为了尽可能提高并行性与健壮性， 以及简化配置与开发， 对于需要监听套接字的服务， 强烈推荐使用基于套接字的启动机制。 使用此机制后， 守护进程不再需要创建和绑定套接字， 而是由 systemd 接管这个工作。 systemd 将会根据单元文件的设置， 预先创建所需的套接字， 并在第一个客户端请求接入的时候 启动该服务， 以实现服务的按需启动。 该机制的好处还在于， 预先创建好套接字之后， 所有使用此套接字通信的进程可以并行启动(包括客户端和服务端)。 此外，重启服务只会导致丢失最低限度的客户端连接， 甚至不丢失任何客户端请求 (例如对于 DNS 或 syslog 这样的无状态协议)。 因为套接字在服务重启期间 始终保持有效并且可被访问， 同时所有客户端请求 也都被排入队列等候处理。

使用此机制之后， 守护进程必须要从 systemd 接收已创建好的套接字， 而不能自己创建并绑定套接字。 关于如何使用该机制，只需要小小的修改， 即可在原有启动机制的基础上添加基于套接字的启动机制。  

systemd 通过 .socket 单元实现该机制。 必须确保所有为支持基于套接字启动而创建的监听 socket 单元都被包含在 sockets.target 中。 建议在 socket 单元的 "[Install]" 小节加入 WantedBy=sockets.target 设置， 以确保在启用该单元时能够自动添加上述依赖关系。 除非明确设置了 DefaultDependencies=no ， 否则会为所有 socket 单元隐含的创建必要的顺序依赖。 


### 基于 D-Bus 的启动
如果守护进程使用 D-Bus 与客户端通信， 那么它应该使用基于 D-Bus 的启动机制， 这样当客户端访问其 D-Bus 接口时，该服务将被自动启动。 该机制是通过 D-Bus service 文件实现的(不要与普通的单元文件混淆)。 为了确保让 D-Bus 使用 systemd 来启动与维护守护进程， 必须在这些 D-Bus service 文件中使用 SystemdService= 指明其匹配的服务单元。 例如，对于文件名为 org.freedesktop.RealtimeKit.service 的 D-Bus service 来说， 为了将其绑定到 rtkit-daemon.service 服务单元， 必须确保在该文件中设置了 SystemdService=rtkit-daemon.service 指令。 注意，必须明确设置 SystemdService= 指令， 否则当服务单元同时使用多种启动机制时， 可能会导致竞争条件的出现。

### 基于设备的启动
用于管理特定类型硬件的守护进程， 只应该在符合条件的硬件变为可用或者被插入时， 才需要启动。 为了达到上述目的， 可以将服务的启动/停止与硬件的插入/拔出事件绑定。 当带有 "systemd" 标签的设备出现在 sysfs/udev 设备树中时， systemd 将会自动为其创建对应的 device 单元。   

通过向这些单元中添加对其他单元的 Wants= 依赖， 就可以实现当该 device 单元被启动(也就是硬件被插入)时， 连带启动其他单元，从而实现基于设备的启动。 这可以通过向 udev 规则库中添加 SYSTEMD_WANTS= 属性来实现，通常，并不是将 service 单元直接添加到设备的 Wants= 依赖中， 而是通过专用的 target 单元间接添加。 例如，不是将 bluetoothd.service 添加到各种蓝牙设备的 Wants= 依赖中， 而是将 bluetoothd.service 添加到 bluetooth.target 的 Wants= 依赖中， 同时再将 bluetooth.target 添加到各种蓝牙设备的 Wants= 依赖中。 通过引入 bluetooth.target 这个抽象层， 系统管理员无需批量修改 udev 规则库， 仅通过 systemctl enable|disable … 命令 修改 bluetooth.target.wants/ 目录中的软链接， 即可控制 bluetoothd.service 的使用。

### 基于路径的启动
对于处理 spool 文件或目录的 守护进程(例如打印服务)来说， 仅在 spool 文件或目录状态发生变化或者内容非空时， 才需要启动。 通过 .path 单元实现的、 基于路径的启动机制正好适用于这种场合。  

### 基于定时器的启动
对于周期性的操作 (例如垃圾文件清理或者网络对时)， 可以通过基于定时器的启动机制来实现。 这种机制通过 .timer 单元实现。  












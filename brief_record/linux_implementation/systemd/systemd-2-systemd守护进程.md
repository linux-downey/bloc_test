# systemd-2-systemd 守护进程
通过前面两章的铺垫,相信各位对 systemd 的基本概念已经有了一定的了解:systemd 是一个专用于 linux 操作系统的系统与服务管理器,在大部分支持 systemd 的机器上,它都是作为 PID 为 1 的 init 进程启动的,启动并维护各种用户空间的服务.  

作为验证,你可以通过 ps -ef | head 指令查看当前系统中的进程列表,在我的 ubuntu18 机器上,PID 为 1 的进程为 /sbin/init,而 /sbin/init 是指向 /lib/systemd/systemd 的一个软链接.   

因此,systemd 系统的守护进程就是 /lib/systemd/systemd,作为系统的 init 进程启动.因此 systmed 代表一个管理系统,同时也表示该管理系统对应的执行程序,所以为了避免混淆,systemd 依旧表示整个管理系统,而对应的守护进程统一使用 /lib/systemd/systemd 来表示.  


## systemd 的系统实例与用户实例
/lib/systemd/systemd 是一个静态的二进制程序被放在根文件系统中,当它被加载到内存中运行就对应一个进程,也可以说这个执行进程是对应 /lib/systemd/systemd 的一个执行实例,相对于其它服务进程来说,systemd 的一个特殊之处在于:它不仅仅只运行系统实例,同时在系统中还可能运行着多个用户实例.   

系统实例只有一个,用于管理整个系统的服务,同时以 root 权限启动,而用户实例是针对用户的,也就是每当有一个新的用户登录上系统时,系统会执行 
/lib/systemd/systemd --user 产生一个新的进程,这个新进程对应当前登录的新用户,这个新的用户实例对系统和其它用户来说都是完全独立的,也就是当用户使用 systemctl --user status foo.service 时,是与新产生的用户实例进行交互,而不是与系统实例进程进行交互.  

区分系统实例和用户实例需要注意以下几点:
* 只有当用户第一次登录到系统中时,才会产生新的实例,实际上是将 /lib/systemd/system/user@.service 模板实例化一个服务并启动.执行 ExecStart 命令:/lib/systemd/systemd --user.早期的版本中用户实例针对的是 session 而不是用户,只要存在登录系统的行为就会创建一个用户实例,现在更新为针对用户,从 systemd 226 版本之后改为针对用户.    
* 用户与系统,用户与用户之间是独立的,对系统实例使用 systemctl enable 时,是设置开机启动,而对用户实例使用同样的操作时,只有用户实例启动后才会按照 enable 的规则启动对应服务,这里有必要说说 systemctl enable 的原理,它实际是建立启动的依赖关系,只不过对于系统实例而言,enable 的操作将会设置为被一个开机启动的服务所依赖,所以所操作的服务也就会在开机的时候被启动.  
* 只要用户还有会话存在，这个进程就不会退出；用户所有会话退出时，进程将会被销毁。  
* 操作系统实例的修改操作通常需要 root 权限才能实现,而用户实例不需要,但是这并不意味着普通用户使用 systemctl status 操作的就是用户实例,实际上普通用户使用该指令操作的还是系统实例,看到的是系统状态,如果需要操作用户实例,需要指定 --user 选项.    
* 系统实例存在对应的系统目录,通常是 /lib/systemd/system 或者是 /usr/lib/systemd/system 等(位于system目录下),而所有用户实例的系统目录在 /lib/systemd/user 或者 /usr/lib/systemd/user 下.即使所有用户实例共用一份系统配置文件,因为运行的是不同的进程,因此也是可以做到独立的.例如:系统中存在两个用户 foo 和 bar,在系统开机时只会执行系统实例,当用户 foo 登录到系统时,会为 foo 启动一个系统实例,foo 用户开启了原本处于关闭状态的 test.service,此时登录 bar,在 bar 用户下查看 test.service 的状态时依旧处于关闭状态.  


使用用户实例主要是方便针对某个用户进行特定的配置,比如邮件服务,mpd 等等.  

### 随系统启动的 systemd 用户实例
用户实例只有在对应用户登录的时候才会被生成，在某些情况下，既需要使用用户实例来执行某些服务，又希望该用户实例在开机时随系统一起启动，在会话全部结束时，也不停止用户实例。  

这种情况下就需要用到使用下列的命令将用户驻留在系统中，即即使该用户没有登录，也会生成对应的用户实例：

```
loginctl enable-linger $USERNAME
```

这种用户驻留行为对用户实例的影响相当于用户在启动之初就登录到系统。  




## systemd 启动服务
linux 系统中大部分需要系统开机启动的服务都是一些守护进程，systemd 负责启动这些守护进程，在传统的 sysvinit 系统上，各个守护进程严格地按照一定的顺序启动，而 systemd 则是采用并行启动、按需启动两种策略，具体的启动过程也有着比较大的差别。  

### sysvinit 启动过程
传统的 sysvinit 系统启动一个进程遵循以下的步骤：
* 关闭当前进程除标准错误、标准输入、标准输出之外的所有文件描述符，这样就保证不会将额外的文件描述符信息传递到新的进程中
* 重置所有的信号处理为默认状态
* 重置所有信号掩码
* 清理环境变量，前面四个步骤主要是为了创建一个干净的进程环境，以创建一个新的子进程
* 调用 fork() 创建一个子进程
* 在子进程中调用 setsid() 从终端脱离并创建一个独立的会话
* 在子进程中再一次调用 fork() 以确保守护进程永远无法获取任何终端。
* 第一个子进程主动退出， 只有第二个子进程(实际的守护进程)保持运行， 并且以 init(PID=1) 为父进程。
* 守护进程(第二个子进程)将 STDIN STDOUT STDERR 连接到 /dev/null 虚拟设备
* 守护进程将 umask 设为 0
* 守护进程将当前目录切换到根目录(/)
* 守护进程将自身的PID记录到例如 /run/foobar.pid 这样的文件中
* 守护进程丢弃自己不需要的权限 
* 守护进程通知最初的父进程：初始化工作已完成
* 最初的父进程自身退出


### systemd 启动守护进程
在 systemd 中启动守护进程要相对简洁得多，systemd 直接提供了干净的上下文环境：环境变量已经被清理、信号处理器与信号掩码已经被重置、 没有遗留的文件描述符、守护进程自动在其专属的会话中执行、标准输入(STDIN)已被连接到 /dev/null 虚拟设备(除非另有配置)、 标准输出(STDOUT)与标准错误(STDERR)已被连接到 systemd-journald.service日志服务(除非另有配置)、umask 已经被重置 … 等等

每一个守护进程的启动都由这个干净的上下文而来，将重复的事情抽象出来，以提升系统的启动效率。  

既然享受了 systemd 的便利，同时也要接受 systemd 带来的限制，也就是：如果你要编写一个守护进程，就需要遵循 systemd 提供的接口，或者是参考 systemd 提出的一些建议：
* 进程收到 SIGTERM 信号后 关闭进程并确保干净的退出
* 进程收到 SIGHUP 信号后 重新加载配置文件(如果进程有重载配置文件的需求)
* 主守护进程 在退出时 应该按照 [LSB recommendations for SysV init scripts](https://refspecs.linuxbase.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic/iniscrptact.html) 的要求返回恰当的退出码，以便于 systemd 判断服务的退出状态。
* 如果可行的话，通过 dbus IPC 机制导出守护进程的控制接口，同时作为初始化的最后一步，并获取总线名称。
* 提供一个 .service 单元文件， 包含如何启动/停止/维护该服务的配置。
* 尽可能 依赖于 systemd 的资源控制与权限升降功能 (CPU与内存占用/文件访问等等)， 而不要自己实现它们。
* 若使用了 D-Bus ， 则强烈推荐使用基于 D-Bus 的启动机制。 这样做有许多好处： 
    (1)守护进程可以按需延迟启动； 
    (2)可以和依赖于它的进程并行启动 (提升启动速度)； 
    (3)守护进程可以在失败时被自动重启 而不丢失D-Bus总线上的请求。
* 若守护进程通过套接字提供服务， 则强烈推荐使用 基于套接字的启动机制。 这样做有许多好处： 
    (1)守护进程可以按需延迟启动； 
    (2)可以和依赖于它的进程并行启动(提升启动速度)； 
    (3)对于无状态协议(例如 syslog, DNS)， 守护进程可以在失败时被自动重启而不丢失套接字上的请求
* 若可能， 守护进程应该通过 sd_notify 接口通知 systemd "启动已完成"或"状态已更新"这样的消息。
* 不要使用 syslog() 记录日志， 只需简单的使用 fprintf() 向 STDERR 输出日志即可。 如果必须指明日志等级， 则可以在日志的行首加上类似 "<4>" 这样的前缀即可(这里表示4级"WARNING")。  

实际上，对于 systemd 启动的守护进程而言，有多种进程启动方式，在 service 文件的介绍中有详细讲解，其中 Type=forking 启动进程就是传统的 sysvinit 启动方式，从上文的分析可以看到，这种方式的启动效率是不高的，而且对于 systemd 来说，不利于进程的追踪，如果必须要使用传统的进程启动方式，则需要使用 PIDFile= 指令提供主进程的 PID 以便 systemd 进行进程追踪。  




## 启动流程
systemd 提供了多种启动机制(见下文)， 而服务单元也经常同时使用其中的几种。 例如 bluetoothd.service 可以在插入蓝牙硬件时被启动， 也可以在某进程访问其 D-Bus 接口时被启动。 又如打印服务可以在IPP端口有流量接入时被启动， 也可以在插入打印机硬件时被启动， 还可以在有文件进入打印机 spool 目录时被启动。 甚至对于必须在系统启动时无条件启动的服务， 为了尽可能并发启动， 也应该使用某些启动机制。 如果某守护进程实现了一个 D-Bus 服务或者监听一个套接字， 那么使用基于 D-Bus 或基于套接字的启动机制， 将允许该进程与其客户端同时并行启动(从而加快启动速度)。 因为所有的通信渠道都已事先建立， 并且不会丢失任何客户端请求， 同时 D-Bus 总线或者内核会将客户端请求排入队列等候， 直到完成启动。


### 开机自启动
传统的守护进程一般是在系统启动时通过SysV初始化脚本自动启动， systemd 也支持这种启动方式。 对于 systemd 来说，如果希望确保某单元在系统启动时自动启动， 那么最佳的做法是在默认启动目标 (通常是 multi-user.target 或 graphical.target)的 .wants/ 目录中为该单元建立软链接。  

systemctl enable 指令就是基于这种原理设置开机自启动。  

### 基于套接字的启动
为了尽可能提高并行性与健壮性， 以及简化配置与开发， 对于需要监听套接字的服务， 强烈推荐使用基于套接字的启动机制。 使用此机制后， 守护进程不再需要创建和绑定套接字， 而是由 systemd 接管这个工作。 systemd 将会根据单元文件的设置， 预先创建所需的套接字， 并在第一个客户端请求接入的时候 启动该服务， 以实现服务的按需启动。 该机制的好处还在于， 预先创建好套接字之后， 所有使用此套接字通信的进程可以并行启动(包括客户端和服务端)。 此外，重启服务只会导致丢失最低限度的客户端连接， 甚至不丢失任何客户端请求 (例如对于 DNS 或 syslog 这样的无状态协议)。 因为套接字在服务重启期间 始终保持有效并且可被访问， 同时所有客户端请求 也都被排入队列等候处理。

使用此机制之后， 守护进程必须要从 systemd 接收已创建好的套接字， 而不能自己创建并绑定套接字。 关于如何使用该机制，只需要小小的修改， 即可在原有启动机制的基础上添加基于套接字的启动机制。  

systemd 通过 .socket 单元实现该机制。 必须确保所有为支持基于套接字启动而创建的监听 socket 单元都被包含在 sockets.target 中。 建议在 socket 单元的 "[Install]" 小节加入 WantedBy=sockets.target 设置， 以确保在启用该单元时能够自动添加上述依赖关系。 除非明确设置了 DefaultDependencies=no ， 否则会为所有 socket 单元隐含的创建必要的顺序依赖。 


### 基于 D-Bus 的启动
如果守护进程使用 D-Bus 与客户端通信， 那么它应该使用基于 D-Bus 的启动机制， 这样当客户端访问其 D-Bus 接口时，该服务将被自动启动。 该机制是通过 D-Bus service 文件实现的(不要与普通的单元文件混淆)。 为了确保让 D-Bus 使用 systemd 来启动与维护守护进程， 必须在这些 D-Bus service 文件中使用 SystemdService= 指明其匹配的服务单元。 例如，对于文件名为 org.freedesktop.RealtimeKit.service 的 D-Bus service 来说， 为了将其绑定到 rtkit-daemon.service 服务单元， 必须确保在该文件中设置了 SystemdService=rtkit-daemon.service 指令。 注意，必须明确设置 SystemdService= 指令， 否则当服务单元同时使用多种启动机制时， 可能会导致竞争条件的出现。

### 基于设备的启动
用于管理特定类型硬件的守护进程， 只应该在符合条件的硬件变为可用或者被插入时， 才需要启动。 为了达到上述目的， 可以将服务的启动/停止与硬件的插入/拔出事件绑定。 当带有 "systemd" 标签的设备出现在 sysfs/udev 设备树中时， systemd 将会自动为其创建对应的 device 单元。   

通过向这些单元中添加对其他单元的 Wants= 依赖， 就可以实现当该 device 单元被启动(也就是硬件被插入)时， 连带启动其他单元，从而实现基于设备的启动。 这可以通过向 udev 规则库中添加 SYSTEMD_WANTS= 属性来实现，通常，并不是将 service 单元直接添加到设备的 Wants= 依赖中， 而是通过专用的 target 单元间接添加。 例如，不是将 bluetoothd.service 添加到各种蓝牙设备的 Wants= 依赖中， 而是将 bluetoothd.service 添加到 bluetooth.target 的 Wants= 依赖中， 同时再将 bluetooth.target 添加到各种蓝牙设备的 Wants= 依赖中。 通过引入 bluetooth.target 这个抽象层， 系统管理员无需批量修改 udev 规则库， 仅通过 systemctl enable|disable … 命令 修改 bluetooth.target.wants/ 目录中的软链接， 即可控制 bluetoothd.service 的使用。

### 基于路径的启动
对于处理 spool 文件或目录的 守护进程(例如打印服务)来说， 仅在 spool 文件或目录状态发生变化或者内容非空时， 才需要启动。 通过 .path 单元实现的、 基于路径的启动机制正好适用于这种场合。  

### 基于定时器的启动
对于周期性的操作 (例如垃圾文件清理或者网络对时)， 可以通过基于定时器的启动机制来实现。 这种机制通过 .timer 单元实现。  





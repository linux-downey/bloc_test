# systemd - 0 - systemd 简介

无论在 linux 的哪个内核版本中，进程的产生方式都是由父进程一分为二，产生一个新的进程，这是内核针对进程管理的基本策略，因此，除了第一个进程之外，所有之后产生的进程都是第一个进程的后代，这种进程的管理方式形成了一种树状的关系。  

用户进程的管理并不是内核决定的，尽管它会依赖于内核提供的接口，但是在这接口之上可以实现多种策略，所以基于内核之上的用户进程管理因各个发行版的不同而不同。  

进程管理最主要的是两部分
* 进程的启动，包括各个进程的启动顺序，依赖关系的处理等等
* 进程的状态跟踪，跟踪进程状态的变化并进行相应处理、日志收集、进程收尾工作等等

早期的计算机主要是老旧的台式机，并没有发展出成体系的用户空间的进程管理策略，由内核创建第一个 init 进程，然后根据进程的依赖关系，一个个地创建系统进程，而对于进程的跟踪基本上也是各自为政，对于不同的发行版而言，各家使用各家 init 系统，其中 sysvinit 系统逐渐占据主要市场。  

随着硬件的发展，尤其是笔记本的出现，原本的 init 系统便显得有些力不从心了，sysvinit 启动任务是一次性的，这种静态配置的特性对于热插拔的设备非常不友好，比如为了管理打印任务，系统需要启动 CUPS，但是当打印机不使用的时候，造成资源的无端浪费，毫无疑问 sysvinit 没有办法妥善地处理这些问题，而且 sysvinit 的启动速度非常慢，所有的任务都是串行启动，这无疑也是个非常大的缺点。   

Upstart 的出现解决了这些麻烦，在 linux 2.6 内核的同步支持下，Upstart 采取事件驱动模型，硬件的变更由内核检测到，并发送到用户空间，用户空间基于这些变更事件实现了对设备的动态支持，包括 U 盘的热插拔、硬件与驱动程序的动态加载卸载。  

Upstart 初始化系统对系统启动做了优化，分析启动进程之间的依赖关系，从而让没有依赖关系的进程同步启动，由串行启动转为并行启动，同时，Upstart 还为每个进程维护一个生命周期，以实现进程的状态跟踪。  

这些特点使得 UpStart 可以很好地应用在桌面或者便携式系统中，处理这些系统中的动态硬件插拔特性。Upstart 系统也获得了很好的市场反应，被作为各大发行版用户空间的进程管理系统。     


如果 systemd 不出现，Upstart 系统将会持续的发光发热，相对于 Upstart 来说，systemd 算是一个后起之秀，相对于从 sysvinit 系列 init 系统到 Upstart 的更新而言，systemd 并没有在 Upstart 的基础上有革命性的变革，在诞生以及发展初期备受争议，甚至受到抵制，但是实践证明，systemd 取得了巨大的成功，目前几乎所有的发行版都是用 systemd 作为用户进程管理系统。  

相对于 Upstart 而言，systemd 有一些更强大的特性：
* 更快的启动速度，在 Upstart 的并行启动基础上采用了更激进的策略以及支持按需加载，同时保证稳定启动
* 接管了大量的服务，同时还在持续的更新中，比如 crond、udev 等独立于主进程的服务，统一了各个服务的管理接口以及日志系统，这种统一无疑让系统管理变得简单。   

systemd 发展到现在，已经不再是一个单纯的初始化系统，更像是一个用户系统的管理框架，对于系统管理员而言，无论是系统服务还是自建的进程，管理这些进程只需要按照 systemd 提供的接口配置相应的服务即可。  

至于早期对于 systemd 的抱怨，多数来源于以下几点：
* unix 的哲学是做一件事，并且把它做好，但是 systemd 有点倾向于把 1 号扩张到最大化，通俗地说就是它管得太宽了。  
* 通过统一地管理而不是完全模块化的接口，这让很多 linux 用户感觉非常不自由，而在 systemd 之前，linux 用户可以在多个组件化的服务之间做选择，甚至实现自己的定制化版本，而现在这种自由正在逐渐受到限制，因为要适配 systemd 的接口。  
* 不遵循 POSIX 标准，除了 linux 平台之外不支持其它的平台
* 太过于激进的启动策略可能带来一些系统稳定性风险，而且，早期 systemd 版本存在一些 bug，当然，随着时间的推移，systemd 的稳定性已经满足了市场的需求。  

systemd 到底受不受开发者的喜欢，这是个见仁见智的问题，但是可以确定的是，它确实适合目前的市场，毕竟，主观的印象可能有所偏颇，而真实的使用数据却不能造假。   

## systemd 系列的开头篇
在上面的讨论中，各位应该建立了一个印象：systemd 是一个大而且复杂的系统，是的，systemd 接管了大量的系统服务，因此也带来了与其相当的复杂性，这篇博客只是 systemd 系列的开头篇，着重于介绍 systemd 的产生背景以及最基本的一个 systemd 使用指南，后续将会对整个 systemd 系统进行更深入的分析，理清这个系统的框架以及背后的原理。  

整个系列的博客分为多篇博客，分别从多个方面进行分析：
* systemd 简介以及基本使用(本文)
* systemd 背后的设计思想
* systemd 的使用详解
* systemd service 文件总览：unit 单元
* systemd service 文件之 service section
* systemd service 文件之 Unin & Install section
* systemd 中的 target 文件
* systemd 中的 socket 文件
* systemd 中的 timer 文件
* systemd 启动顺序
* systemd.analyze 启动分析
* systemd日志控制


## systemd 的基本使用
上文中只是对 systemd 做了一个大概的介绍，对于系统管理员而言还是需要落实到怎么用，systemd 是一个庞大的系统，同时也是一个守护进程，就像 linux 中常见的 daemon 与客户端程序模式一样，守护进程提供接口，而真正起到控制 systemd 中服务和系统管理的指令为 systemdctl。   


对于一个基本的服务而言，使用者最关心的操作就是服务的开启、停止、设置开机启动以及状态管理，systemdctl 中自然是有对应的实现的。   

以名为 foo 的服务为例.   

服务的开启关闭指令为：

```
systemctl start foo.service
systemctl stop foo.service
```

服务的开机启动设置指令:
```
systemctl enable foo.service
systemctl disable foo.service
```

查看对应服务的状态，包括运行状态、启动信息、属主信息等：

```
systemctl status foo.service
```

对于系统的服务，操作起来是非常方便的，基本上都是一两条指令就完成，这是因为系统已经对这些服务进行了完善的配置。  

按照平常的开发经验来说，一个服务其实就是对应一个或者一系列程序集合，比如 ssh 服务对应 daemon 程序 sshd，以及可能存在的其他辅助程序，对服务的管理本质就是如何对这部分程序进行启停操作，以及做相应的配置，因此，如果需要将一个服务交给 systemd 进行托管，自然是需要通过 systemd 提供的接口做相应的配置，这样 systemd 才知道用户使用 systemctl 对该服务进行操作时，对应执行哪些底层操作。    

不难发现，在上述的服务启动中，指定的服务名都带了一个后缀：.service，这个 service 文件正是 foo 服务针对 systemd 系统的配置文件，下面是一个最简单的 service 文件示例：

```
[Unit]
Description=Foo

[Service]
ExecStart=/usr/sbin/foo-daemon

[Install]
WantedBy=multi-user.target
```

对于一个 service 文件而言，通常包含三个小节(section)：
* Unit：该服务的通用配置，比如启动顺序、依赖条件、环境检查等
* Service：针对具体服务的配置，也是比较核心的部分，指定服务启停时的执行命令以及相应配置
* Install：主要是针对开机自启动的服务

对于上述的 service 文件而言，各字段的含义分别如下：
* Description：是该服务的描述字段，仅仅作为一个描述字符串，没有实际功能
* ExecStart：该字段指定一个执行命令，在用户执行 systemctl start foo 时会调用到该命令。  
* WantedBy：用于标识在开机自启动时的顺序，指定该字段并不意味着设置了开机自启动，而是在用户执行 systemdctl enable foo 时会读取该字段以确定启动顺序。  

对于一个 service 文件而言，service 字段是必须的，否则服务无法正常执行，而 Unit 和 Install 字段是可选的，如果没有指定 Install 字段也并不一定表示该服务无法开机自启动，它可能通过其他的依赖方式而被启动，这部分将在后文中详细讨论。  

除了 service 文件之外，systemd 实际上还支持多个种类的配置文件，比如：.target、.mount、.socket 等等，这些配置文件都是 ini 风格的纯文本文件，这些文件统称为单元文件(unit 注意和 service 文件中的 Unit 节不是一个概念)。  

不同的配置文件封装了服务不同的信息，在上文中有提到，systemd 接管了系统中的大量服务，除了最常见的 daemon(守护进程)之外还有文件系统挂载、系统定时服务等，所以存在多种类型的配置文件，只是用户最常接触到的是 service 文件罢了。  


除了服务的启停之外，系统中还有一个比较重要的部分：日志管理，日志的重要性不言而喻，systemd 实现了日志的统一管理，所有由 systemd 管理的服务，其对应调试信息以及日志都会被 systemd 记录，而对应的客户端程序为 journalctl，使用该程序可以查看 systemd 中所有的日志信息，当然也是可以对日志进行过滤和匹配，以查看自己需要的那部分日志信息。  


## 小结
在本章中，对 systemd 的产生、发展作了简要的介绍，同时也演示了 systemd 最基础的使用，对 systemd 建立一个大概的印象，但是，systemd 作为一个复杂的系统，值得我们去深入发掘。  

同时，作为驱动工程师，知其然并知其所以然才是我们的学习原则，所以，更多的应该是探究一项技术的背后实现机制，必要的时候结合源码进行分析。  

在接下来的文章中，我们一起来走进 systemd 的世界。   



systemd 源码地址：https://github.com/systemd/systemd
参考：https://www.ibm.com/developerworks/cn/linux/1407_liuming_init2/index.html

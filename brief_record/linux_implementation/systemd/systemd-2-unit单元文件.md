# systemd-2-unit 单元文件
如果不涉及到复杂的应用，系统管理员基本上只会接触到 service 配置文件，当我们要对某个服务程序进行管理时，编写一个 service 文件，指定服务开启、关闭时对应的指令，就可以通过 systemd 对该服务进行控制了("服务"这个概念本来是针对系统提供的 daemon 程序而言，比如 ssh、login，在本章中这个概念被引用到所有实现某个具体功能的进程或进程组，比如一个 QT 交互界面程序，尽管它可能是一个客户端程序).  

实际上，systemd 的配置文件分为多种，分别针对多种服务的配置，这些不同后缀的配置文件统称为单元文件(unit)，systemd 从系统目录下读取这些单元文件对服务进行相应的配置。  

单元文件是 ini 风格的纯文本文件。 封装了以下对象的信息：服务(service)、套接字(socket)、设备(device)、挂载点(mount)、自动挂载点(automount)、 启动目标(target)、交换分区或交换文件(swap)、被监视的路径(path)、定时任务(timer)、 资源控制组(slice)、一组外部创建的进程(scope)。    

以下列出常用的几种文件的简短介绍：
* service：以 .service 为后缀的文件，这是最常见的配置文件，针对服务相关的设置，包括服务的启停、开机启动所对应的指令，同时兼容 sysvinit 系统，能够读取 sysvinit 脚本，比如 /etc/init.d/ 目录下的文件，rc-local 等，sysvinit 系统的开机自启动一般是两种方式：
    * 将启动脚本放到 /etc/init.d/ 目录下，再使用 update-rc.d 指令更新开机启动设置
    * 直接在 /etc/rc.local 文件中添加启动指令，rc.local 会在启动的最后阶段被执行。 
    这两种方式都可以被 systemd 直接支持。

* socket：以 .socket 为后缀的文件，该单元将套接字封装在文件系统或网络上。当前支持流、数据报和顺序包类型的AF_INET，AF_INET6，AF_UNIX套接字。同时还支持经典FIFO作为传输方式。套接字文件中通常包含了其在套接字文件在系统中的目录、文件权限、buffer 大小等等。套接字文件不会被当成某个服务启动，都是通过依赖关系被系统自动启动。    

* device：.device 为后缀的文件，针对 linux 中的设备文件的配置，实际上这种类型的配置文件用得不多，所有硬件设备都由内核进行管理，当设备初始化、添加或者删除时，内核通过 netlink 发送消息到用户空间，用户空间统一通过 udev 接收并处理，执行用户指定的脚本或者是创建一些设备节点，需要使用 .device 文件来描述的情况并不多。

* mount: .mount 文件用于指定文件系统的加载点，这个文件系统可能是磁盘文件系统，也可能是基于 RAM 的文件系统，原本的 /etc/fstab 依旧可用，.mount 文件通常需要提供文件系统类型、挂载点等信息。  

* target：.target 文件是单元文件的逻辑分组，也就是说，单个服务配置文件通常是为了完成某个特定的功能，比如启动 ssh、login，当系统需要达到某个状态或者实现某个相对复杂的功能需求时，需要多个服务的组合，比如需要完成 sysinit，即系统初始化工作，需要先完成文件系统、交换分区、硬件设备的初始化，target 文件就是负责管理多个服务的分组，以组为单位对服务进行管理以实现特定的需求而不再是单个的程序，target 文件通常被用在服务的依赖条目中。  

* snapshot：快照文件，类似于目标单元的快照，它本身并不会做任何事情，它们的唯一目的是引用其他单元。快照可用于保存/回滚init系统的所有服务和单元的状态。主要的用途为：允许用户暂时进入特定状态 (例如 resecu 状态)，终止当前服务，并提供一种简单的方法来返回之前的状态。  


## 单元文件加载目录
在 systemd 开始运行的时候，会在一组指定的目录处读取单元文件并加载，下列是所有单元文件的系统路径，以单元文件的优先级进行排列，先列出的优先级较高，当系统中同时出现多个同名的单元文件时，存在于高优先级目录下的单元文件会覆盖低优先级目录下的文件：

当 systemd 以系统权限运行时(--system)，加载单元的目录(优先级从高到低排列)：TODO

当 systemd 以用户模式运行时，加载单元的目录(优先级从高到低排列)：TODO

上表中的 XDG_RUNTIME_DIR、XDG_CONFIG_HOME 是系统中的环境变量，环境变量可以通过特定的程序生成，systemd 中允许使用环境变量生成器来给环境变量赋值，生成器是 systemd 中一系列执行程序，这些程序在单元文件加载之前被执行，生成动态的单元文件或者环境变量。  




## 单元文件内容
单元文件被 systemd 读取，正如上文中的介绍，不同的单元文件对应不同的功能，尽管不同类型的单元文件有不同的配置，但是其格式是一样的，单元文件分为两个部分：
* 使用 [ ] 包括的 section，即小节，一个小节可包含多个描述字段，比如 [Unit]、[Service]、[Install] 等。 
* 描述字段，也被称作指令，以键值对的形式，值可以是列表的形式

其中，小节是对多个描述字段的组织，而描述字段负责具体的功能描述，比如 service 文件中的 ExecStart=/bin/foo 表示开启该服务对应的指令为 /bin/foo. 在 systemd 的[指令手册](https://www.freedesktop.org/software/systemd/man/systemd.directives.html)中，详细地列出了所有的指令.  

无法识别的指令不会中断单元文件的加载，但是 systemd 会输出一条警告日志。 如果选项或者小节的名字以 X- 开头， 那么 systemd 将会完全忽略它。 以 X- 开头的小节中的选项没必要再以 X- 开头， 因为整个小节都已经被忽略。 应用程序可以利用这个特性在单元文件中包含额外的信息。  


### 创建别名
如果想要给一个单元赋予别名，那么可以按照需求，在系统单元目录或用户单元目录中， 创建一个软连接(以别名作为文件名)，并将其指向该单元的单元文件。 例如 systemd-networkd.service 在安装时就通过 /usr/lib/systemd/system/dbus-org.freedesktop.network1.service 软连接创建了 dbus-org.freedesktop.network1.service 别名。   

此外，还可以直接在单元文件的 [Install] 小节中使用 Alias= 创建别名。 注意，单元文件中设置的别名会随着单元的启用(enable)与禁用(disable)而生效和失效， 也就是别名软连接会随着单元的启用(enable)与禁用(disable)而创建与删除。 例如，因为 reboot.target 单元文件中含有 Alias=ctrl-alt-del.target 的设置，。单元的别名可以用于 enable, disable, start, stop, status, … 这些命令中，也可以用于 Wants=, Requires=, Before=, After=, … 这些依赖关系选项中。 但是务必注意，不可将单元的别名用于 preset 命令中。 再次提醒，通过 Alias= 设置的别名仅在单元被启用(enable)之后才会生效。  


### 附属配置目录
除了直接读取单元文件，systemd 还支持读取单元文件的附属配置，对于 foo.service 这样的文件，可以创建一个 foo.service.d/ 目录，将单元文件的配置项放在该目录下的 .conf 文件中，systemd 在解析完主文件之后，将会搜索是否存在同名的 .d/ 目录，如果存在，就读取该目录下的 .conf 为后缀的文件，.conf 文件中的指令和主文件中采用同样的解析规则，这样做的目的在于可以保持主要配置不变的情况下，非常方便地对单元文件增加额外的配置，这种模块化的方式对于移植和维护是有明显的好处的。  

对于名称中包含连字符("-")的单元，将会按特定顺序依次在一组(而不是一个)目录中搜索单元配置片段。 例如对于 foo-bar-baz.service 单元来说，将会依次在 foo-.service.d/, foo-bar-.service.d/, foo-bar-baz.service.d/ 目录下搜索单元配置片段。这个机制可以方便的为一组相关单元(单元名称的前缀都相同)定义共同的单元配置片段，特别适合应用于 mount, automount, slice 类型的单元， 因为这些单元的命名规则就是基于连字符构建的。

附属配置并不一定要存在于同目录下，它可以放在任何 systemd 支持的系统目录下，比如 /etc/systemd/{systemd,user} 或者是 /usr/lib/systemd/{systemd,user}.  

附属配置的语法和单元文件的语法是一样的，同样是以小节为开头，后面跟着配置项，如果单元文件和附属配置中存在相同的配置项，附属配置会覆盖单元文件中的配置。  



## 依赖
系统服务之间或多或少地会存在依赖关系，依赖关系的处理策略直接影响到各服务的启动速度，这也是 sysytemd 相对 Upstart 的一大特点，systemd 在依赖关系的处理上采用了更激进的策略，以此带来更快的启动速度，各服务之间的依赖配置被分成三类：
* 隐含依赖：systemd 根据服务之前的特性自动添加的依赖关系，不可更改，比如带有 Type=dbus 的 service 单元 将会自动隐含 Requires=dbus.socket 与 After=dbus.socket 依赖
* 默认依赖：systemd 根据服务之前的特性自动添加的依赖关系，可以通过将 DefaultDependencies 变量设置为 no 进行修改，比如 service 单元自动添加 After=sysinit.target，也就是在系统初始化完成之后启动
* 显式依赖：在单元文件中显式地配置依赖关系
* 依赖目录：通过创建特定的目录指定依赖关系

### 显式的依赖配置
单元文件的依赖配置算是 systemd 中服务配置的关键步骤了，设置依赖相当于指定服务的运行环境，直接关系到程序是否能正常启动以及正常地运行，比如在启动 ssh 服务之前，网络必须初始化成功，这属于一种强依赖关系，ssh 服务同时还需要用到系统日志服务来记录运行日志，但是如果系统日志没有正常运行，其实也不影响 ssh 的正常运行，这就属于一种弱依赖关系。  
显式的依赖配置项有以下几种：
* wants：相对来说，wants 是一种 弱依赖，当当前单元被启动时，在该表项中列出的其他单元尽可能地被启动，即使其他启动失败，也不会影响当前单元的启动。 

* Requires=：设置此单元所必须依赖的其他单元，这属于一种强依赖，需要注意的是，Requires 并不影响服务之间的启动顺序，也就是说，启动依旧是并行的，除非同时设置 After 和 Before 字段，当当前服务被启动时，在该表项中列出的单元如果出现启动失败，当前单元不会被启动或者是停止启动。
    需要注意的是，这并不意味这当前单元如果处于运行状态，在 Requires= 中列出的其他所有单元都会处于运行状态，存在几种特殊情况：
    * 某些服务在执行前会执行条件检查，比如 A Requires B，B 执行之前需要检查某些文件、某个 socket 接口存不存在，如果条件检查失败，B 服务不会被启动，但是这时候 B 不再影响 A 的执行。  
    *  同样是 A Requires B，如果在 A、B 都启动之后，B 主动停止，并不会连带着 A 也一起停止。  
    如果要实现依赖的服务"同生共死"，使用 BindsTo 表项进行设置。  

*  Requisite=：
    Requisite 与 Requires 类似，其区别在于当此单元启动时，这里列出的依赖单元必须已经全部处于启动成功的状态， 否则，此单元将会立即进入启动失败的状态，并且也不会启动那些尚未成功启动的被依赖单元。但是，同样的，该项配置不影响服务之间的启动顺序，所以这一项通常都是和 After 一起使用，从而保证当前服务不会早于被依赖项启动。   
    
* BindsTo=：
    这是比 Requisite 和 Requires 具有更强依赖性的选项，这个配置项等同于单向的"同生共死"，为什么说是单向的呢？如果 A BindsTo B，B 在任意时刻停止或者任何理由导致无法启动，A 都会停止，但是 A 的停止并不会影响到 B。  

    同样的，该配置不会影响到启动顺序，如果要指定启动顺序，需要同时设置 After 和 Before 字段。  
* PartOf=：
    与 Requires= 类似， 不同之处在于：仅作用于单元的停止或重启。 其含义是，当停止或重启这里列出的某个单元时， 也会同时停止或重启该单元自身。 注意，这个依赖是单向的， 该单元自身的停止或重启并不影响这里列出的单元。
* Conflicts=：
    表示冲突关系，接受一个空格分隔的单元列表，表明该单元不能与列表中的任何单元共存，也就是说：
    * 当此单元启动的时候，列表中的所有单元都将被停止
    * 当列表中的某个单元启动的时候，该单元同样也将被停止。  
    
    同样的，此选项与 After= 和 Before= 选项没有任何关系。
 * Before=, After=:
    强制指定单元之间的先后顺序，接受一个空格分隔的单元列表。 假定 foo.service 单元包含 Before=bar.service 设置， 那么当两个单元都需要启动的时候， bar.service 将会一直延迟到 foo.service 启动完毕之后再启动。 注意，停止顺序与启动顺序正好相反，也就是说， 只有当 bar.service 完全停止后，才会停止 foo.service 单元。 After= 的含义与 Before= 正好相反。


### 依赖目录
单元文件 wants、require 等依赖关系，这种依赖关系除了直接在单元文件内指定外，还可以通过指定依赖目录的方式，即对于 foo.service 而言，存在一个 foo.service.wants/ 目录，添加到该目录下的文件软链接相当于在文件中配置 wants=$SERVICE,对于 require 等依赖关系是同样的设置方式，只是对应 foo.service.require/ 目录。  


### Install section
在 .service 类型的服务配置文件中，经常出现 "[Install]" 的节，"[Install]" 小节包含单元的启用信息,事实上，systemd(1) 在运行时并不使用此小节。 只有 systemctl(1) 的 enable 与 disable 命令在启用/停用单元时才会使用此小节。enable 相当于将该单元设置为开机自启动，而 disable 取消开机自启动，而实现这种开机自启动功能的原理在于设置服务之间的依赖。  

通常可以在 service 文件中看到这样的内容：

foo.service
```
...
[Install]
WantedBy=multi-user.target
```
multi-user.target 表示多用户模式下的系统初始化，指定 WantedBy=multi-user.target 相当于在 multi-user.target 的 [Unit] 小节中指定 Wants=foo.service，也就是说在 multi-user.target 服务启动时，尽量先启动 foo.service 服务。   

而 systemctl enable foo.service 指令则是将当前服务的软链接添加到 multi-user.target.wants 中，参考上文的依赖目录实现不难看出 foo.service 会在 multi-user.target 之前启动，而 multi-user.target 在系统启动阶段中靠后，也就实现了开机启动。  

Install section 中包含以下的配置项：
* Alias=
    创建别名，每个别名的后缀(也就是单元类型)都必须与该单元自身的后缀相同。
* WantedBy=, RequiredBy=
    表示在使用 systemctl enable 启用此单元时， 将会在每个列表单元的 .wants/ 或 .requires/ 目录中创建一个指向该单元文件的软连接。 这相当于为每个列表中的单元文件添加了 Wants=此单元 或 Requires=此单元 选项。在 bar.service 单元内设置 WantedBy=foo.service 选项 与设置 Alias=foo.service.wants/bar.service 选项基本上是等价的。
* Also=
    设置此单元的附属单元， 可以设为一个空格分隔的单元列表。 表示当使用 systemctl enable 启用 或 systemctl disable 停用 此单元时， 也同时自动的启用或停用附属单元。
* DefaultInstance=
    仅对模板单元有意义， 用于指定默认的实例名称。 如果启用此单元时没有指定实例名称， 那么 将使用这里设置的名称。模板将在后续的章节中介绍。   


## 服务单元的启动和回收
单元文件都是存储在磁盘上的，在系统启动的时候按需加载到内存中，一个单元会在以下的情况被加载到内存中：
* 该单元是另外一个已加载单元的依赖，例如 After=, Wants=, …
* 该单元正处于启动(starting)、运行(running)、重新加载配置(reloading)、停止(stopping)状态
* 该单元正处于失败(failed)状态
* 该单元的一个任务正在排队等候执行
* 该单元正在被一个活动的IPC客户端程序锁定
* 该单元是一个特殊的"永久"单元，总是被加载并启动。 例如，根文件系统挂载点 -.mount 单元、以及 systemd(PID=1) 自身所在的 init.scope 单元。
* 该单元拥有与其关联的、正在运行中的进程


当不再需要该单元时，systemd 会自动卸载该单元，卸载包括释放进程、回收所有的资源占用，默认情况下，如果某个单元处于停止(inactive)状态，并且没有被其他客户端、任务、单元所引用，那么该单元将会被卸载。启动失败的单元并不会被自动回收，可以使用 CollectMode= 进行配置。   

当一个单元的配置与状态被卸载之后，该单元的所有执行结果，除了已经记录在日志中的信息之外，所有其他信息， 例如，退出码、退出信号、资源占用，等等，都会消失。  

即使单元的配置已经加载，也可以使用 systemctl daemon-reload 或其他等效命令，强制重新加载单元配置。 所有已经加载的配置都将被清空， 并被新加载的配置取代


## 单元文件的替换符
在单元文件的配置选项中，除了使用静态的配置之外，还可以使用一些替换符，替换符用来标识一些特殊的变量，下表是替换符的函数：TODO




总共分为三个部分：Service、Unit、Install

Unit 和 Install 部分包含公共配置部分，而针对具体服务的被包含在 Serivice 部分。 

额外的选项在 systemd.exec 部分列出，主要定义了环境参数
systemd.kill 定义了进程的终止方式
systemd.resource-control，配置处理器的资源控制。  

如果以特定名称请求服务，但未找到任何单元配置文件，则systemd会查找具有相同名称（已删除.service后缀）的SysV初始化脚本，并根据该脚本动态创建服务单元。这对于与SysV兼容很有用。请注意，此兼容性非常全面，但并非100％。有关不兼容性的详细信息，请参阅“与SysV不兼容”文档。

service：
systemd 可以使用 @ 定义模板，比如 dhcpcd@argument.service, 没有带 argument 的就是模板的实现，在服务文件中，可以使用％-specifiers访问此参数或“实例名称”

默认的依赖：
如果在 /etc/systemd/system.conf 中设置了 DefaultDependencies=no 则取消默认的依赖。  

Requires=sysinit.target
After=sysinit.target
After=basic.target
Conflicts=shutdown.target
Before=shutdown.target

默认情况下，为实例服务单元（即名称中带有“ @”的服务单元）分配每个模板 slice 单元

service 文件中必须有一个 Service 节，提供 service 相关的信息。  
下面是 [Service] 中可能的字段：

Type=
配置服务启动时的类型，分为 simple，exec，forking，onshot，dbus，notify 或者 idle。
* simple: 如果 ExecStart= 被指定而 Type= 和 BusName 都没被指定，默认就是 simple，该服务会在主服务进程 fork 之后立即启动，预期用ExecStart =配置的进程是服务的主要进程。在这种模式下，如果进程为系统上的其他进程提供功能，则应在启动服务之前安装其通信通道（例如systemd设置的套接字），因为在创建主要服务流程之后以及在执行服务的二进制文件之前，service manager 将立即着手启动后续单元。在创建主服务进程之后，在执行服务的二进制文件之前。请注意，这意味着即使无法成功调用服务的二进制文件，简单服务的systemctl start命令行也将报告成功（例如，因为所选的User =不存在，或者缺少服务二进制文件）

* exec：exec类型类似于simple，但是服务管理器将在执行主服务二进制文件后立即考虑启动该单元，service manager将把后续单位的启动推迟到这一点。换句话说：在fork（）返回之后，简单地继续执行进一步的工作，而exec在服务进程中的fork（）和execve（）都成功之前不会继续执行，请注意，这意味着当无法成功调用服务的二进制文件时（例如，因为所选的User =不存在，或者缺少服务二进制文件），exec服务的systemctl start命令行将报告失败。

* 如果设置为 froking，则预期使用ExecStart =配置的进程将在其启动过程中调用fork（）。启动完成并设置所有通信通道后，预计父进程将退出。子级继续作为主要服务进程运行，并且当父级进程退出时，服务管理器将认为该单元已启动。这是传统UNIX服务的行为。如果使用此设置，建议也使用PIDFile =选项，以便systemd可以可靠地标识服务的主要进程。一旦父进程退出，systemd将继续启动后续单元。

* oneshot的行为类似于simple。但是，service manager将在主流程退出后考虑该单元。然后它将开始后续行动。 RemainAfterExit =对于此类服务特别有用。如果未指定Type =或ExecStart =，则Type = oneshot是隐含的默认值。请注意，如果在不使用RemainAfterExit =的情况下使用此选项，则该服务将永远不会进入“活动”单元状态，而是直接从“激活”转换为“取消激活”或“停止”，因为没有配置任何可以连续运行的进程。特别是，这意味着在运行这种类型的服务（并且未设置RemainAfterExit =）之后，该服务将不会显示为启动后的状态，而是显示为无效的状态

* dbus的行为类似于 simple。但是，期望该服务在D-Bus总线上获得由BusName = 配置的名称。获得D-Bus总线名称后，systemd将继续启动后续单元。隐式配置了此选项的服务单元将获得对dbus.socket单元的依赖。如果指定BusName =，则此类型为默认类型。

* notify的行为类似于exec；但是，预计该服务在启动完成后会通过sd_notify（3）或等效调用发送通知消息。发送此通知消息后，systemd将继续启动后续单元。如果使用此选项，则应将NotifyAccess =（请参见下文）设置为打开对systemd提供的通知套接字的访问。如果NotifyAccess =丢失或设置为none，则将其强制设置为main  

* 空闲行为与简单行为非常相似。但是，服务程序的实际执行被延迟，直到所有活动作业都被调度为止。这可用于避免将Shell服务的输出与控制台上的状态输出进行交织。请注意，此类型仅对改善控制台输出有用，它对作为通用的单元订购工具没有用，并且此服务类型的效果受5s超时的影响，此后无论如何都将调用服务程序。  

通常建议尽可能将Type = simple用于长时间运行的服务，因为这是最简单，最快的选择。但是，由于此服务类型不会传播服务启动失败，并且不允许在完成服务初始化时订购其他单元（例如，如果客户端需要通过某种形式的IPC连接到服务，这很有用。 ，而IPC通道仅由服务本身建立-与通过套接字或总线激活或类似方式提前进行此操作相反，它在许多情况下可能不够用。如果是这样，则首选方法是notify或dbus（仅在服务提供D-Bus接口的情况下才使用dbus），因为它们使服务程序代码可以准确地计划何时考虑成功启动服务以及何时进行后续操作单位。 notify服务类型需要服务代码库中的显式支持（因为sd_notify（）或服务需要在适当的时间调用等效的API）—如果不支持，则可以使用分叉：它支持传统的UNIX服务启动协议。最后，对于足以确保调用服务二进制文件且服务二进制文件本身不执行或很少执行初始化（并且初始化不太可能失败）的情况，可以使用exec。请注意，使用简单类型以外的任何其他类型都可能会延迟启动过程，因为服务管理器需要等待服务初始化完成。因此，建议不要不必要地使用简单类型以外的任何类型。 （还请注意，通常不建议对长时间运行的服务使用空闲或单发。）

*********************************************************************
RemainAfterExit=
接受一个布尔值，该值指定即使服务的所有进程都退出，该服务是否也应被认为是活动的。默认为否

*********************************************************************

GuessMainPID=
接受一个布尔值，该布尔值指定如果无法可靠确定systemd是否应尝试猜测服务的主PID。除非设置了Type = forking且未设置PIDFile =，否则将忽略此选项，因为对于其他类型或使用显式配置的PID文件，总是知道主PID。如果守护程序包含多个进程，则猜测算法可能得出错误的结论。如果无法确定主要PID，则故障检测和服务的自动重启将无法可靠运行。默认为是。

*********************************************************************
PIDFile=
采用引用服务的PID文件的路径。建议将Type =设置为派生的服务使用此选项。指定的路径通常指向/ run /下的文件。如果指定了相对路径，则其前面带有/ run /。服务启动后，服务管理器将从该文件中读取服务主进程的PID。服务管理器将不会写入此处配置的文件，尽管如果服务仍然存在，它将在服务关闭后删除该文件。 PID文件不需要由特权用户拥有，但是如果它由非特权用户拥有，则将强制执行其他安全限制：该文件可能不是与其他用户拥有的文件的符号链接（无论是直接还是间接） ，并且PID文件必须引用已经属于该服务的进程。

*********************************************************************
BusName=
采用此服务可访问的D-Bus总线名称。对于Type=dbus的服务，此选项是必需的。  

*********************************************************************
ExecStart=    //这个最常用
启动此服务时执行的命令及其参数。  

除非Type =是oneshot，否则必须给出一个命令。当使用Type = oneshot时，可以指定零个或多个命令。可以通过在同一伪指令中提供多个命令行来指定命令，或者，可以多次指定该伪指令以达到相同的效果。如果将空字符串分配给此选项，则将重置要启动的命令列表，该选项的先前分配将无效。如果未指定ExecStart =，则该服务必须具有RemainAfterExit = yes和至少一个ExecStop =行设置。 （同时缺少ExecStart =和ExecStop =的服务无效。）

对于每个指定的命令，第一个参数必须是可执行文件的绝对路径，或者是没有斜杠的简单文件名。 （可选）此文件名可以带有多个特殊字符作为前缀：

* @: 如果可执行文件路径的前缀为“ @”，则第二个指定的标记将作为“ argv [0]”传递给已执行的进程（而不是实际的文件名），再传递其他指定的参数。
* -:如果可执行路径的前缀为“-”，则记录通常被认为是失败的命令的退出代码（即非零退出状态或由于信号导致的异常退出），但是没有进一步的作用，并且被认为等同于成功。
* ':' :如果可执行文件路径的前缀为“：”，则不应用环境变量替换（如下面“命令行”部分所述）。
* '+':如果可执行文件路径的前缀为“ +”，则将以完全特权执行该过程。在此模式下，使用User =，Group =，CapabilityBoundingSet =或各种文件系统名称间隔选项（例如PrivateDevices =，PrivateTmp =）配置的特权限制不会应用于调用的命令行（但仍会影响其他ExecStart =，ExecStop = ，…行）。
* '!':与上面讨论的“ +”字符相似，这允许以提升的特权调用命令行。但是，与“ +”不同，“！”字符专门改变User =，Group =和SupplementaryGroups =的效果，即仅影响用户和组凭据的节。请注意，此设置可以与DynamicUser =组合使用，在这种情况下，将在调用命令之前分配一个动态用户/组对，但是将凭据更改留给已执行的进程本身。
* '!!':该前缀非常类似于“！”，但是它仅对不支持环境过程功能的系统有效，即不支持AmbientCapabilities =。它旨在用于利用环境功能的单位文件，以尽可能以最小的特权运行进程，同时与缺乏环境功能支持的系统保持兼容。请注意，当“ !!”使用，并检测到缺少环境功能支持的系统，将隐式修改任何已配置的SystemCallFilter =和CapabilityBoundingSet =节，以允许生成的进程自己丢弃凭据和功能，即使将其配置为不允许。此外，如果使用此前缀并且检测到缺少环境功能支持的系统，则将跳过AmbientCapabilities =并将其不应用。在支持环境功能的系统上，“ !!”没有效果，并且是多余的。  

“ @”，“-”，“：”和“ +” /“！” /“ !!”之一可以一起使用，并且它们可以按任何顺序出现。但是，“ +”，“！”，“ !!”中只有一个可以一次使用。请注意，其他命令行设置也支持这些前缀，即ExecStartPre =，ExecStartPost =，ExecReload =，ExecStop =和ExecStopPost =。

如果指定了多个命令，则将按照命令在单元文件中出现的顺序依次调用这些命令。如果其中一个命令失败（并且没有前缀“-”），则不会执行其他行，并且该单元将被视为失败。 除非设置了Type = forking，否则通过此命令行启动的进程将被视为守护程序的主进程。

*********************************************************************
ExecStartPre=, ExecStartPost=
在ExecStart =中的命令之前或之后分别执行的其他命令。语法与ExecStart =相同，不同之处在于允许多条命令行，并且一个接一个地依次执行命令。 如果这些命令中的任何一个（不带“-”前缀）失败，则其余命令将不执行，并且该单元将被视为失败。 仅在所有不带前缀“-”的ExecStartPre =命令成功退出后，才运行ExecStart =命令。 仅在成功调用ExecStart =中指定的命令（由Type =确定）后才运行ExecStartPost =命令（即，对于Type = simple或Type = idle，该进程已启动，对于Type = oneshot，最后一个ExecStart =进程已成功退出） ，则针对Type = forking成功退出了初始过程，针对Type = notify发送了“ READY = 1”，或者对于Type = dbus而言已采用BusName =）。 请注意，ExecStartPre =可能不会用于启动长时间运行的进程。通过ExecStartPre =调用的进程派生的所有进程将在运行下一个服务进程之前被杀死。 请注意，如果在ExecStartPre =，ExecStart =或ExecStartPost =中指定的任何命令失败（并且没有以“-”为前缀，请参见上文）或在服务完全启动之前超时，则将继续使用ExecStopPost =中指定的命令执行，将跳过ExecStop =中的命令。 请注意，出于Before = / After =排序约束的目的，考虑了ExecStartPost =的执行。

*********************************************************************
ExecCondition=
在ExecStartPre =中的命令之前执行的可选命令。语法与ExecStart =相同，不同之处在于允许多条命令行，并且一个接一个地依次执行命令。 行为类似于ExecStartPre =和条件检查混合：当ExecCondition =命令以退出代码1到254（包括退出代码）退出时，其余命令将被跳过，并且该单元未标记为失败。但是，如果ExecCondition =命令以255退出或异常退出（例如，超时，被信号杀死等），则该设备将被视为发生故障（剩余的命令将被跳过）。退出代码0或与SuccessExitStatus =匹配的退出代码将继续执行下一条命令。 关于在ExecStartPre =中不运行长时间运行的进程的相同建议也适用于ExecCondition =。在任何非零或异常退出的情况下（如上述），ExecCondition =还将在停止服务的一部分中运行ExecStopPost =中的命令。

*********************************************************************
ExecReload=
执行以触发服务中的配置重新加载的命令。该参数采用多个命令行，遵循与上面对ExecStart =所述的相同方案。此设置的使用是可选的。按照与ExecStart =相同的方案，此处支持说明符和环境变量替换。 设置了一个附加的特殊环境变量：如果知道，$ MAINPID设置为守护程序的主进程，并且可用于以下命令行： ExecReload = kill -HUP $ MAINPID 但是请注意，通过发送信号（如上面的示例行）来重新加载守护程序通常不是一个好选择，因为这是异步操作，因此不适合命令多个服务的重新加载。强烈建议将ExecReload =设置为一个命令，该命令不仅会触发守护程序的配置重载，而且还会同步等待其完成。例如，dbus-broker（1）使用以下代码：


*********************************************************************
ExecStop=
执行命令以停止通过ExecStart =启动的服务。该参数采用多个命令行，遵循与上面对ExecStart =所述的相同方案。此设置的使用是可选的。运行在此选项中配置的命令后，暗示该服务已停止，并且根据KillMode =设置终止了为其剩余的任何进程（请参阅systemd.kill（5））。如果未指定此选项，则当请求停止服务时，通过发送KillSignal =或RestartKillSignal =中指定的信号来终止进程。支持说明符和环境变量替换（包括$ MAINPID，请参见上文）。 请注意，为此命令指定仅要求服务终止的命令通常是不够的（例如，通过向其发送某种形式的终止信号），而没有等待它终止。由于如上所述，在命令退出后立即按照KillMode =和KillSignal =或RestartKillSignal =杀死服务的其余进程，因此这可能不会导致干净停止。因此，指定的命令应该是同步操作，而不是异步操作。 请注意，仅当服务首先成功启动时，才执行ExecStop =中指定的命令。如果根本没有启动服务，或者如果启动失败（例如，由于ExecStart =，ExecStartPre =或ExecStartPost =中指定的任何命令失败，并且没有以“-”作为前缀），则不会调用它们。 ，请参见上文）或超时。当服务无法正确启动并再次关闭时，请使用ExecStopPost =调用命令。另请注意，即使服务成功启动或终止，即使服务成功启动，也始终执行停止操作。必须准备好stop命令来处理这种情况。如果systemd在调用stop命令时知道主进程已退出，则$ MAINPID将被取消设置。 服务重新启动请求被实现为停止操作，然后是启动操作。这意味着ExecStop =和ExecStopPost =在服务重新启动操作期间执行。 建议将此设置用于与要求干净终止的服务通信的命令。对于事后清理步骤，请改用ExecStopPost =。 

*********************************************************************
ExecStopPost=
服务停止后执行的其他命令。这包括使用了ExecStop =中配置的命令，服务未定义任何ExecStop =或服务意外退出的情况。该参数采用多个命令行，遵循与ExecStart =描述的相同方案。这些设置的使用是可选的。支持说明符和环境变量替换。请注意–与ExecStop =不同–当服务无法正确启动并再次关闭时，将调用使用此设置指定的命令。 建议使用此设置进行清理操作，即使服务无法正确启动，清理操作也应执行。即使该服务在中途启动失败并且遗留了未完全初始化的数据，使用此设置配置的命令也必须能够运行。由于执行此设置指定的命令时服务的进程已经终止，因此不应尝试与它们进行通信。 请注意，使用此设置配置的所有命令都将与服务的结果代码以及在$ SERVICE_RESULT，$ EXIT_CODE和$ EXIT_STATUS环境变量中设置的主进程的退出代码和状态一起调用，请参见systemd.exec。 （5）详细。 请注意，出于Before = / After =排序约束的目的，考虑了ExecStopPost =的执行。

*********************************************************************
RestartSec=
配置重新启动服务之前的休眠时间（使用Restart =进行配置）。以秒为单位的无单位值，或“ 5min 20s”之类的时间跨度值。默认为100毫秒。

*********************************************************************
TimeoutStartSec=
配置等待启动的时间。如果守护程序服务在配置的时间内未发出启动信号，则该服务将被视为失败，并将再次关闭。确切的操作取决于TimeoutStartFailureMode =选项。以秒为单位的无单位值，或“ 5min 20s”之类的时间跨度值。传递“ infinity”以禁用超时逻辑。管理器配置文件中的默认值为DefaultTimeoutStartSec =，但使用Type = oneshot时除外，在这种情况下，默认情况下禁用超时（请参见systemd-system.conf（5））。 如果Type = notify服务发送“ EXTEND_TIMEOUT_USEC =…”，则可能导致开始时间超出TimeoutStartSec =。该消息的第一次接收必须在超过TimeoutStartSec =之前发生，并且一旦启动时间超过了TimeoutStartSec =，服务管理器将允许该服务继续启动，前提是该服务在指定的间隔内重复“ EXTEND_TIMEOUT_USEC =…”直到服务启动状态由“ READY = 1”完成为止。 （请参见sd_notify（3））。

*********************************************************************
TimeoutStopSec=
此选项有两个目的。首先，它配置等待每个ExecStop =命令的时间。如果它们中的任何一个超时，则会跳过后续的ExecStop =命令，并且该服务将由SIGTERM终止。如果未指定ExecStop =命令，则该服务将立即获取SIGTERM。可以通过TimeoutStopFailureMode =选项更改此默认行为。其次，它配置等待服务本身停止的时间。如果未在指定时间内终止，它将被SIGKILL强制终止（请参阅systemd.kill（5）中的KillMode =）。以秒为单位的无单位值，或“ 5min 20s”之类的时间跨度值。传递“ infinity”以禁用超时逻辑。从管理器配置文件中默认为DefaultTimeoutStopSec =（请参阅systemd-system.conf（5））。 如果Type = notify服务发送“ EXTEND_TIMEOUT_USEC =…”，则可能导致停止时间超出TimeoutStopSec =。该消息的第一次接收必须在超过TimeoutStopSec =之前发生，并且一旦停止时间超过了TimeoutStopSec =，服务管理器将允许该服务继续停止，只要该服务在指定的间隔内重复“ EXTEND_TIMEOUT_USEC =…”即可。 ，或终止自身（请参阅sd_notify（3））。

*********************************************************************
TimeoutAbortSec=
此选项配置服务由于监视程序超时而中止时等待服务终止的时间（请参阅WatchdogSec =）。如果服务的TimeoutStopSec =短，则可以使用此选项使系统有更多时间写入服务的核心转储。到期后，服务将被SIGKILL强制终止（请参阅systemd.kill（5）中的KillMode =）。在这种情况下，核心文件将被截断。使用TimeoutAbortSec =为每个服务的核心转储设置合理的超时时间，该超时时间应足够大以写入所有期望的数据，同时还应足够短以在适当的时候处理服务故障。 以秒为单位的无单位值，或“ 5min 20s”之类的时间跨度值。传递一个空值可跳过专用的看门狗中止超时处理，并回退TimeoutStopSec =。传递“ infinity”以禁用超时逻辑。从管理器配置文件中默认为DefaultTimeoutAbortSec =（请参阅systemd-system.conf（5））。 如果Type = notify服务本身处理SIGABRT（而不是依靠内核编写核心转储），则可以发送“ EXTEND_TIMEOUT_USEC =…”以将中止时间延长到TimeoutAbortSec =之后。该消息的第一次接收必须在超过TimeoutAbortSec =之前发生，并且一旦中止时间超过了TimeoutAbortSec =，服务管理器将允许该服务继续中止，前提是该服务在指定的间隔内重复“ EXTEND_TIMEOUT_USEC =…” ，或终止自身（请参阅sd_notify（3））。

*********************************************************************
TimeoutSec=
将TimeoutStartSec =和TimeoutStopSec =都配置为指定值的简写。

*********************************************************************
TimeoutStartFailureMode=, TimeoutStopFailureMode=
这些选项配置在守护程序服务未在其配置的TimeoutStartSec =中未发出启动信号的情况下所采取的操作，如果该服务未在TimeoutStopSec =中停止的话。采取终止，中止和杀死之一。这两个选项默认都终止。 如果设置了终止，则将通过发送KillSignal =中指定的信号（默认为SIGTERM，请参见systemd.kill（5））来正常终止该服务。如果服务没有终止，则在TimeoutStopSec =之后发送FinalKillSignal =。如果设置了中止，则发送WatchdogSignal =，并且在发送FinalKillSignal =之前应用TimeoutAbortSec =。此设置可用于分析间歇性启动或关闭失败的服务。通过使用kill命令，通过发送FinalKillSignal =可以立即终止服务，而无需任何其他超时。此设置可用于加快故障服务的关闭速度。

*********************************************************************
RuntimeMaxSec=
配置服务运行的最长时间。如果使用了此选项，并且该服务的活动时间超过了指定的时间，则该服务将终止并进入失败状态。请注意，此设置对Type = oneshot服务没有任何影响，因为它们在激活完成后立即终止。传递“ infinity”（默认值）以配置无运行时限制。 如果Type = notify服务发送“ EXTEND_TIMEOUT_USEC =…”，则可能导致运行库扩展到RuntimeMaxSec =之后。该消息的首次接收必须在超出RuntimeMaxSec =之前发生，并且一旦运行时超出了RuntimeMaxSec =，服务管理器将允许该服务继续运行，前提是该服务在指定的间隔内重复“ EXTEND_TIMEOUT_USEC =…”，直到通过“ STOPPING = 1”（或终止）实现服务关闭。 （请参见sd_notify（3））。

*********************************************************************
WatchdogSec=
配置服务的看门狗超时。启动完成后，将启动看门狗。服务必须使用“ WATCHDOG = 1”（即“保持活动的ping”）定期调用sd_notify（3）。如果两次调用之间的时间大于配置的时间，则该服务将处于失败状态，并且将通过SIGABRT（或WatchdogSignal =指定的信号）终止该服务。通过将Restart =设置为失败，看门狗，异常或始终，服务将自动重新启动。此处配置的时间将在WATCHDOG_USEC =环境变量中传递给已执行的服务过程。如果为服务启用了看门狗支持，则这允许守护程序自动启用保持活动的ping逻辑。如果使用此选项，则应将NotifyAccess =（请参见下文）设置为打开对systemd提供的通知套接字的访问。如果未设置NotifyAccess =，它将隐式设置为main。默认值为0，这将禁用此功能。服务可以检查服务管理器是否期望看门狗保持活动通知。有关详细信息，请参见sd_watchdog_enabled（3）。 sd_event_set_watchdog（3）可用于启用自动看门狗通知支持。

*********************************************************************
Restart=
配置在服务进程退出，被终止或达到超时时是否应重新启动服务。服务进程可能是主要的服务进程，但也可能是用ExecStartPre =，ExecStartPost =，ExecStop =，ExecStopPost =或ExecReload =指定的进程之一。如果进程死于systemd操作（例如服务停止或重新启动）的结果，则该服务将不会重新启动。超时包括错过看门狗“保持活动ping”期限以及服务启动，重新加载和停止操作超时。 采取否，成功，失败，异常，看门狗，中止或始终采取其中一种。如果设置为no（默认值），该服务将不会重新启动。如果设置为成功，则仅当服务进程完全退出时才重新启动。在这种情况下，干净的退出是指退出代码为0，或者是信号SIGHUP，SIGINT，SIGTERM或SIGPIPE之一，另外，还包括退出状态和在SuccessExitStatus =中指定的信号。如果设置为on-failure，则当进程以非零退出代码退出时，将通过信号（包括核心转储，但不包括上述四个信号）终止操作时（例如服务），服务将重新启动重新加载）超时，以及触发配置的看门狗超时。如果设置为on-onnormal，则当进程通过信号终止时（包括在核心转储上，不包括上述四个信号），操作超时或触发看门狗超时时，将重新启动服务。如果设置为中止，则仅当服务进程由于未将未捕获的信号指定为干净退出状态而退出时，才会重新启动服务。如果设置为on-watchdog，则仅当服务的看门狗超时到期时才会重新启动服务。如果设置为Always，则无论该服务是否干净退出，是否因信号异常终止或超时，都将重新启动该服务。

表格参照：https://www.freedesktop.org/software/systemd/man/systemd.service.html#Restart=

作为上述设置的例外，如果在RestartPreventExitStatus =（请参阅下文）中指定了退出代码或信号，或者通过systemctl stop或等效操作停止了服务，则该服务将不会重新启动。另外，如果在RestartForceExitStatus =中指定了退出代码或信号，则将始终重新启动服务（请参见下文）。 请注意，服务重启受使用StartLimitIntervalSec =和StartLimitBurst =配置的单位启动速率限制的约束，有关详细信息，请参见systemd.unit（5）。仅在达到启动限制后，重新启动的服务才会进入失败状态。 对于长时间运行的服务，建议将其设置为on-failure，以通过尝试从错误中自动恢复来提高可靠性。对于应该能够自行终止（并避免立即重启）的服务，异常启动是一种替代选择。

*********************************************************************
SuccessExitStatus=
列出退出状态定义的列表，这些退出状态定义在由主服务流程返回时，除了正常的成功退出状态0和信号SIGHUP，SIGINT，SIGTERM和SIGPIPE之外，还将被视为成功终止。退出状态定义可以是数字终止状态，终止状态名称或终止信号名称，以空格分隔。有关终止状态名称的列表，请参见systemd.exec（5）中的“过程退出代码”部分（对于此设置，仅应使用没有“ EXIT_”或“ EX_”前缀的部分）。有关信号名称的列表，请参见signal（7）。 请注意，此设置不会更改数字出口状态与其名称之间的映射，即无论如何使用此设置，0仍将映射到“ SUCCESS”（因此在工具输出中通常显示为“ 0 / SUCCESS”）和1到“失败”（因此通常显示为“ 1 /失败”），依此类推。它仅控制由于这些退出状态而发生的情况，以及它如何传播到整个服务状态。 此选项可能会出现多次，在这种情况下，成功退出状态的列表将被合并。如果将空字符串分配给该选项，则列表将被重置，此选项的所有先前分配均无效

*********************************************************************
RestartPreventExitStatus=
获取退出状态定义的列表，这些退出状态定义在由主服务进程返回时将阻止自动服务重新启动，而不管使用Restart =配置的重新启动设置如何。出口状态定义可以是数字出口代码或终止信号名称，并用空格分隔。默认为空列表，因此默认情况下，已配置的重启逻辑不会排除任何退出状态。例如： RestartPreventExitStatus = 1 6 SIGABRT 确保退出代码1和6以及终止信号SIGABRT不会导致服务自动重启。此选项可能会出现多次，在这种情况下，重新启动阻止状态列表将合并。如果将空字符串分配给该选项，则列表将被重置，并且此选项的所有先前分配都将无效。 请注意，此设置对通过ExecStartPre =，ExecStartPost =，ExecStop =，ExecStopPost =或ExecReload =配置的进程无效，而仅对主服务进程有效，即由ExecStart =调用的进程或（取决于Type =，PIDFile =，…）否则配置的主进程。

*********************************************************************
RestartForceExitStatus=
获取退出状态定义的列表，这些退出状态定义在由主服务进程返回时将强制自动重新启动服务，而与使用Restart =配置的重新启动设置无关。参数格式类似于RestartPreventExitStatus =。

*********************************************************************
RootDirectoryStartOnly=
接受布尔参数。如果为true，则使用RootDirectory =选项配置的根目录（有关更多信息，请参见systemd.exec（5））仅应用于以ExecStart =开头的进程，而不应用于其他各种ExecStartPre =，ExecStartPost =， ExecReload =，ExecStop =和ExecStopPost =命令。如果为false，则该设置以相同的方式应用于所有已配置的命令。默认为false。

*********************************************************************
NonBlocking=
为通过基于套接字的激活传递的所有文件描述符设置O_NONBLOCK标志。如果为true，则所有文件描述符> = 3（即除stdin，stdout，stderr以外的所有文件描述符），不包括通过文件描述符存储逻辑传递的文件描述符（有关详细信息，请参见FileDescriptorStoreMax =），将设置O_NONBLOCK标志，因此处于非阻止模式。如systemd.socket（5）中所述，此选项仅与套接字单元结合使用才有用，并且对以前保存在文件描述符存储中的文件描述符没有影响。默认为false。

*********************************************************************
NotifyAccess=
控制对服务状态通知套接字的访问，可以通过sd_notify（3）调用进行访问。采用无（默认），main，exec或全部之一。如果没有，则服务进程不接受守护程序状态更新，所有状态更新消息都将被忽略。如果为main，则仅接受从服务的主进程发送的服务更新。如果为exec，则仅接受来自任何一个Exec * =命令的主进程或控制进程发送的服务更新。如果全部包含，则接受服务控制组的所有成员的所有服务更新。使用Type = notify或WatchdogSec =时，应将此选项设置为打开对通知套接字的访问权限（请参见上文）。如果使用了这些选项，但未配置NotifyAccess =，它将隐式设置为main。 请注意，只有在PID 1处理消息时发送过程仍在附近，或者服务管理器明确在运行时跟踪发送过程时，sd_notify（）通知才可以正确地归属于单元。如果服务管理器最初是在流程中（即在与main或exec匹配的所有流程上）分叉的，则属于后者。相反，如果单元的辅助进程发送sd_notify（）消息并立即退出，则服务管理器可能无法正确地将该消息归因于该单元，因此即使已为其设置NotifyAccess = all，也将忽略该消息。 。 因此，要消除所有涉及查找客户端单元以及正确将通知归属于单元的争用条件，可以使用sd_notify_barrier（）。此调用充当同步点，并确保成功返回服务管理器后，该调用之前已发送的所有通知均已被接听。对于未由服务管理器调用的客户端，需要使用sd_notify_barrier（），否则，对于将通知分配给该单元，此同步机制是不必要的。

*********************************************************************
Sockets=
指定此服务将在启动服务时继承套接字文件描述符的套接字单元的名称。通常，没有必要使用此设置，因为其单位与服务共享相同名称的所有套接字文件描述符（当然，要使用不同的单位名称后缀）都将传递给生成的进程。 注意，相同的套接字文件描述符可以同时传递给多个进程。还要注意，与最终配置为继承套接字文件描述符的服务不同，传入套接字流量可能会激活另一种服务。或者，换句话说：.socket单元的Service =设置不必与它所引用的.service的Sockets =设置相反。 该选项可能会出现多次，在这种情况下，套接字单元的列表将被合并。请注意，设置后，不支持再次清除套接字列表（例如，通过为该选项分配空字符串）。

*********************************************************************
FileDescriptorStoreMax=
使用sd_pid_notify_with_fds（3）的“ FDSTORE = 1”消息，配置在服务的服务管理器中可以存储多少文件描述符。这对于实现可以在显式请求或崩溃后重新启动而不会丢失状态的服务非常有用。重新启动期间不应关闭的所有打开的套接字和其他文件描述符都可以用这种方式存储。应用程序状态可以序列化为/ run中的文件，或者更好地存储在memfd_create（2）内存文件描述符中。默认值为0，即服务管理器中不能存储任何文件描述符。从特定服务传递到服务管理器的所有文件描述符在下次服务重新启动时都传递回服务的主进程。当在其上看到POLLHUP或POLLERR时，或者当服务完全停止并且没有作业排队或正在执行时，传递给服务管理器的所有文件描述符都将自动关闭。如果使用此选项，则应将NotifyAccess =（请参见上文）设置为打开对systemd提供的通知套接字的访问。如果未设置NotifyAccess =，它将隐式设置为main。

*********************************************************************
USBFunctionDescriptors=
配置包含USB FunctionFS描述符的文件的位置，以实现USB小工具功能。仅与配置了ListenUSBFunction =的套接字单元一起使用。该文件的内容在打开后被写入ep0文件

*********************************************************************
USBFunctionStrings=
配置包含USB FunctionFS字符串的文件的位置。行为类似于上面的USBFunctionDescriptors =。

*********************************************************************
OOMPolicy=
配置内存不足（OOM）阻止程序策略。在Linux上，当内存不足时，内核可能决定终止正在运行的进程，以释放内存并减少内存压力。此设置需要继续，停止或终止之一。如果设置为继续，并且服务的进程被内核的OOM杀手杀死，则将记录该事件，但服务将继续运行。如果设置为stop，则会记录事件，但服务管理器会彻底终止该服务。如果设置为kill且OOM杀手将服务的进程之一杀死，则内核也会被指示杀死服务的所有其余进程。默认情况下，systemd-system.conf（5）中的设置DefaultOOMPolicy =设置为，但打开Delegate =的服务除外，默认情况下此设置将继续。 使用OOMScoreAdjust =设置来配置是否应将单元的进程视为Linux OOM杀手级逻辑终止进程的首选或次首选。有关详细信息，请参见systemd.exec（5）。


## 命令行
本节介绍ExecStart =，ExecStartPre =，ExecStartPost =，ExecReload =，ExecStop =和ExecStopPost =选项的命令行解析以及变量和说明符替换。 可以通过用分号将多个命令行分隔开来将多个命令行连接在一起（这些分号必须作为单独的单词传递）。单独的分号可以转义为“ \;”。 每个命令行都在空白处分割，第一项是要执行的命令，随后的项是参数。可以使用双引号（“…”）和单引号（'…'）来包装整个项目（开头的引号只能出现在未引用的空白的开始或之后，并且结尾的引号后必须跟空白或行尾），在这种情况下，直到下一个匹配的引号为止的所有内容都成为同一参数的一部分。引号本身将被删除。还支持C样式转义符。下表包含已知的转义模式列表。只允许使用与表中语法相匹配的转义模式；将来可能会添加其他模式，未知模式将导致警告。特别是，任何反斜杠都应加倍。最后，可以使用尾部反斜杠（“ \”）合并行。 此语法受Shell语法启发，但仅理解以下各段中描述的元字符和扩展，并且变量的扩展不同。具体来说，不支持使用“ <”，“ <<”，““>”和“ >>”的重定向，使用“ |”的管道，使用“＆”在后台运行程序以及shell语法的其他元素。 要执行的命令可能包含空格，但不允许使用控制字符。 命令行接受systemd.unit（5）中所述的“％”说明符。 支持基本环境变量替换。在命令行上使用“ $ {FOO}”作为单词的一部分或作为其自己的单词，在这种情况下，它将被擦除并替换为环境变量（包括所有空格）的确切值（如果有）它包含，总是导致仅一个参数。在命令行上使用“ $ FOO”作为单独的单词，在这种情况下，它将被在空格处分割的环境变量的值替换，从而导致零个或多个参数。对于这种类型的扩展，在分解为单词并随后将其删除时，会使用引号。 如果该命令不是完整（绝对）路径，则将使用在编译时确定的固定搜索路径将其解析为完整路径。在使用拆分的/ usr / bin /和/ bin /目录的系统上，搜索的目录包括/ usr / local / bin /，/ usr / bin /，/ bin /，在使用split bin /和sbin /的系统上，搜索的目录与sbin /对应。因此，如果可执行文件位于任何“标准”目录中，则仅使用可执行文件名称是安全的，在其他情况下，必须使用绝对路径。建议使用绝对路径以避免歧义。提示：可以使用systemd-path search-binaries-default查询此搜索路径。

examples：参考
https://www.freedesktop.org/software/systemd/man/systemd.service.html#Restart=






# buddy 子系统 - 初始化

在内核的内存初始化阶段，memblock 在完成了一些最基本的物理内存信息收集以及必要的内存分配之后，就需要着手开始向 buddy 系统进行迁移了，毕竟 buddy 子系统越早启动，内核就越早进入到内存管理的正轨。

但是这个过程并不是一步就位的，内存所涉及到的方方面面本身是非常复杂的，尽管 buddy 系统已经足够简单，那也只是相对其它的内存管理器而言，本章着重于分析 buddy 子系统的初始化的早期部分，也就是一些准备工作。 

## 背景

memblock 作为内核早期的内存管理器，有几个重要的阶段：

* 在内核中被静态定义，整个内存管理器由 memory 和 reserved 两个数组来管理物理内存

* 扫描设备树，获取系统中所有物理内存信息
* 为内核镜像、dtb、设备树中指定内存等区域设置保留空间，并针对一些必要的部分分配物理内存
* 为所有物理内存建立页表，不过建立页表的工作并不完全算 memblock 来做的，它只是提供相应的内存信息，总之，在此之后，系统中所提供的所有物理内存及其属性都已经确定，线性映射区可以访问了。

在这种情况下，buddy 子系统已经具备了启动的环境，memblock 开始慢慢地将内存管理的重任交接给 buddy 子系统。



## 基本概念

memblock 足够简单，简单到将所有的物理内存一视同仁，但实际上鉴于内核亦或是硬件的一些特性，内核如果想要更高的效率和利用率，比如对内存管理工作进行细化。在了解 buddy 所做的这些工作之前，我们需要先了解几个概念。



### 内存模型

内存模型这个概念其实是有些抽象的，没办法，对应的英文就是 memory model，其实就是规定如何对物理内存进行组织，内核中的内存模型分为三种：

* FLATMEM：平坦内存模型
* DISCONTIGMEM：非连续内存模型
* SPARSEMEM：稀疏内存模型

软件总归是基于硬件进行抽象，内核使用哪种内存模型取决于系统的物理内存是如何分布的，在嵌入式系统中，物理内存通常是连续的，这种情况下的物理内存管理是最简单的，平坦内存模型适用于这种情况。

在内核中，既然要对每个物理页面进行管理，那么自然是需要使用特定的数据结构对其进行描述，记录页面的相关信息，内核中使用 struct page 结构来描述一个页面，在平坦内存模型中，所有的页面对应的 struct page 结构可以存放在一片连续的内存中。

这种结构带来的好处在于：物理页面与 struct page 之间的关联实现非常简单，这种关联在于通过一方可以快速地索引到另一方，连续的内存可以直接使用偏移地址获得对方的地址。 

实际的情况也可能并不理想，系统中连接的物理内存可能并不是连续的，被分为一块或者多块，页面依旧使用 struct page 来表示，但是如果还是按照原来的方案(连续内存)来保存所有物理内存的 struct page，这种物理内存上的空洞必定会带来内存空洞处对应的 struct page 是没有意义的，也就是会造成内存的浪费，为了避免这种浪费，非连续内存模型被提出，顾名思义，这种内存模型用来管理非连续的物理内存





### NUMA 节点

尽管本系列文章并不涉及到 numa 系统的分析，同时，内核针对 numa 和 非 numa 系统使用统一的接口，在分析内存时还是不能忽略这个概念。

在内核中，buddy 子系统会将所有机器抽象为 numa 架构，非 numa 系统被内核视为单节点 numa 系统，这样就可以实现接口的统一。

因此，不难推出，一个 numa 节点就是一个完整的内存管理区域，每个 numa 节点包含一个 struct pglist_data 结构，同样是以 pgdat  -> zones  -> pages 的树形结构来管理一片完整的物理内存。 











内存模型

zone

为 struct page 分配内存



 内存模型：https://zhuanlan.zhihu.com/p/220068494
# 内存初始化 - 建立内核页表

在内核开启 MMU 之后，整个内存世界实际上还处于一片黑暗之中，毕竟这时候内核并不知道当前系统中物理内存的信息，只是为内核 image、dtb 建立了页表，内核只有访问这两部分才是安全的。

紧接着，memblock 内存分配器就开始工作了，这是内核中静态定义的一个内存管理器，其首要工作就是将所有问你内存纳入管理，首先从通过扫描 dtb 获取物理内存的相关信息，看清楚整个物理内存世界，然后将那些已经被使用的内存设为保留，比如内核镜像所在内存、dtb 内存、页表内存。至于其它的内存都是空闲可支配的。

但是，很可惜的是，由于其它空闲内存的页表没有建立，那些物理内存只能看到还不能摸到，因此，目前最紧急的任务就是建立物理内存的页表映射。 



## 内核页表的建立

首先，内核页表的基地址已经在此前确定了，为物理起始地址的 0x00004000 偏移处，占用 16K 的连续物理内存，将新建立的页表保存在该物理地址上即可，毕竟 MMU 要求内核给出的页表基地址为物理地址。 

实际上，起始地址偏移 0x00004000~0x00008000 这一段物理地址映射的是 4G 的内存，而内核只占用了最高 1G 内存，因此内核实际页表项的地址为 起始物理地址+0x00007000，不过设置到 MMU 的地址依旧是 0x00004000 偏移处。 

同时，内核中只有线性映射区才会直接建立页表，而对于高端内存是无法建立页表的，这并不难理解，假设物理内存有 1.5 G，已经超出了内核本身的线性空间，自然有一部分物理内存是无法建立直接映射的，关于内核中的内存区域 ZONE 的概念可以参考 TODO。

**有个不太好理解，但是非常重要的概念是：内核中线性映射区对于物理内存的映射仅仅是建立映射，内核可以直接访问这些内存，从而进行管理，而用户空间使用内存时建立的内存映射是基于内存分配的需求。**

**因此，对于用户空间而言，虚拟内存到物理内存的映射必须是分配大小的粒度，也就是 4K，但是内核中可以使用 section map，也就是 1M 的映射，这并不影响内核对物理内存的管理，分配时照样可以使用 4K 的粒度进行，毕竟 pfn 和 struct page 都是以 4K 页面进行索引的。**

内核中使用 section 映射的好处在于：

* 节省内存，不再需要分配二级页表项 block
* 节省内存访问时间，内存访问只需要翻译一次，不需要经过二级页表项的翻译



### 建立映射

内核线性映射内存区映射的建立在  paging_init -> map_lowmem 函数中，对于所有的空闲内存，默认映射为 RW 属性，而对于内核而言，需要加上 X 属性，不然内核代码无法执行，尽管内核在开启 MMU 的阶段已经映射过了，但是那毕竟只是在不知道物理内存信息的情况下建立的临时映射，因此内核需要重新映射为 RWX 属性，而 dtb 占用的内存也是 RW 属性，和空闲内存一起做映射即可。

因此，内核线性空间的映射通常被分为三个部分：

* 内核镜像之前的物理内存映射，RW 属性
* 内核镜像的重新映射，RWX 属性
* 内核镜像之后的物理内存映射，RW 属性

在 map_lowmem 函数中，先是对上面所提到的三个内存区域空间进行计算，然后分别映射，建立内存映射的函数为 create_mapping，该函数接受一个 struct map_desc 类型的参数：

```c++
struct map_desc {
	unsigned long virtual;
	unsigned long pfn;
	unsigned long length;
	unsigned int type;
};
```

这个参数非常好理解，既然是虚拟内存到物理页面的映射，自然包括虚拟内存地址、物理页面页帧号 pfn，映射长度以及映射类型。 



### pgd、pud、pmd、pte

对于 arm32 而言，硬件上就决定了可以使用一级页表(section map)或者二级页表(page table map)，对于 64 位系统而言，因为支持的线性内存空间巨大，需要使用 4 级页表，linux 为了兼容所有的硬件设备，因此内核统一支持 4 级页表：

* pgd：页全局目录
* pud：页上级目录
* pmd：页中间目录
* pte：页表项入口

对于 arm32 而言，并不需要使用到 pud 和 pmd，直接让 pgd 目录项指向 pte 即可，将 pud 和 pmd 折叠，做法就是直接让 pud 和 pmd 指向 pgd，这种折叠并没有太多成本，只是在创建页表的时候多两层函数调用而已。 



### 硬件页表与内核页表

在 TODO 这篇博客中介绍到，armv7 规定在实现 4K page table map 时，二级页表项为 256 项，每项占用 4 bytes，一个二级页表 block 占用 1K 的空间，但是问题在于页面大小为 4K，因此需要多个二级页表 block 存放到一个 page 中，以免造成内存的浪费。理论上一个 page 中可以存放 4 个二级页表 block。

实际情况并不是这样，由于 armv7 处理器设计的特殊性

实际情况是，一个页面只会存放两个二级页表 block，这是硬件页表 block，剩下的 2K 空间存放的是内核页表 block，那么，为什么内核会需要两个页表block？








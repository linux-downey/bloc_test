# 深入解析Makefile系列(0) -- 初识Makefile
从事C/C++相关的编程人员都或多或少地对makefile有所了解，尤其是linux环境下的开发，更是经常与其打交道。 通俗地说，Makefile是一种编译规则指导文件，make程序通过读取Makefile的内容来决定软件的编译方式。  

随着软件行业的持续发展，也出现了各种各样的工具自动生成Makefile，比如GNU官方发布的auto tools，或者第三方软件cmake，相比于自己编写Makefile而言，其自动生成且跨平台的特性更加的方便可靠，那是不是有了这些工具，我们就可以不用了解Makefile的运行规则了呢？  

其实不然，即使是不用自己动手写，至少需要能读懂复杂的Makefile，再者说，对底层原理探究的欲望应该是每个软件工作者所具备的，所以，这一系列文章将深入地解析Makefile。

## 程序的编译
既然make工具以及Makefile是服务于程序编译的，那么，我们以C语言程序为例来看看程序的编译过程是怎样的。 

首先，你肯定知道编译工具链使用的是gcc(C++为g++)，早期的gcc全称为GNU C Compiler，它只负责处理C语言。GCC在发布之后很快就得到了扩展，支持C++/Fortran/Objective-C等一系列语言，后期改名为GNU Compiler Collection，指一套语言编译器。  

### 简单的示例
我们用一个简单的示例来看看gcc的编译语法，当我们需要编译main.c时，编译语法是这样的：

        gcc main.c -o main
如果程序不报错，编译生成的结果就是可执行文件main，我们可以运行该可执行文件以执行我们的程序：

        ./main
其中，main.c表示需要编译的文件，-o为编译选项，这个选项的作用是指定生成的可执行文件名称，gcc的选项就不在这里过多赘述。   

对应一个简单的程序，可能只有少量的几个文件，我们可以轻松做到在命令行下直接使用gcc指令编译，但是涉及到稍微大一点的工程，比如上百个文件，自然不能再使用这种方式来处理，这时候我们需要用到另一个工具：make。

## make工具
make工具专门用作源代码的编译以及工程的构建，它通过读取Makefile文件来确定整个编译过程，当用户需要编译一个大型程序时，通常需要编写一份Makefile文件来指导工程的编译。  

## 简单的makefile示例
俗话说，一例胜千言，在讲解makefile之前我们先贴上一个简单的makefile示例：

    1. main:foo.c foo.h common.h
	2.    gcc foo.c -o main

    3. clean:
    4.    -rm main
我们只需要键入下面的指令就可以执行编译：

    make

在这个示例中，一共编译三个文件foo.c,foo.h,common.h。  

标准的makefile中编译规则是这样的：

    目标 … : 依赖 …
        命令
        …

**规则：**指编译生成一个目标的完整语句，通常包含目标，依赖和命令。
**目标：**编译过程中需要生成的文件，一个目标同样可以是一个需要执行的命令。
**依赖：**编译目标时需要依赖的文件列表，以空格分隔
**命令：**被执行的指令，注意命令部分需要以tab开头，**值得注意的是，命令部分的语句将会由makefile的规则做简单替换(变量替换，通配符的替换等等)之后被传递给shell，由shell解析，并不完全遵循makefile的语法规则**，同时，命令部分并不一定需要重启一行，也可能出现在依赖文件列表行，但是并不建议这么做。  

## 示例解析

### make解析目标文件
当我们键入make指令之后，make就会在当前目录下寻找名为GNUmakefile，makefile、Makefile的文件，make默认读取这三种名称的文件并解析，当同时存在两种及以上的上述文件时，处理优先级为：GNUmakefile > makefile > Makefile。

即同时存在makefile和Makefile时，make只处理makefile文件而忽略Makefile。  

同时，用户可以使用**-f参数**来为指定特定的Makefile文件，它可以是任意名称。例如：

    make -f file

虽然make对需要解析的目标文件有许多扩展，但是建议使用目前最为通用的名称：Makefile，毕竟标准化也是软件中非常重要的一部分。  

### make解析目标
在上述示例中，存在两个目标：**main**和**clean**。  

make的规则是：**默认使用第一个不以"."(常用语伪目标)，"%"(常用于模式匹配)开头命名的目标作为编译生成的结果**。所以，上述示例中使用make编译的结果是生成main。  

同时，make后可以跟一个目标名参数表示指定编译生成某个目标，所以在上述示例中，make等同于下面的指令：

    make main
这条指令的执行流程是：
* 检查依赖文件是否有更新，同时检查目标文件是否存在
* 如果依赖文件有更新或者没有目标文件，执行命令部分以重新生成目标
* 如果依赖文件没有更新，不重新编译生成目标
* 如果一个依赖文件是一个目标，则先编译生成依赖文件。  

这是make对于目标的生成规则，至于为什么先要检查依赖文件是否更新呢？其实不难理解，对于那些没有修改的文件，我们重新编译的时候，自然不愿意将所有文件全部重新编译一遍，这样会很浪费时间，在编译大型软件的时候这一点显得尤为重要。  

如果一个依赖文件没有目标，则先编译生成依赖文件。所以，通常的makefile写法是将需要生成的最终的目标(通常是可执行文件，或者是最后要生成的库文件)作为第一个目标，后面跟着依赖文件的生成规则，再是编译过程的其他目标。总体上来看makefile的布局是这样的：

    TODO    
当然这只是大体上的布局，具体的实现可能更加细化，也可能会有适当的交叉。  
 

### 伪目标
在上面的Makefile示例中，可以发现除了目标**main**之外还有另一个目标**clean**，根据make的默认规则，在键入**make**时，这个**clean**是不会被执行的，同时，值得注意的是，这个目标并没有**依赖文件**，只有**目标**和**命令**。  

这一类目标在makefile中叫做伪目标，普通目标对应着一个需要被生成的文件，而伪目标不对应具体的文件，它仅仅充当一个目标的标识。  

***  
对于伪目标有一个常见的误区：没有依赖文件且不生成以目标名命名的文件，这个目标就是伪目标。例如下面这个例子：

    clean:
        -rm main
它即没有依赖文件，同时也不会生成目标文件**clean**。所以**clean**是一个伪目标。  
***   
这种说法算是一个可以接受的答案，但却不是标准答案。    

从应用的角度上来说，没有依赖文件且不生成对应的目标文件，这个目标就算是个伪目标，依据这条规则去编写Makefile是没有问题的，但是，Makefile是由make来解析的，是不是伪目标还是得make说了算。  

事实上，make遇到这种“我们所认为的伪目标”，它依旧会将其当成一个普通目标去解析。这个目标总是不生成对应目标文件，在检查依赖更新时make将其当成一个没有生成目标文件的普通目标，需要重新编译，在运行命令时会调用隐式规则试图去解析它，尽管最后执行的结果是一样的。  
*** 

如果需要定义一个伪目标，我们可以直接使用Makefile语法支持的关键字：*.PHONY*,这个关键词显式地指定一个伪目标。  

它的使用方式是这样的：

    .PHONY : clean
    clean:
        -rm main

这样显式地定义伪目标的好处有两点：
* 如果同时存在一个普通目标**clean**,当前定义的伪目标将无法执行，显式定义伪目标可以解决这个问题，在出现同名普通目标时，它将覆盖普通目标得以执行，make将输出警告信息。
* 告诉make这就是一个伪目标，不要试图对其做其他处理，这样可以提高编译效率，减少编译时间。  

*** 

既然没有依赖且不生成对应目标文件的目标可以被看成伪目标，那么是不是伪目标都是没有依赖且不生成对应目标文件呢？  

其实不然，伪目标是可以有依赖的，同样地，伪目标对应的命令也可以生成一些文件(这取决于伪目标的命令部分)，这并非makefile语法作的强制要求。  

makefile的语法规定，伪目标不生成对应的目标文件，每次调用伪目标时都会重新执行一次伪目标的命令。所以不要将伪目标作为其他普通目标的依赖，这会导致对应普通目标每次都被重新编译(因为伪目标每次都需要被重新编译)。  
*** 

### 依赖文件
依赖文件的作用是：提供给make一个文件列表，当当前目标需要被指定编译时就会去检查这个文件列表中的文件是否有更新，如果有更新，就重新编译这个目标，否则不进行编译。 


### 命令
接下来我们来讲解makefile目标生成规则中三要素中的**命令**。  

值得注意的是，当命令即将开始执行的时候，make对其的操作是将命令完整地传递给shell，而不是由makefile的语法来解析。  

认识到这一点是非常有必要的，因为makefile的处理语法与shell的处理语法有一些小区别，至于具体的区别完全取决于使用的shell。

尽管如此，命令中是可以调用makefile的环境变量，命令继承makefile的环境，即在命令执行前先将变量展开再传递给shell。

### 重要的事情再说一遍
博主觉得有必要将make的执行顺序再强调一遍，因为这事make规则中最基础最重点的一部分：
* 检查依赖文件是否有更新，同时检查目标文件是否存在
* 如果依赖文件有更新或者没有目标文件，执行命令部分以重新生成目标
* 如果依赖文件没有更新，不重新编译生成目标

如果你觉得你已经理解了，可以来看看博主出的这道题：

    定义一个不带依赖文件列表的目标，目标的命令部分生成该目标，假设目标为名为test，它的形式是这样的：
    ...
        test:
            touch test
    ...
    调用make test 
    会发生什么？重复调用会有什么样的问题？
    如果将test显式定义为伪目标结果会不会一样？
    (答案以及讲解将在本系列文章下一章揭晓)。  
        
***  
***  
***  
参考资料：[官方文档](https://www.gnu.org/software/make/manual/make.html)

***  
好了，关于深入解析Makefile系列(0) -- 初识Makefile的讨论就到此为止啦，如果朋友们对于这个有什么疑问或者发现有文章中有什么错误，欢迎留言

***原创博客，转载请注明出处！***

祝各位早日实现项目丛中过，bug不沾身.



































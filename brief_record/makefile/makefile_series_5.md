# 深入解析Makefile系列(5) -- 条件判断以及运行时指定环境

在前面的makefile章节中，博主已经介绍了makefile的大部分内容，随着研究的深入，我们也需要来研究更为复杂的问题，在这一章节中我们来探讨一下makefile中的条件判断及处理。    

## 为什么需要条件处理
在编译工程时，我们通常要处理多种情况，比如工程的测试版本和发布版本，又比如不同架构之间的兼容，我们常常需要同时考虑好几种情况。  
但是，针对每一种情况实现一个makefile又显得太过于臃肿，所以就需要用到makefile中的条件处理。  

## 条件语句
条件语句的表达式语法为：

    <conditional-directive>
    <text-if-true>
    endif

或者

    <conditional-directive>
    <text-if-true>
    else
    <text-if-false>
    endif

### ifeq

这里的<conditional-directive>由条件语句代替，可以是ifeq，例如下面这个例子：

    ifeq (var1,var2)
        ...
    else
        ...
    endif
ifeq与后面接的条件判断式之间必须有空格。  
执行语句即\<text-if-true\>部分可以有空格和tab键。  

这个语句的本意就是比较var1和var2的值是否相同，根据结果执行不同的分支。ifeq是最常用的条件判断语句之一，除了使用()来放置参数，它还支持下面几种语法：

    ifeq 'var1' 'var2'
    ifeq "var1" "var2"
    ifeq 'var1' "var2"
    ifeq "var1" 'var2'
即单引号和双引号在判断中表示同样的含义。  

### ifneq
既然有ifeq，那么相对应的，就会有ifneq，ifneq的作用与ifnq相反。  
当两个变量不相等时，返回真。  
当两个变量相等时，返回假。  


### ifdef
ifdef指令的语法为：

    ifdef <variable-name>
用于测试一个变量是否有值，值为空则返回假，值为非空则返回真，即使是值为false或False之类的，也是返回真。  
**需要注意的是，ifdef指令只判断变量是否有值，并不会对其进行扩展。**，我们来看下面一个例子：

    foo =
    bar = $(foo)
    ifdef bar
        foobar = yes
    else
        foobar = no
    endif
最后输出的结果:$(foobar)的值为yes，因为$(bar)的值为foo的引用，不算空值，即使foo为空。  
但是，如果写成这样，效果就不一样了：

    foo :=
    bar := $(foo)
    ifdef bar
        foobar = yes
    else
        foobar = no
    endif
这个示例最后的数据结果：$(foobar)的值为no，这两个示例唯一的差别是一个赋值时使用了循环递归扩展变量，一个使用了简单扩展变量。  
回过头看看简单扩展变量的特性：在定义时就对变量进行了扩展，所以在第二个例子中，在定义bar时就取出了foo的值赋给了bar，即相当于：bar =  ，所以foobar最后的赋值为no。  

### ifndef
ifndef是与ifdef相对应的条件语句，顾名思义，它的语法与ifdef一致，返回值与ifdef相反。  



## 条件语句的应用场景
条件判断的语法是非常简单的，但是它的应用确实非常广泛，了解这个，我们需要先了解makefile中的变量优先级。  

通常，变量的定义是三种方式：  
* makefile内变量定义
* makefile环境变量
* 命令行执行make时参数传递

### makefile内变量定义
事实上，在makefile中，变量定义有几种方式：
* 使用"="定义的循环递归扩展变量。  
* 使用":="定义的简单扩展变量。   
* 使用define定义的变量，它的特点是支持定义带换行的变量，扩展方式为简单扩展。  
* 使用override定义的变量，顾名思义，就是覆盖其他变量内容，扩展方式为简单扩展。    

### makefile的环境变量
makefile在执行时存在的默认变量，对应一系列默认值。  

### 命令行执行make时参数传递
在执行make时，make允许用户传递参数值到makefile中。  

### 变量优先级
makefile中支持的变量优先级是这样的：
1. override的优先级最高，使用override定义的变量在整个makefile解析期间始终不会被改变，除非存在另一个override对其进行修改。  
2.  用户传递的命令行参数其次，这个特性被使用的频率是非常高的，用命令行传入参数的方式覆盖makefile中定义的变量或者环境变量，由用户指定当前的参数设置。在makefile中对此变量使用"+="符号追加的值也会被忽略。 
3.  使用"define",":=","="定义的变量。 
4. 优先级最低的，就是环境变量，默认值总是优先级最低的，这个也符合常理。       

### 编译变量的指定
通常，可能出现这样一种情况，我们并不清楚makefile执行时的环境，比如目标计算机的架构、平台以及匹配的编译器，或者仅仅是为了扩展性考虑，我们将不确定的情况以某一个变量来描述，这个变量存在一个默认值。  

当我们在实施具体的编译时，通过命令行再为这个变量指定相应的参数。这是最为常见的做法。  

比如，在linux内核的交叉编译过程中，我们无法确定用户为哪个平台编译内核。  

在编译这件事上，不同的平台之间会有两个方面的不同：架构和编译工具链，linux的内核即提供了这么两个变量：ARCH 和 CROSS_COMPILE，分别对应目标平台的架构和使用的编译工具链，在具体编译时指定参数，就可以编译出当前机器上合适的目标文件。  

当然，如果你希望你的makefile中某些参数不能被修改,或者在顶层(主要的)makeflie中确定某个变量有赋值的最高优先级，那么你可以使用override关键词来定义变量。  

## 编译的目标指定
前面的章节有提到，make将makefile中第一个目标作为编译的默认目标，当我们执行make命令时，如果后面不接任何目标，就编译生成默认的目标。  

make后可以接一个或多个目标参数以指定需要执行编译的目标，如果是多个目标，make会逐个地按照列出的顺序编译目标。    

在一些简单的makefile中，一般存在两个目标：  
* all:表示编译需要生成的最终目标。  
* clean：一般而言，删除除了源文件以外的其他编译过程中生成的文件

当然我们也可以为他们起其他的名称或者赋予其他的含义，比如目标clean的命令部分是编译生成最终目标，而all是删除所有编译过程文件，只需要修改目标规则中的命令部分就可以做到，但是，我们应该遵守标准。  

这个目标的值将会被赋值给环境变量：MAKECMDGOALS，当直接执行make时，其值为空。  

GNU make为目标定义了一些标准(推荐的命名标准，GNU软件通常遵循，并非makefile的语法强制规定),下面列举出一些常用的：
* all : 编译生成最终目标
* clean ： 删除编译过程中生成的所有目标文件
* mostlyclean ： 清除部分的编译生成目标文件
* distclean ： 指定删除目标文件
* install : 安装，通常是安装到系统目录，安装可执行文件和动态库。通常需要root权限。    
* print ： 打印被修改的源文件
* tar ： 为源文件打包，创建一个tar打包文件
* test ： 自测指令



***  
***  
***  
参考资料：[官方文档](https://www.gnu.org/software/make/manual/make.html)

***  
好了，关于深入解析Makefile系列(5) -- 条件判断以及运行时指定环境的讨论就到此为止啦，如果朋友们对于这个有什么疑问或者发现有文章中有什么错误，欢迎留言

***原创博客，转载请注明出处！***

祝各位早日实现项目丛中过，bug不沾身.



# 深入解析Makefile系列(1) -- 进一步认识makefile
## 前情回顾
在上一篇文章中，我们以一个非常简单的makefile示例，介绍了一个makefile的执行过程以及核心原理，并留下了一道题：

    定义一个不带依赖文件列表的目标，目标的命令部分生成该目标，假设目标为名为test，它的形式是这样的：
    ...
        test:
            touch test
    ...
    调用make test 
    会发生什么？重复调用又会发生什么？为什么？
    如果将test显式定义为伪目标结果会不会一样？

如果理解了上一章节所介绍的内容，这道题是非常简单的。我们来简单分析一下：
* 当第一次调用**make test**时，make工具将会检查依赖文件列表，没有发现文件依赖列表意味着没有依赖文件的更新，接着检查是否存在目标文件，发现没有目标文件，所以该目标需要重新编译生成，所以执行**touch test**来生成目标文件。  
* 当第二次调用make test时，同样检查到没有依赖文件的更新，同时该目标文件已经生成，所以并不会执行命令。带来的问题是，如果我想更新test目标，除非删除test。  
* 如果将test显式定义为伪目标，由于makefile对于伪目标的固定规则，每次重复调用**make test**都将执行命令**touch test**。


## 进一步认识makefile
在上一篇博客我我们讲解了一个简单的makefile的写法，demo肯定是不够的，在这一章我们再来深入了解makefile的特性。

## 生成中间文件，分布式编译
在上一章中，由于整个工程非常简单，我们将所有文件都放在一条指令中进行编译，随着编译文件的增加，我们会发现这样做明显是不对的。  

根据上一章节的编译规则中可以了解到，make在编译前会检查文件的更新，如果某个目标的依赖文件列表中有文件更新，那么重新编译这个目标，所以，如果一个目标依赖很多文件，其中只要有一个文件有修改，那么所有的这些依赖文件都要重新编译，这样是不符合用户的初衷的。  

那么，这种问题该怎么解决呢？我们看下面的例子：
    1 main:foo.o bar.o main.c common.h
    2     cc foo.o bar.o main.c common.h -o main
    3 foo.o:foo.c foo.h common.h
    4     cc -c foo.c foo.h common.h  
    5 bar.o:bar.c bar.h common.h
    6     cc -c  bar.c bar.h common.h
    7 clean:
    8     rm -rf *.o  main
上述示例中一共涉及到6个文件的编译：foo.c,foo.h,bar.c,bar.h,common.h,main.c  

根据惯例：  
foo.c依赖foo.h,common.h
bar.c依赖foo.h,common.h
main.c依赖common.h

这里的做法是先将foo.c编译成foo.o目标文件，然后将bar.c编译成bar.o目标文件，最后由foo.o,bar.o,main.c编译生成main.c，采用这种分离式的编译由什么好处呢？  
假设我们修改了main.c文件，foo.o文件和bar.o文件不用重新编译生成，因为满足两个条件：目标文件存在且依赖文件没有更新。  

我们仅仅需要做的就是重新编译main.c,然后链接foo.o和bar.o,以达到节省编译时间的目的。  


按照上一节的写法，是这样的：

    main:foo.c foo.h bar.c bar.h main.c common.h
        cc foo.c bar.c main.c -o main
无论修改哪一个文件，foo.c，bar.c，main.c三个文件都要重新编译一遍。  


## 自动推导规则
makefile中，带有一些隐式规则，make的自动推导依赖文件就是其中一种。  

可以明确的是，make工具是服务于程序编译的，程序的编写自然会有一些标准可循。  

比如，在C/C++程序的编写中，我们通常将函数的实现与声明分开放，使用同名不同后缀的文件分别表示实现文件与声明文件,在C中，通常是xxx.c与xxx.h这种对应的关系。  

在makefile的规则中则利用了这种特性，由此，我们可以改写上面的示例：

    1 main:foo.o bar.o common.h
    2     cc foo.o bar.o main.c -o main
    3 foo.o:common.h foo.h
    4 bar.o:common.h bar.h
    5 clean:
    6     rm -rf *.o  main

这个makefile最终的结果与上面的makefile一致，可以发现，在编译foo.o和bar.o时，我们并不需要添加编译目标的命令，因为make会对目标进行隐式推导：make为foo.o自动寻找foo.c文件，并将foo.c编译成foo.o，这一隐式规则对于用户来说是非常方便的，只要遵循了相应的命名规则。  

需要注意的是，隐式规则可以通过给出的.o文件而自动地去寻找并编译对应的同名.c文件并编译，所以在写依赖文件列表的时候可以省略相应的.c文件，但是不允许省略对应的.h文件，否则将使得.h文件的更新不会导致重新编译而出错。  


## 变量的使用
在makefile中，同时支持变量的使用，变量的使用大大减少了列举文件的工作量。  

添加变量的使用，于是上面的示例变成了这样：

    1 TARGET = main
    2 OBJ = foo.o bar.o
    3 
    4 ${TARGET}:${OBJ} common.h
    5     cc ${OBJ} main.c -o $@
    6 foo.o:common.h
    7 bar.o:common.h bar.h
    8 5 clean:
    9     rm -rf ${OBJ} ${TARGET}

在上述示例中可以看到，变量可以是单个目标也可以是多个空格隔开的目标列表，变量的值同时也可以是其他变量。

在第二行中，定义一个OBJ变量，当我们在第四行中引用它时，需要在变量前使用"$",变量则用()或者{}包含，虽然在某些时候变量引用可以不用添加{},但是我们应该遵循规范。  

第五行中的$@是makefile中的内置变量，它的值是目标文件，所以，展开变量后的第五行实际上是这样的：

    cc foo.o bar.o main.c -o main

### 变量的赋值方式
在上文中我们简单介绍了变量的使用，最为makefile中基础且非常重要的部分，我们再来深入地了解一下变量的使用方式。  

makefile中总体的变量名赋值的规则是这样的：
* 以变量名开头，后面接赋值操作符
* 变量名后的空格以及复制操作符后的空格将被忽略
* 变量名没有长度限制
* 没有被赋值的变量视为空字符串，但是在makefile中有一些内置变量是自带初始值或者在某个处理阶段被自动赋值。


makefile中变量的赋值方式有几种，分别为：**=** ， **?=** ，**:=** , **::=** , **+=** , **!=**  





### 变量的分配空间
### 嵌套的变量



与C语言不同的是，变量不需要声明，变量默认都是字符串类型，不论是否使用引号赋值，都以字符串的方式存储。











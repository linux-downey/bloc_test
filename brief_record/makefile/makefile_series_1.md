# 深入解析Makefile系列(1) -- 自动推导与变量
## 前情回顾
在上一篇文章中，我们以一个非常简单的makefile示例，介绍了一个makefile的执行过程以及核心原理，并留下了一道题：

    定义一个不带依赖文件列表的目标，目标的命令部分生成该目标，假设目标为名为test，它的形式是这样的：
    ...
        test:
            touch test
    ...
    调用make test 
    会发生什么？重复调用又会发生什么？为什么？
    如果将test显式定义为伪目标结果会不会一样？

如果理解了上一章节所介绍的内容，这道题是非常简单的。我们来简单分析一下：
* 当第一次调用**make test**时，make工具将会检查依赖文件列表，没有发现文件依赖列表意味着没有依赖文件的更新，接着检查是否存在目标文件，发现没有目标文件，所以该目标需要重新编译生成，所以执行**touch test**来生成目标文件。  
* 当第二次调用make test时，同样检查到没有依赖文件的更新，同时该目标文件已经生成，所以并不会执行命令。带来的问题是，如果我想更新test目标，除非删除test。  
* 如果将test显式定义为伪目标，由于makefile对于伪目标的固定规则，每次重复调用**make test**都将执行命令**touch test**。


## 进一步认识makefile
在上一篇博客我我们讲解了一个简单的makefile的写法，demo肯定是不够的，在这一章我们再来深入了解makefile的特性。

## 生成中间文件，分布式编译
在上一章中，由于整个工程非常简单，我们将所有文件都放在一条指令中进行编译，随着编译文件的增加，我们会发现这样做明显是不对的。  

根据上一章节的编译规则中可以了解到，make在编译前会检查文件的更新，如果某个目标的依赖文件列表中有文件更新，那么重新编译这个目标，所以，如果一个目标依赖很多文件，其中只要有一个文件有修改，那么所有的这些依赖文件都要重新编译，这样是不符合用户的初衷的。  

那么，这种问题该怎么解决呢？我们看下面的例子：
    1 main:foo.o bar.o main.c common.h
    2     cc foo.o bar.o main.c common.h -o main
    3 foo.o:foo.c foo.h common.h
    4     cc -c foo.c foo.h common.h  
    5 bar.o:bar.c bar.h common.h
    6     cc -c  bar.c bar.h common.h
    7 clean:
    8     rm -rf *.o  main
上述示例中一共涉及到6个文件的编译：foo.c,foo.h,bar.c,bar.h,common.h,main.c  

根据惯例：  
foo.c依赖foo.h,common.h
bar.c依赖foo.h,common.h
main.c依赖common.h

这里的做法是先将foo.c编译成foo.o目标文件，然后将bar.c编译成bar.o目标文件，最后由foo.o,bar.o,main.c编译生成main.c，采用这种分离式的编译由什么好处呢？  
假设我们修改了main.c文件，foo.o文件和bar.o文件不用重新编译生成，因为满足两个条件：目标文件存在且依赖文件没有更新。  

我们仅仅需要做的就是重新编译main.c,然后链接foo.o和bar.o,以达到节省编译时间的目的。  


按照上一节的写法，是这样的：

    main:foo.c foo.h bar.c bar.h main.c common.h
        cc foo.c bar.c main.c -o main
无论修改哪一个文件，foo.c，bar.c，main.c三个文件都要重新编译一遍。  


## 自动推导规则
makefile中，带有一些隐式规则，make的自动推导依赖文件就是其中一种。  

可以明确的是，make工具是服务于程序编译的，程序的编写自然会有一些标准可循。  

比如，在C/C++程序的编写中，我们通常将函数的实现与声明分开放，使用同名不同后缀的文件分别表示实现文件与声明文件,在C中，通常是xxx.c与xxx.h这种对应的关系。  

在makefile的规则中则利用了这种特性，由此，我们可以改写上面的示例：

    1 main:foo.o bar.o common.h
    2     cc foo.o bar.o main.c -o main
    3 foo.o:common.h foo.h
    4 bar.o:common.h bar.h
    5 clean:
    6     rm -rf *.o  main

这个makefile最终的结果与上面的makefile一致，可以发现，在编译foo.o和bar.o时，我们并不需要添加编译目标的命令，因为make会对目标进行隐式推导：make为foo.o自动寻找foo.c文件，并将foo.c编译成foo.o，这一隐式规则对于用户来说是非常方便的，只要遵循了相应的命名规则。  

需要注意的是，隐式规则可以通过给出的.o文件而自动地去寻找并编译对应的同名.c文件并编译，所以在写依赖文件列表的时候可以省略相应的.c文件，但是不允许省略对应的.h文件，否则将使得.h文件的更新不会导致重新编译而出错。  

## makefile支持的自动推导语言
本示例中仅仅以C源代码为例讲解makefile的自动推导规则，事实上，makefile的语法支持很多中语言：
**C++ :** 从 **.cc** 或者 **.cpp** 文件推导 **.o**
**Pascal :** 从 **.p** 文件推导 **.o**
**Fortran  :** 从 **.r**或者 **.f** 文件推导 **.o**
...
读者有兴趣可以查看[官方文档](https://www.gnu.org/software/make/manual/make.html#Flavors)。

## 变量的使用
在makefile中，同时支持变量的使用，变量的使用大大减少了列举文件的工作量。  

添加变量的使用，于是上面的示例变成了这样：

    1 TARGET = main
    2 OBJ = foo.o bar.o
    3 
    4 ${TARGET}:${OBJ} common.h
    5     cc ${OBJ} main.c -o $@
    6 foo.o:common.h
    7 bar.o:common.h bar.h
    8 5 clean:
    9     rm -rf ${OBJ} ${TARGET}

在上述示例中可以看到，变量可以是单个目标也可以是多个空格隔开的目标列表，变量的值同时也可以是其他变量。

在第二行中，定义一个OBJ变量，当我们在第四行中引用它时，需要在变量前使用"$",变量则用()或者{}包含，虽然在某些时候变量引用可以不用添加{},但是我们应该遵循规范。  

第五行中的$@是makefile中的内置变量，它的值是目标文件，所以，展开变量后的第五行实际上是这样的：

    cc foo.o bar.o main.c -o main

### 变量的赋值方式
在上文中我们简单介绍了变量的使用，最为makefile中基础且非常重要的部分，我们再来深入地了解一下变量的使用方式。  

makefile中总体的变量名赋值的规则是这样的：
* 以变量名开头，后面接赋值操作符
* 变量名后的空格以及复制操作符后的空格将被忽略
* 变量名没有长度限制
* 没有被赋值的变量视为空字符串，但是在makefile中有一些内置变量是自带初始值或者在某个处理阶段被自动赋值。


makefile中变量的赋值方式有几种，分别为：**=** ， **?=** ，**:=** , **::=** , **+=** , **!=**  
他们分别的赋值方式是这样的：  
**=** : 普通的赋值符，将右值赋给左值
**?=** ：如果没有初始化该变量，就给它赋上默认值，属于条件赋值符
**:=** : 直接赋值，不过在变量展开上与 **=**不同(见下文).
**::=** : 这种赋值符等效于 **:=**
**+=** : 追加赋值符，在原变量的值上追加赋值
**!=** : 这个赋值符比较特殊，右值为一条shell命令，shell命令的返回值赋给赋值符左边的变量.

### != 详解
鉴于!=赋值符的特殊性，这里添加一个示例来详细讲解这个赋值符：  

    var != echo "hello"
此时，${var}展开的值就是hello，这种赋值方式等价于另一种常用的方式：

    var := ${shell echo "hello"}
其中，shell是makefile中的一个函数，表示以后面接的参数为命令并在shell中执行该命令。   

但是需要特别注意的是，如果被执行的shell脚本的返回值中有$字符，我们再去引用这个装有返回值的变量时会出错：

    var != echo "$123"
在我们的预期中，${var}的值应该是"$123", 但是在实际使用${var}引用变量var时，它被解析成了"$1"+"23",由于$1为空，所以${var}的值为"23".   
不论是使用shell函数的方式还是使用 **!=**的方式都存在这个问题，这时我们需要将变量中的$符号进行转义.   
如果这个变量是在makefile中使用，则遵循makefile中的转义语法，如果在命令部分使用，即传递给shell，就遵循shell中的转义语法。

### 变量的扩展方式
变量在使用$符号对其进行引用时，叫做变量的扩展，变量在扩展完成之后才真正确定了变量的值，值得注意的是，变量在赋值的时候并不直接确定变量的值，变量的扩展有两种：**循环递归扩展**和**简单扩展**。

#### 循环递归扩展  
在变量被赋值时并不直接确定了当前变量的值，如果这个变量引用了其他变量，make会先确定被引用变量的值之后再确定该变量的值。一例胜千言：我们来看一个例子理解一下：

    1 var1 = ${var2}
    2 var2 = "hello"
    3 
    4 main:
    5     @echo ${var1}
输出结果：

    hello
在这个简单的示例中，**var1**赋值为**var2**，但是在**var1**赋值时，var2并没有被初始化，按照一般的脚本语言特性，这时候**var1**的值应该为空。  

但是在makefile中，在**var2**被赋值之后，再回过头将**var2**的值赋值给**var1**，相当于是循环递归地进行赋值，而非简单地使用当前值进行扩展。

***对于赋值描述符而言，= 和 ?= 都属于循环递归扩展的变量类型。***


#### 简单扩展变量
makefile另一种扩展方式是简单扩展，与循环递归扩展不一样的是，这种方式就是在赋值的时候就确定了变量的值，不管它是否引用了其他变量，我们来看下面一个例子：

    1 var1 := ${var2}
    2 var2 := "hello"
    3 
    4 main:
    5     @echo ${var1}

输出结果：

    （空）

***对于赋值描述符而言，:= 、::= 、 != 都属于循环递归扩展的变量类型。***

#### 特殊的 += 
有意思的是，**+=** 这个赋值操作符并不是简单地属于循环递归扩展变量和简单扩展变量中的任何一种，它属于墙头草系列。  

如果变量被提前设置为简单赋值变量，则 **+=**操作的就是简单赋值变量，否则就是循环扩展赋值变量(包括新定义变量).  

我们依旧通过一个示例来说明：

    1 var1 += ${var2}
    2 var2 := "hello"
    3 
    4 var3 := "world"
    5 var3 += ${var4}
    6 var4 = "!!!"
    7 
    8 main:
    9     @echo "var1 :" ${var1}
    10    @echo "var3 :" ${var3}


输出结果：

    var1 : hello
    var3 : world

可以看到，在示例的第1、2行直接使用 **+=**定义了一个新的变量，明显地，make的解析规则对**var1**的值进行了递归地扩展。  
在第4、5、6行，**+=**作用于一个已经被初始化为简单扩展变量上，所以并不会进行递归扩展，还是保持原来的值"world"。  

其实不难理解，**+=**赋值符除了初始化赋值，它还有一个作用就是追加，既然是追加，那肯定是客随主便，原来是什么类型就按照什么类型的方式来操作。  





***  
***  
***  
参考资料：[官方文档](https://www.gnu.org/software/make/manual/make.html)

***  
好了，关于深入解析Makefile系列(0) -- 初识Makefile的讨论就到此为止啦，如果朋友们对于这个有什么疑问或者发现有文章中有什么错误，欢迎留言

***原创博客，转载请注明出处！***

祝各位早日实现项目丛中过，bug不沾身.







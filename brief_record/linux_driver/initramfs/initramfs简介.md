# initramfs 实现
在大部分分析 linux 系统启动的资料中，往往都是着重描写 U-boot 和内核的启动，毕竟这两部分是重点也是难点，在启动的最后一部分，通常的描述是：在内核启动的最后阶段，挂载上根文件系统，并启动用户空间的第一个进程 init，正式进入到用户空间的启动阶段。  

实际上，从内核到用户空间的启动通常并没有这么简单和直接，这里面涉及到几个问题：
1、在 FHS 的根文件系统规定中，/usr 目录是可以单独挂载到其它介质中，但是，通常 /usr 目录中包含启动文件，内核默认只是挂载根文件系统，此时无法正常启动系统。  
2、如果根文件系统被加密，除非为这种行为定制内核解密程序，否则 Linux 内核将无法找到 init 程序，导致系统无法启动。  
3、linux 支持的启动介质越来越多，比如 U 盘，SCSI 硬盘甚至网络根文件系统，如果需要兼容各种启动方式，linux 就需要将各种硬件驱动编译进内核中，包括各种存储介质的硬件驱动以及各种文件系统驱动，这种全部编译进内核的方式无疑会让内核变得臃肿。 
4、如果因为意外断电或者其它问题导致根文件系统出了问题，系统将直接无法启动，或者运行过程中出错，当然，在内核中对根文件系统进行检查和修复理论上是可以的，但是实现起来并不现实。  
5、对于某些厂商,如果不愿意开源某些硬件驱动,只想以 ko 的形式提供驱动,比如比较复杂的 nand 驱动程序,这种情况下就不方面直接集成到内核中.  

再次引用计算机界的那一句名言："计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决",上述问题的解决方案是使用 initrd 程序来解决，initrd 就是这样的一个中间层，它是一个基于内存的磁盘结构(ramdisk)，内核在初始化完成之后并不是直接挂载根文件系统，而是先挂载 initrd，可以把 initrd 看成一个真正的磁盘设备，该设备上包含各种工具和脚本，而 initrd 的优势在于：作为一个中间层，它就是一个微缩版的 rootfs，可以直接执行用户空间的程序，比如结合 udev 检查系统上的各类硬件设备，再加上内核传递的命令行信息，可以针对性地加载硬件驱动程序，mount 对应的文件系统，或者对真实的根文件系统进行检查和修复，在所有的一切就准备妥当之后，再挂载真正的根文件系统，开启用户空间的启动工作。

当然，早期的 initrd 并不是完全具备上述的所有功能，一方面，initrd 随着软硬件的发展不断地更新迭代，通常是针对性地做一些适配。另一方面，也并不是所有的系统都需要 initrd 这么一个中间层，在上面列出的四个问题中，有些是可以通过定制化内核来解决，而有些问题对于某些应用场景并不存在，比如在嵌入式领域中，内核在不同平台上的移植性并不是那么重要，通常每一类平台都是定制化的内核，而且启动介质也比较单一，所以某些嵌入式平台也就不需要使用 initrd。 

## initramfs
在 2.6 内核之后,initrd 逐渐被 initramfs 代替了,这是因为传统的 initrd 尽管基于 ram,实际上它被实现为一个磁盘设备,格式化为 ext2 文件系统,因此,内核在挂载 initrd 时需要准备好对应的驱动程序,同时,作为一个完整的块设备,他需要整个文件系统的开销，消耗 Linux 内核中的缓存内存和易于使用的文件（如分页），这使得 initrd 有更大的内存消耗。  

对于 initramfs 而言,这个问题

而最重要的是，由于 initrd 是一个基于 ram 的 disk，在挂在了根文件系统之后， 


mv initrd.img-4.14.108-ti-r124 initrd.img.tar.gz
tar -xvf initrd.img.tar.gz
file initrd.img.tar.gz
gzip -d initrd.img.tar.gz

cpio -i < initrd.img.tar

就获取到 initramfs 的解压缩包。


find . | cpio -H newc -ov --owner root:root > ../initramfs.cpio
gzip initramfs.cpio



为什么存在 initramfs:
1,不能把所有的驱动编译进内核
2,文件系统检查,万一文件系统所处的物理磁盘有问题呢
3,boot 被加密怎么办
4,/usr 目录处于不同的存储介质上怎么办





# 阅读linux源码入门指南 -- 针对嵌入式驱动工程师

自1991年linux的诞生，经过世界各地的热心软件工程师的无私奉献，它的版本从当初的1.0到现在的5.x,源代码从最初发布的几个C语言源文件到现在的几百M，30年的时间见证了一个伟大操作系统的诞生。   

作为一个工作于linux的嵌入式软件工程师，阅读linux源代码是必不可少的。但是，随着linux的迅猛发展以至于逐渐庞大，软件上的复杂度也不断提高，甚至于怎样去阅读源代码都成了困扰新手的一个难题。这一章，我们就来讨论这个问题：怎么阅读linux源代码？以及在深入源代码时会有哪些坑?

****

## 困难在哪里
对于一般的源代码而言，一般从 main 函数开始，如果涉及到多线程多进程部分，也会在创建的时候指定相应的函数入口，唯一需要注意的就是中断处理子程序部分，它由系统调用，不跟随主函数的调用流，我们需要做的就是从main()开始，根据函数调用流梳理源代码逻辑即可，只需要关心逻辑，非常简单。  

在linux内核源码时，事情好像并没有这么简单，众所周知，linux的跨平台性能是非常优秀的，因此，在跨平台方面的处理也是非常完善的，而阅读源代码的主要难点也来自于这里，主要是涉及到几个方面：
1、函数的起点、代码跟踪
2、大量的宏定义，导致在阅读时无法判断代码分支
3、同名文件，同名函数，分不清哪个被使用，哪个没有被使用
4、设备树部分：分散的设备树定义文件，无法确定设备树源文件


接下来，我们逐个讨论这些情况。

*****

## 开始阅读源代码之前
在深入源代码之前，需要一些做必不可少的准备工作。


### 如何下载源代码
如果要阅读源代码，那么下载源代码当然是首要的第一步，官方主线内核可以从这里下载：https://github.com/torvalds/linux。  

同时，根据我们的需求，可以选择不同的分支和tag，如果你要选择不同的版本，在tag列表中找就可以了，你可以将 git 中的 tag 看成是某次提交的标签。  

**实际获取源码的过程中，你很可能碰到两个问题：**   

####  使用厂商提供的内核源码
在开发的时候，很少有完全使用主线代码的情况，如果你基于某个厂商的开发板进行开发，那么对应的厂商将会在主线代码的基础上对内核进行修改，毕竟，硬件的不同肯定会导致内核配置的不同。  

比如：外设端口、时钟等资源的配置，这一部分在主线内核中大多有提供接口，但是配置还得需要自己来。

所以，通常，在主线内核的基础上，我们还需要在对应的版本上打上厂商提供的patch，或者直接使用厂商提供的内核源码，一般是后一种形式。  

#### 源码过于庞大
内核源码发展到现在，大概是几百M的大小，但是当你使用 git clone 想把内核源码下载下来的时候，却发现大小变成了几个G，这其实是 git 的特性，事实上，当你使用 git clone 下载内核源码时，默认将整个 linux 内核源码所有历史版本都下载下来，网络条件不好的时候这可能是一场灾难。  

这个时候，你可以使用 git 的 --depth 的参数，当指定 --depth=1 时，就选定了只下载当前版本的源码，也就是当前内核版本的大小，当然，别忘了指定下载的内核源码版本，使用 -b 参数来指定分支或者tag，如果不指定，git 默认下载最新版本的内核源码。  

例如，如果需要下载 5.0 版本的内核源码，我们可以键入如下指令：  

```
git clone --depth=1 https://github.com/torvalds/linux -b v5.0
```
****

### 如何编译源代码
不论是linux驱动还是linux应用工程师，编译内核源码也算得上是每个工程师上手 linux 的必经之路，虽然这一章讲解如何阅读源代码，同时也需要修改内核源码，所以，linux内核的配置和编译也是必须掌握的。  

内核以及模块的编译可以参考我的其他博客[linux kbuild编译系统](http://www.downeyboy.com/2019/06/10/Kbuild_series_sumary/)，如果你暂时对于linux不太熟悉，看前三篇就可以了。  

****

### 趁手的工具
在荀子的《劝学》中有说到："君子善假于物也"，在开发中也是一样，一件趁手的工具能大大提高工作效率，阅读源码，我们也需要一个比较好的编辑器。  

就目前而言，比较通用的编辑器有 source insight 和 vscode(身边较为常见)，这两个是公认的比较不错的编辑器，他们之间各有各的特点：  

source insight 比较傻瓜化，简单易用，作为一款成功的商用软件，体验还是很不错的。  

对应的，vscode则是由微软发起的开源软件，非常轻量的一款软件，开源是它的最大特点，支持很多灵活的特性，支持自己安装插件，具有非常大的 hack 空间，软件更新快，但是，同时也意味着会有一些bug，以及比较高的学习成本。  

我个人使用 vscode，毕竟使用linux平台的人都有那么一些开源情怀，同时，vscode的发展也是非常迅猛，确实是越来越好用了。  

### 开始源码的阅读

做好了相应的准备工作之后，我们再来谈谈如何阅读内核代码。

*****

## 函数的起点以及代码追踪
当系统上电之后，并不会立即运行内核代码，内核的运行需要一些硬件的相关支持，比如时钟的启动、C语言环境的建立、外设的配置等等。所以，系统先会执行uboot，然后由uboot设置好的运行环境，再加载内核。  

内核最开始的部分是由汇编代码编写的，这一部分的启动代码在arch/${ARCH}/目录下，根据平台的不同而有所不同，主要的作用就是检查硬件、处理uboot传递过来的信息、页表初始化等等，对于某些压缩的镜像格式，还需要对其进行自解压。  

而真正的C语言开始的部分为 start_kernel(),可以把它看成是main()函数，作为一个起点。

### 怎么追踪源代码

事实上，事情并没有这么简单：  

通常情况下，我们阅读源代码，并不会从 start_kernel() 开始，逐个地去分析函数调用，这是完全不可能的，因为linux内核源码非常多且精，这样笼统地读代码一定是以失败告终，只是不同的人坚持不同的时间长短罢了。  

实际的开发中，往往是根据以下的情况去熟悉内核框架：  

### 调试信息
当系统log或者启动日志中有报错或者警告信息时，我们将具体信息复制下来然后到内核源码中搜索关键字，通过这种方式来找到出错的函数，然后再由出错的部分往上或者往下查看函数调用流程。   

具体的操作就是通过全局搜索函数名或者函数定义来找到相应的调用流程或者定义。  

### 驱动框架特性
linux内核驱动框架比较复杂，但总归是有迹可循的，如果我们要查看对应硬件外设驱动的代码，一方面，硬件外设的设备信息被注册到设备树中，而真正的驱动部分被编译进内核中，在一定条件下这两者发生匹配，相应的驱动代码被调用。   

而匹配的条件就是设备树中的 .compatible 属性，如果该驱动被系统使用，驱动代码中也一定存在同名的  .compatible 属性，所以我们只要在源码中全局所有  .compatible 属性，就可以找到对应外设的驱动代码。这种方式对于所有硬件驱动部分都是通用的。在驱动代码的阅读中也是最常见的。    

### 追踪代码可能出现的问题
使用全局搜索定义和上述代码跟踪的方式可以找到大部分的源代码定义，但是它也会有一些问题：  

#### linux特殊的 init 机制
在驱动相关的源代码阅读时，会发现一个问题，驱动相关的初始化函数(通常用__init标识)并不能找到其调用的源头，也就是无法从 start_kernel() 开始找到它的调用。  

事实上，由于 linux 内核模块特殊的动态加载机制，很多初始化代码并非在内核中被调用，而是借助于内核编译时将这些初始化函数统一放在某个段中(镜像中的符号以段为单位，可以理解成是一个特定的地址区间)，在内核启动的时候依次地将这些函数从特定段中取出来，然后调用。  

所以，如果全局搜索某些init函数被调用的信息，是搜索不到的。

关于linux的init机制，可以参考我的另一篇博客：[linux initcall机制](http://www.downeyboy.com/2019/03/10/linux_initcall_mechnism/)  

#### 以宏的方式定义符号的情况
在另一种情况下，全局搜索也是失效的，鉴于接口的抽象，某些结构体或者函数的定义使用宏的方式实现,比如下面的例子中：

```
CLK_OF_DECLARE(fixed_clk, "fixed-clock", of_fixed_clk_setup);

#define CLK_OF_DECLARE(name, compat, fn) OF_DECLARE_1(clk, name, compat, fn)

#define OF_DECLARE_1(table, name, compat, fn) \
		_OF_DECLARE(table, name, compat, fn, of_init_fn_1)

#define _OF_DECLARE(table, name, compat, fn, fn_type)			\
	static const struct of_device_id __of_table_##name		\
		__attribute__((unused))					\
		 = { .compatible = compat,				\
		     .data = (fn == (fn_type)NULL) ? fn : fn }

```
这里通过使用宏 定义了一个 static const struct of_device_id __of_table_fixed_clk 的结构体，## 在宏中的作用是连字符，可以将左右两边以字符串的形式相连。  

如果是这种情况下的定义的结构体或者函数，直接全局搜索的方式也是不成立的，就需要更加细心地查找了。 

*****


## 如何确定宏的状态
阅读linux源代码的第二个难点就是：内核源码中充斥着大量的宏，控制着代码的分支与逻辑，同时这些宏定义并非显示地定义在内核源码中，导致编辑器也无法分辨这些宏的状态。  

通常情况下，这些宏定义是用户对内核配置的结果，而配置完内核之后将会生成 .config 文件，内核编译完成之后也将根据这些配置生成 .include/generated/autoconf.h 文件，这个文件中包含用户配置的所有宏定义，查看内核源码中的宏是否定义我们可以对比查找这两个文件即可。  

但是内核编译中并非所有的宏都是由内核配置定义的，也可能是编译时指定或者其他配置文件(如Makefile)中指定，这种方式虽然方便，但是可能存在漏网之鱼。    

另一种更加稳妥的方法是使用 #error 宏，#error 是一条预处理指令，后面可以跟一个字符串参数，当程序预处理阶段处理到 #error 指令的时候，编译终止并打印输出 #error 的参数，比如下面的语句用来判断是否是 g++ 编译： 

```
#ifndef __cplusplus
#error Error,Not g++ compiler！ 
#endif
```

由于这条指令在预处理阶段就会被指定，所以相对编译而言执行效率还是可以保证的，我们看下面内核中的例子：
```
#ifdef CONFIG_OF
    part1
#else
    part2
#endif
```

如果我们没办法判断 CONFIG_OF 是否被定义，就可以在 part1 和 part2 加上 #error 语句，这样在编译的时候根据相应的报错来确定程序执行分支。  


## 同名文件的区分
为了平台的兼容性，linux 对硬件保留了大量的接口，对于不同的硬件，厂商只需要面向这些接口以编写不同的硬件操作程序即可，由于linux兼容目前市面上大多数的平台，自然地，在内核的源码中就包含了大量的接口实现函数，每一种不同的实现对应不同的硬件操作，但是，通常这些实现的函数名甚至文件名都是一致的。  

这就导致一个问题，在使用编辑器的函数跳转功能的时候，经常出现多个不同目录下的同名文件或者同名函数，导致我们根本分不清那些是被真正使用的。  

### 通过文件名或文件目录名大致确定

判断的第一个方法就是根据文件(目录)名来确定哪些目录被编译，比如我们使用 arm 架构的开发板，那么对应的平台相关的代码肯定处于 arch/arm/ 目录下，再根据对应的 board 和 CPU 来找到对应名称的文件，比如树莓派，就可以进一步确定平台相关源码处于 arch/arm/mach-bcm/ 目录下的 board_bcm2835.c 而不是 bcm_5301x.c。  

其他目录下的文件判断方式也是大概一致，根据平台、厂商、开发板、CPU型号来判断，这种方式通常是经验所得，同时也具有一定的局限性，我们不一定能找到对应型号的文件，目标文件可能存在于其它目录，也可能其它平台的文件包含当前平台的通用代码，毕竟代码共用是常见的。  

但是它可以让我们快速地判断文件的大概位置，如果没有出现同名文件的冲突，那么也就可以基本确定文件位置，这种方式主要是效率高，但是需要一定经验。  

### 根据配置文件确定源文件
linux 内核编译之前是需要配置的，linux kbuild 系统根据用户的配置来确定哪些文件将被编译进内核，哪些文件被编译成模块，而哪些是不用处理的。  

具体的做法是这样的，在源码的大多数目录下，都存在一个 Kconfig 文件和 Makefile 文件，用户在配置界面中选择的那些条目就是由 Kconfig 文件提供的，Kconfig 文件大致是这样的：

```
config OF_DYNAMIC
    bool "Support for dynamic device trees" if OF_UNITTEST
    help
      On some platforms, the device tree can be manipulated at runtime.
      While this option is selected automatically on such platforms, you
      can enable it manually to improve device tree unit test coverage.
```
在配置界面就会出现 "Support for dynamic device trees" 这一条，如果这一条被配置上，对应的 CONFIG_OF_DYNAMIC 就会写入 .config 文件，相对应的，Makefile 中文件编译就是这样的：  

```
    obj-$(CONFIG_OF_DYNAMIC) += of.c
    ... 
```
总结起来就是：Kconfig 提供配置界面中的条目，然后在 Makefile 中根据配置来决定将文件编译成内核还是模块或者不做处理。  

由此，我们可以根据这个机制来确定文件是否被编译进内核：找到该文件的目录，找到 Makefile 中控制该文件对应的 CONFIG_xxx 变量，然后查找 .config 文件中对应的 CONFIG_xxx 的值即可确定该文件的编译状态，如果 CONFIG_xxx=y 表示编译进内核，如果 =m 表示编译成外部模块。  

对于 linux 的内核编译机制同样可以参考我的另一系列博客[linux kbuild编译系统](http://www.downeyboy.com/2019/06/10/Kbuild_series_sumary/)，如果你暂时对于linux不太熟悉，看前三篇就可以了。  

### 使用 #error 宏
与上文中《确定宏的状态》部分一样，判断文件是否编译进内核也可以使用 #error 宏来判断需要编译的文件，方式是一样的。  


*****


## 设备树部分的源码
除了C部分的源代码，设备树也是 linux 系统的一部分，对于驱动工程师而言，是非常重要的一部分。设备树中包含了所有硬件相关的描述，大到系统必不可少的 CPU、时钟节点，小到gpio外设总线上挂的一颗 led，都直接在设备树中有相应的节点体现。  

得益于 linux 系统的成熟，很多时候硬件的修改仅仅需要修改设备树中相应的节点即可，不需要再费心费力地去修改源代码。  

设备树的源码与 C 的源码不一样，编译和调试方式也是大不相同，所以有必要单独拎出来讲一讲。  

一般情况下，设备树文件的源码集中在 arch/${ARCH}/boot/dts/ 目录中，多个设备树文件参与编译，生成一个唯一的 dtb 文件，用作内核启动。  

要找到一个系统中设备树源文件，最简便的做法就是将系统使用的 dtb 文件进行反编译，使用下面的指令：

```
dtc -i dtb sys.dtb -o src.dts
```

得到的 src.dts 就是描述整个系统的 dts 文件了，我们可以参考这个文件，但是，反编译出来的 dts 文件具有一定的局限性，我们来看下面的例子。  

在 dts 中间中可以包含 C 中的头文件，通常也是这样干的，所以源码中的 dts 的可读性还是不错的，通常是这样的代码：

```
dpll_core_x2_ck: dpll_core_x2_ck {
        ...
       clocks = <&dpll_core_ck>;
    };
....
dpll_core_m5_ck: dpll_core_m5_ck@484 {
        ...
        clocks = <&dpll_core_x2_ck>;
        ...
    };
```
在 dts 源码中可以清晰地看出 clock 部分的层次关系， dpll_core_m5_ck@484 的上级clock节点是 dpll_core_x2_ck(clocks字段指定父节点)，而 dpll_core_x2_ck 的上级 clock 节点是 dpll_core_ck，但是反编译出来的 dts 文件则全部变成了裸数据：

```
dpll_core_x2_ck: dpll_core_x2_ck {
        ...
       clocks = 0x10;
    };
....
dpll_core_m5_ck: dpll_core_m5_ck@484 {
        ...
        clocks = 0x20;
        ...
    };
```
这样使得 dts 不够清晰，而且还需要经过艰难的查找对比才能建立层次关系以及搞清楚配置选项。  

如果仅仅是简单的查看设备树，并不深入细节，可以对其进行反编译，但是在实际开发中，我们还是必须得找到对应的源文件。  

其实找设备树源码的方式和上文提到的《根据配置文件确定源文件》一致，通过 Kconfig 与 Makefile 以及 .config 文件的结合来确定哪些 dts 或 dtsi 文件被编译进内核。  

#### 设备树节点在系统中的体现  

对于设备树的每一个节点，在 linux 的 /proc/device-tree 目录下都有严格的一一对应，我们同样可以通过查看该文件下的节点来确定系统的设备树，这种做法适用于无法获取系统 dtb 文件的情况，因为在某些平台上，dtb 文件是通过自动化脚本管理的，用户甚至开发者看不到操作细节。  

****


### 确定源码的终极方案
当上面的方案都无法直接确定函数调用流时，最后的方案就是修改源码，使用 printk 添加打印调试语句，在所有可能调用的部分不厌其烦地添加相应的调试信息，然后根据调试信息确定函数的调用流程。  

毕竟在内核中，比如中断处理部分、应用程序到内核的系统调用、线程执行、睡眠与唤醒等一些执行流的切换并不存在直接的调用关系，这时候就需要通过调试信息来确定。  

## 小结
在这一章节中，对如何开始阅读 linux 源代码做了一个大致的讲解，如果你也有这方面更好的经验，欢迎交流。  



好了，关于 阅读linux源码入门指南 讨论就到此为止了，如果朋友们对于这个有什么疑问或者发现有文章中有什么错误，欢迎留言

***个人邮箱：linux_downey@sina.com***
***原创博客，转载请注明出处！***

祝各位早日实现项目丛中过，bug不沾身.



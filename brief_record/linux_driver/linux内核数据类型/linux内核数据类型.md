# linux内核数据类型--由移植性引发的问题

## 前言：为什么会有各种数据类型

在日常的 C 语言编程中，部分程序员都习惯使用像 int、long 这样的 C 语言的标准类型，印象中，标准的东西总归是最通用的。但是这个原则在 C 语言的类型使用时并不成立，，使用 int 、long 很可能在不同的平台移植上出现致命的问题。  

大部分工作于底层的工程师都对 "跨平台" 这三个字恨之入骨，不同的总线架构、不同的芯片位数、不同的内存存储方式，就需要针对这些不同而在软件中做大量的处理工作，来提供给上层以统一的接口。  

而我们所有讨论的数据类型的使用，也是因为处理平台兼容的需求而发展出来的。  

****

## 最基本的类型
最基本、最常用的数据类型就那么几种：char、int、long、long long，当然还有对应的无符号版本，以及使用非常频繁的指针。   

就如上一节所说，尽管这些数据是标准类型，但是我们不应该直接使用它们，众所周知，C 语言中的数据类型是严格对应内存分配的，但是在不同的平台上，同一个数据类型并不一定占有相同的内存长度。

对于 int 类型而言：
* 16位系统中，int型为16位大小，两字节
* 32位系统中，int型为32位大小，四字节
* 64位系统中，int型为32位大小，四字节

而对于 long 而言：
* 16位系统中，long型为32位大小，4字节
* 32位系统中，long型为32位大小，4字节
* 64位系统中，long型为64位大小，8字节

除了 int、long 类型之外，还有指针的长度，指针的长度则要复杂一点，那么，指针的长度是怎么定义的呢？  

一个可以接受的答案是：指针的长度由系统的地址总线长度决定。通常情况下，多少位的系统就对应多少位的地址总线长度，比如 32 位系统的地址总线长度为 32 位，指针就是 4 字节，以此类推。  

但是总会有那么一些特例，系统位数和地址总线位数不等，8086 是 16 位单片机，但是有 20 位地址线，就需要使用特殊的地址分段寻址方式。   

那为什么说 "指针的长度由系统的地址总线长度决定" 是一个可以接受的答案而不是标准答案呢？  

这又源于另一些特例，例如 SPARC64 架构的系统，64 位系统，64位地址总线，但是它运行的是 64 位的内核空间，32 位的地址空间，也就是说内核指针是 64 位 8 字节，而在用户空间是 32 位 4 字节。  

不得不说这些无处不在的特殊设计真的令人头大，对软件开发人员(尤其是需要处理跨平台的情况下)造成比较大的困扰。  

关于 int、long、指针类型的详细解析可以参考我的另一篇博客:[不同平台下int类型、指针类型的数据大小](http://www.downeyboy.com/2019/06/28/Width_of_system_bus/)。


### 解决方案
既然在跨平台的时候有这么多问题，那怎么解决呢？  

还是计算机中的老办法：分层，在底层将所有的情况进行处理，提供统一的接口给上层，这样上层软件开发者就不用(尽量少地)考虑跨平台问题。   

对于基础的数据类型，C99 标准中提供了一系列的数据类型以替代传统的标准数据类型：

* uint8_t;
* uint16_t;
* uint32_t;

该标准抛弃了传统的面向类型(int、long)的数据类型，而提供了面向内存的数据内存。  

既然不同平台上数据类型的内存长度不同而导致程序的错误，那么就直接面向内存长度来定义类型，这样在开发者使用这些类型时，就可以直观地确定所用类型的长度，而这些类型的底层实现就交给那些制定标准的人吧。  

它们的定义类似于这样的：

32 位平台：
typedef uint32_t long;

64 位平台
typedef uint32_t int;

(具体的定义并非完全这样，只是为了示范不同平台之间的定义差别)

而在 linux 的内核中，也有相应的类型提供：

* u8;
* u16;
* u32;

但是，这仅仅是内核通用，而并非像上述类型一样作为 C 语言通用标准，仅在 linux 内核中使用，甚至其他的 unix 变种也不兼容，如果考虑到移植，最好是使用 uint8_t 之类的标准类型。  
**** 

### 实际内核源码中的类型使用

有了解过内核源码的朋友可能对我上面的建议(最好使用uint8_t之类的类型)存在疑惑，因为在内核代码中，int、char 这一类数据类型并不少见，也没见出什么问题。  

因为使用传统的数据类型面临的是 "可能出问题"，如果你完全了解了数据类型背后的原理并且有自信保证它不会出问题，那当然是可以使用的。  

比如，用 int 类型定义函数返回值，而函数定义者清楚地知道的返回值范围在 -32767 ~ 32768 之间，也就是 int 对应的最小值范围，那么在任何平台上都不会有问题。  

就像 C 语言中被无数学者唾弃的 goto 语句，它在内核源码中的出场率非常高，如果你完全了解它并且知道如何使用它，那你就是自由的。  

但是，实际情况中却有很多自以为了解而带来的问题，在我们没有成为业界公认时，最好还是遵循标准，这会免去很多麻烦。  

**** 

## 大小端的存储

### 大小端简介

鉴于数据的存储和传输都是以字节位单位，多字节的数据类型存储、传输方式就有了不同的实现，由于历史原因，目前分为两种：大端和小端。   

实际上在日常的开发中，需要处理字节大小端的问题并不多，内存中的大小端问题已经由编译器为我们处理完成，以同一格式存和取，自然不会出问题。  

当然如果你非要将一个多字节类型拆开处理，那就需要考虑大小端的问题，这种情况可能发生在某些协议解析时，处理大小端更多地发生在协议传输时，这需要发送和接收方的共同协商。  

在内存模型中，大端意味着高字节存储在低地址，例如一个 uint32_t 变量，存储开始地址为 0x1000，0x12345678，内存存储是这样的：

```
0x1000  0x1001 0x1002  0x1003
 0x12    0x34   0x56    0x78

```

而小端则是高地址存储在高字节，

```
0x1000  0x1001 0x1002  0x1003
 0x78    0x56   0x34    0x12
```

相对来说，大端的存储方式从直观上来看更符合人的思考方式.  

而在数据传输过程中，大端表示高字节先发送，而小端表示低字节先发送。  

**本质上，大小端在存储和传输过程中代表的是字节的处理顺序：大端中的大表示高字节(翻译过程中的转义)，所以大端顺序就是高字节先处理，而小端表示低字节先处理，这对于传输来说很好理解。**  

**而对于存储来说，大端表示高字节先处理，先处理的就放在低地址，依次往高地址存放，所以高字节在低地址，而小端是低字节先处理，所以低字节先放在低地址。**

**为什么会有大小端呢？从上图可以看出来：大端的 0x12345678 顺序存放在 0x1000~0x1003，这是符合人的思考方式的，所以在很多人为定义的通信协议中(比如网络字节序)都是以大端字节序来表示。**

**但是计算机中就不一样了，在进行计算的时候，自然是先从低位开始处理，自然的，如果第一个字节取到的就是低位明显可以提高效率，所以，在大部分的 CPU 设计中，都是小端字节序。大端CPU的优势就是在某些大端应用中不用转换字节序，比如网络应用。**

### 关于大小端的类型转换
回到数据类型的话题，通常情况下，是不用关心大小端的问题的。  

但是，不得不考虑的情况是，有时需要处理的程序需要从单字节来建立一个整型数或者相反的操作，又或者是需要和特定字节序的设备进行通信，我们就需要考虑大小端的问题了。  

在内核中，在 include/linux/byteorder/generic.h 中提供了一组接口专门处理大小端的存储：

```
//参数为u32类型，从当前 cpu 字节序转换为小端 32 位并返回
cpu_to_le32 
//参数为u32类型，从小端 32 位转换为当前 cpu 字节序并返回
le32_to_cpu

//参数为指针类型,目标为指针指向的数据，从当前 cpu 字节序转换为小端 32 位
cpu_to_le32p 
//参数为指针类型，目标为指针指向的数据，从小端 32 位转换为当前 cpu 字节序
le32_to_cpup 

//网络字节序的转换
#define ___htonl(x) __cpu_to_be32(x)
#define ___htons(x) __cpu_to_be16(x)

```

上述只是列出了 cpu 字节序与 32 位小端字节序的转换，还有 64 位、大端的的各种接口，可以自己去查一查对应的接口。  

而对于下面两个接口，是标准的网络字节序的转换，网络字节序为大端，所以直接调用了 be 的接口。  

被上述接口所描述的目标值，不管 CPU 默认的字节序是什么，都将以指定的字节序进行存储。

而 CPU 字节序则是不确定的，CPU 有可能是大端，有可能是小端，而不管是大端还是小端，上述接口都是可以正常工作的，如果是同一种字节序，只是空操作而已。  

****



### 实战应用

单纯地讲概念总是空洞的，我们引入一个示例来对上述的接口进行讲解：

```
    uint32_t be_val = cpu_to_be32(0x12345678);
    uint32_t le_val = cpu_to_le32(0x12345678);

    char *be_p = (char*)&be_val;
    printk(KERN_INFO "*be_p = %x\n",*be_p);

    char *le_p = (char*)&le_val;
    printk(KERN_INFO "*le_p = %x\n",*le_p);

    printk(KERN_INFO "be_val = %x\n",be_val);
    printk(KERN_INFO "le_val = %x\n",le_val);
```

输出结果：

```
*be_p = 12
*le_p = 78
be_val = 78563412
le_val = 12345678
```

这是从内核模块代码中截取的主要部分，对应结果我们来讲解整个代码的思路:
* 定义两个变量 be_val 和 le_val,这两个变量的值同为 0x12345678，只是经过了大小端的转换
* 通过一个 char 指针分别访问两个变量内存中的第一个字节，来看看 cpu_to_be32 是否起了作用，被转换后的变量是否真的按照指定的字节序进行了转换并存储

从结果来看，be_val 的第一字节是 0x12，确实为大端存储，而 le_val 也同样是小端存储，转换是成功的。  

但是，当我们想直接使用 be_val 和 be_val 时，be_val 的值居然变成了 0x78563412，也就是说当前 be_val 所占的四字节内存是按照大端来存储的，但是 CPU 是小端模式的，默认情况下自然也是按小端来取数据，所以取出的 be_val 值就变量。  

所以，对应这一类特殊转换的数值，在取的时候也需要使用相应的接口，才能保证代码正确运行，同时，不要假设 CPU 平台的字节序，就好比这里实验的平台为小端，那么你就只对大端转换的数据做处理，如果移植到一个大端平台上，程序就会出问题。  
 
如果想取出的数据保持原来的值，我们可以这样写：

```
printk(KERN_INFO "be_val = %x\n",(be32_to_cpu)be_val);
printk(KERN_INFO "le_val = %x\n",(le32_to_cpu)le_val);
```

最后，再次强调，只有当我们需要处理的程序需要从单字节来建立一个整型数或者相反的操作，又或者是需要和特定字节序的设备进行通信的时候才需要使用到上述的接口来指定数据的大小端，其他情况下编程是不需要的。  

事实上，这些接口在内核中出场率也不低，有兴趣的可以去看看。  

****

## 内核中有关移植性的其他问题
关于处理移植性的类型，核心就是提供一个统一的数据类型来屏蔽传统类型所可能引起的溢出或者是其他错误，在内核中，还有一些其他的、值得一提的可移植性问题，它不属于类型定义，但是也非常容易受到不同平台之间的移植影响。  

****

### 时间间隔
自内核的启动开始，内核中就有一个变量来记录系统时间，就是我们常用 jiffies，或者说它记录着"系统节拍"次数，一个系统节拍是调度的最小单位，每一个系统节拍的中断过程中，系统重新选取应该被执行的进程(当然也可能继续执行上次执行的进程)。  

这是一个全局变量，如果你信奉 "实践出真知" 的原则，在你的电脑上直接间断地打印出这个变量的值，通常会发现它的频率是每一秒增长 100 ，同时如果你就此得出结论，那么很遗憾，这个结论并不正确。  

事实上，在大部分传统机器上，jiffies 的值由 HZ 来决定，HZ 就是系统节拍的间隔(单位为ms)，他们的关系是 jiffies 每秒增长1000/HZ,通常 HZ 的值是 10(ms)，但是这并不是固定的。  

在某些系统中，它被定义为1(ms)，以拥有更好的调度实时性，但是频繁地调度进程，会导致调度器本身的执行时间对系统时间的占比增大，CPU的有效执行率降低。  

而对于一些对实时性要求不高的情况下，HZ 的值可能是 20，40.  

所以，在实际的编码中，不要假设 jiffies 是任何一个固定的值，而应该老老实实地使用 HZ 进行换算。  

****

### 页的大小
目前市面上看到的很多教材，对 linux 分页系统中页大小的描述通常是 4KB，PC 程序员更是经常犯这种错。   

页的大小应该是由宏 PAGE_SIZE 来进行描述，而不是 4KB，事实上，随着 CPU 的发展，目前有大量的平台开始支持不同的页大小，64 位架构的系统更甚，通常可以设置为 4KB~64KB，特殊情况下甚至可以设置 huge page 为1G(当然，huge page本身是一种特例)，甚至在同一个平台中可以同时设置几种不同的页大小。  




参考:https://www.ruanyifeng.com/blog/2016/11/byte-order.html
    :《linux设备驱动程序》

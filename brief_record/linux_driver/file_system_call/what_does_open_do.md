# open 做了什么
接触 Linux 的朋友几乎都知道它的设计哲学：一切皆文件。

所以，无论是对应用还是驱动开发者来说，一直在和文件打交道，对于文件的的常用操作接口也是信手拈来。  

不过，博主在这里想问一个比较扫兴的问题：你真的知道文件接口做了什么吗？  

当然，有些朋友会很快地回答：open() 打开或者创建文件，read/write 对文件进行读写，如果这是一个应用程序开发者的回答，还尚可接受，但是如果你是一个驱动工程师，是不应该仅限于知道这些的。  

因为，对内部实现原理的探究才是底层工程师该做的事。


## 从用户空间到内核
在经典 32 位操作系统中，Linux 虚拟内存的 0~3G 为用户空间，3~4G 的内存空间为内核空间，用户空间只负责运行用户程序，而内核空间掌控所有的硬件资源，当用户程序需要使用到硬件资源，比如访问磁盘的时候，就需要向内核提交申请，内核将用户进程需要的资源返回给用户。这是大部分开发者都知道的。   

再往深一点想，用户空间的进程和内核之间到底是怎么运作的？看起来，用户程序在不断地运行、内核接收用户程序的请求运行，还有内核线程和中断系统，整个系统上这么多看起来在同时运行的程序到底是怎么协调工作的。  

其实如果你了解实时操作系统的实现原理，这也并没有什么难理解的。是的，这些程序看起来都是同时在系统上运行，实际上是任务切换的速度够快，即使一个进程是间隔运行也让人感觉不到它的停顿，毕竟这个间隔很可能是 30ms 甚至更短，在系统任务非常多的时候，你会感觉到系统很卡，就是由于任务的增多而让你感受到了这个间隔，这时这个间隔可能是 200ms 。  

用户程序、中断系统、内核线程的"同时执行"可以理解，但是进程和内核是怎么交互的呢？  

当一个进程运行时，一个全局指针 current 将指向当前进程的进程控制块，也就是 struct task_struct 结构，该结构中包含了一个进程的所有私有数据。 而用户进程到内核是通过系统调用接口进入的，内核对于用户进程而言，其实是一种"代替执行"的模式，所以，尽管在内核空间内，同样可以访问当前进程的所有进程数据，也就是通过 current 指针访问当前进程进程控制块。而此时，用户进程是处于睡眠状态的，直到内核处理返回。    




## open 函数






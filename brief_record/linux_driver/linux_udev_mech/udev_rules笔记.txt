udev 可以实现的内容:
* 重新为设备节点命名
* 通过创建链接的方式针对同一个设备提供一个持久化的命名
* 根据程序输出命令设备节点
* 设置设备节点的权限
* 当设备修改的时候,执行指定的脚本程序
* 为网络接口重新命名

rules 文件被保存在 /etc/udev/rules.d 目录下
/lib/udev/rules.d/
/usr/lib/udev/rules.d/ , /etc 有更高优先级

rules 文件以词法顺序进行解析,


基本规则:
KERNEL-匹配内核名称
subsystem-匹配子系统名称
driver-与支持设备的驱动程序名称匹配

分配系统资源:
* name:创建的设备名称
* symlink:创建的软链接列表

创建的文件都在 /dev 目录下.  

一个比较重要的规则:当设备找到对应的 rule 时,并不会停止该节点的处理,而是继续搜寻匹配所有的 rules 文件,
所以一个变动的设备可以有多次匹配.  


PROGRAM 关键字是执行脚本用于取名
RUN     关键字是执行脚本


https://www.freedesktop.org/software/systemd/man/udev.html
https://wiki.archlinux.org/index.php/Udev


如果手动地发送了 add,系统会自动发送 remove.  



使用 netlink 应用层程序可以监听udev 的所有事件并打印出来. 

udevadm info $PATH       // 可以查看udev数据库的信息
udevadm trigger $PATH    // 可以触发一个 change 类型的 udev 事件,这个事件使用了udev数据库中的信息
事件的字符串格式为:
add@/module/kset_create_delAC
TION=addDEVPATH=/module/kset_create_delSUBSYSTEM=moduleSEQNUM=3676

首先,所有发送过来的数据都是这种类型,有的还会在自定义 uevent 中添加一些字段.  

参考:https://www.freedesktop.org/software/systemd/man/udev.html

KERNEL 对应名称,一般来说,就是 $PATH 的最后一个分量.  
KERNELS:沿路径向上查找. 


SUBSYSTEM 对应 subsystem 字段.
SUBSYSTEMS:沿路径向上查找 

DEVPATH:匹配消息中的 DEVPATH.   

NAME:针对网络设备,匹配消息中的 NAME 字段. 

ENV 表示全局变量,可以直接设置全局变量,也可以直接使用全局变量,这个全局变量不是系统级别的,而是 udev rules 的全局变量. 

GOTO:与 LABEL 相对应,跳转到 LABEL 处.  

ATTR:对应目录下的文件,ATTR{$FILE_NAME} 做判断,但是需要注意权限问题
如果没有权限操作的话,可以通过 ENV 来实现操作.

ATTR{foo}=="foo"  该语句表示判断当前文件夹下是否有 foo 文件,且其值为 foo.  

ATTRS:和 ATTR 差不多,只是当找不到对应的文件的时候,会根据 DEVPATH 向上找,如果父级目录找到对应的属性文件也可以匹配.  


DRIVER:只有在消息中设置了 DRIVER 字段的才可以进行匹配.  
DRIVERS:沿路径向上查找.  

OWNER:
GROUP:
MODE:  设置权限

TAG:

IMPORT:导入外部的item.

IMPORT{TYPE}:
TYPE:
"program":外部程序
"builtin":内部的程序
"file":导入文件,格式必须是全局变量的形式
"cmdline":

OPTIONS:
link_priority=value : 设置 link 的优先级,高优先级可以覆盖低优先级的同名link

watch:追踪该文件,使用 inotify 机制,如果该文件在打开修改关闭之后,会产生一个 change event.  
nowatch

db_persist:将消息一直保存在 udev 数据库中,即使使用 udevadm info --cleanup-db 也不能删除.

static_node:创建静态的设备节点.  









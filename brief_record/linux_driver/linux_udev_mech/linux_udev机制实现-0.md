# Linux udev 机制实现-0

## udev 简介
在早期的 linux 中,对于设备管理的策略是比较简单的,各个硬件设备对应 /dev 目录下的一些静态属性文件,这时候的硬件环境并不复杂,外围硬件通常比较少,更没有热插拔的需求.  

不过,随着这几十年硬件的爆发式增长以及移动设备的兴起,设备管理开始变得复杂起来,一方面是外围设备的增多,设备的复杂度逐渐提高,另一方面,系统需要满足越来越多的"动态需求",也就是一些即插即用的设备,比如:USB 网卡,硬盘等.   

为了应对外部环境的变化,linux 首先推出了 devfs,首次出现在 2.3 内核中,它主要特点是支持设备的热插拔,但是 devfs 不支持持久化的命名、后期维护不积极，同时考虑到设备管理的工作没必要完全放在内核中等因素，在不久之后的 2.6 版本内核中就被新的设备管理策略 udev 所替代,一直沿用至今.  

值得一提的是,udev 是一个用户空间程序,通过 netlink 机制与内核进行交互,监听内核的设备更改并相应地修正应用空间的设备接口.  

udev 分为两个部分,一个是守护进程 udevd,另一部分是客户端程序,主要是 udevadm,提供用户层面的操作接口.在早期 udev 作为独立的服务运行在 Linux 系统中,后来被并入 systemd 管理系统中,这种迁移并不对 udev 的功能造成任何影响.  

## udev 能做什么?
设备管理是一个抽象的概念,设备本身也囊括了非常多的东西,linux 中的设备分为三种:字符设备，块设备和网络设备,对于 Linux 来说,设备在硬件上通过各种总线连接到系统中,然后在软件层面导出操作设备的接口,几乎所有设备都是这种方式运行在 linux 中.

不同设备的区别在于:硬件上,有些设备可能是通过 USB 总线连接到机器,而有些是通过串口或者网口.软件上,某些设备对应单一的操作接口,而某些设备的设备接口更加复杂.  

需要注意的是,udev 是一个用户空间的程序,所以可以想到,硬件相关的操作是和 udev 完全无关的,因为 linux 中只有内核才有操作硬件资源的权限,所以内核负责处理设备连接到系统,包括总线的匹配,连接,底层通信等工作,而 udev 的工作在于:在用户空间创建设备的操作接口,当然,这依赖于内核提供的设备信息.   

下面就是 udev 具体负责的工作:
* 重新为设备节点命名
* 通过创建链接的方式针对同一个设备提供一个持久化的命名
* 根据程序输出为设备节点命名
* 设置设备节点的权限
* 当设备修改的时候,执行指定的脚本程序
* 为网络接口重新命名,网络设备

在 linux 下，一切皆文件，上文中所说的硬件设备对应的软件接口也正是以文件的形式导出，所以 udev 的工作也是和设备文件接口打交道，包括命名、权限等。   


## udev 是如何实现设备管理的？
设备管理中大部分的工作都是围绕设备接口相关，最多的自然是设备的创建，，下面我们就以系统中的实时时钟(RTC)为例，看看一个硬件设备从连接到用户接口的导出是怎么样的一个过程。  

* RTC 是低速设备，通常使用 i2c 接口与 CPU 连接，如果需要将一个 i2c 接口的 RTC 在 linux 中使用，第一步自然是硬件连接，通常是四根线：VCC(电源)、GND(地)、SCK(时钟线)、SDA(信号线)。  
* 第二步是将该设备注册到内核中，在新版的内核中通过设备树来描述该 RTC 设备，设备树节点中包含该 RTC 设备的相关信息，而老版本内核中需要编写相应的设备节点并注册到内核中。  
* 内核在启动并初始化对应的 i2c 总线时，会根据设备树节点中的 "compatible" 属性，匹配到该 RTC 对应的驱动程序，并执行驱动程序中的 probe 函数。  
* 在 probe 函数中，会为该设备节点创建一系列的设备节点，包括 /proc,/sys 等目录下的文件节点，同时还会直接或者间接地调用到 kobj_uevent_env() 函数，这个函数就会通过 netlink 通信机制向用户空间广播设备创建的相关信息，这类通知信息的格式通常为：ACTION=addDEVPATH=/module/kset_create_delSUBSYSTEM=moduleSEQNUM=3676，这些信息中会包含操作类型(add)，文件接口的路径，子系统的名称等以方便用户空间识别目前对应的是哪一个设备。    
* udevd 守护进程通过监听内核对应的 netlink 套接字，读取到内核广播的设备信息。  
* 在读取到内核创建的对应的 RTC 设备信息之后,udevd 守护进程并不会自行分析内核信息中的每个字段，而是将设备信息与一种名为 .rule 为后缀的规则文件进行匹配，这些 rules 文件是系统管理员预定义的专门针对设备信息的解析文件，它会告诉 udevd 接收到内核设备信息时该如何操作。    
* 当存在某个 rules 文件中的规则与内核设备信息相匹配时，就会执行相应的操作，而这个操作也正是规则文件中定义的，比如对于 RTC 而言， /lib/udev/rules.d/50-udev-default.rules 中的下列两行规则就会匹配成功：
    SUBSYSTEM=="rtc", ATTR{hctosys}=="1", SYMLINK+="rtc"
    SUBSYSTEM=="rtc", KERNEL=="rtc0", SYMLINK+="rtc", OPTIONS+="link_priority=-100"
    其中， == 表示匹配的规则，比如 SUBSYSTEM 必须为 rtc 才能匹配到这两条规则，+= 表示要执行的动作，这里表示在 /dev 目录下创建 rtc 软链接，而 /dev/rtc0 文件接口则由内核直接创建。 

这是一个相对简单的示例，展示了一个设备从硬件的连接到内核总线的处理再到用户接口的导出整个过程。  


## rules 规则文件简介
udev 最核心的部分在于 .rules 规则文件，系统的规则文件被保存在 /lib/udev/rules.d/ 目录下，当接收到内核设备信息时，会遍历所有可用的规则文件，这一点需要注意，udevd 在匹配时并不会在第一次找到匹配后停止。  





# Linux udev 机制实现-0

## udev 简介
在早期的 linux 中,对于设备管理的策略是比较简单的,各个硬件设备对应 /dev 目录下的一些静态属性文件,这时候的硬件环境并不复杂,外围硬件通常比较少,更没有热插拔的需求.  

不过,随着这几十年硬件的爆发式增长以及移动设备的兴起,设备管理开始变得复杂起来,一方面是外围设备的增多,设备的复杂度逐渐提高,另一方面,系统需要满足越来越多的"动态需求",也就是一些即插即用的设备,比如:USB 网卡,硬盘等.   

为了应对外部环境的变化,linux 首先推出了 devfs,首次出现在 2.3 内核中,它主要特点是支持设备的热插拔,在不久之后的 2.6 版本内核中就被新的设备管理策略 udev 所替代,一直沿用至今.  

值得一提的是,udev 是一个用户空间程序,通过 netlink 机制与内核进行交互,监听内核的设备更改并相应地修正应用空间的设备接口.  

udev 分为两个部分,一个是守护进程 udevd,另一部分是客户端程序,主要是 udevadm,提供用户层面的操作接口.在早期 udev 作为独立的服务运行在 Linux 系统中,后来被并入 systemd 管理系统中,这种迁移并不对 udev 的功能造成任何影响.  

## udev 能做什么?
设备管理是一个抽象的概念,设备本身也囊括了非常多的东西,linux 中的设备分为三种:字符设备,对于 Linux 来说,设备在硬件上连接到机器上,然后在软件层面导出操作设备的接口,几乎所有设备都是这种方式运行在 linux 中.

不同设备的区别在于:硬件上,有些设备可能是通过 USB 总线连接到机器,而有些是通过串口或者网口.软件上,某些设备对应单一的操作接口,而某些设备的设备接口更加复杂.  

需要注意的是,udev 是一个用户空间的程序,所以可以想到,硬件相关的操作是和 udev 完全无关的,因为 linux 中只有内核才有操作硬件的权限,所以内核负责处理设备连接到系统,包括总线的匹配,连接,底层通信等工作,而 udev 的工作在于:在用户空间创建设备的操作接口,当然,这依赖于内核提供的设备信息.   

下面就是 udev 具体负责的工作:
* 重新为设备节点命名
* 通过创建链接的方式针对同一个设备提供一个持久化的命名
* 根据程序输出命令设备节点
* 设置设备节点的权限
* 当设备修改的时候,执行指定的脚本程序
* 为网络接口重新命名,网络设备


## 为什么

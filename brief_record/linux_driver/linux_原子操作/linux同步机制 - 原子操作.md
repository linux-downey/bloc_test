# linux同步机制 - 原子操作
在 linux 的同步机制中，锁是最常见的用法，当操作共享的全局对象或者内存时，限制该对象同时只能被一个执行流所访问。  

这里所说的共享是相对的，我们常接触到的共享情况就是一个全局对象在多个线程中被操作或者同时在中断中使用。  

在单核的情况下，这种数据的共享相对比较好处理，可以通过关中断来实现共享对象的保护，因为在关中断的情况下，如果不显式地执行进程切换、使能中断下半部操作，当前执行流的执行是不会被打断的，这种方式我更倾向于称它为"针对过程的同步"，即通过让执行过程不被打断而实现的数据保护。 

另一种则是"针对对象保护的同步"，就是不保证执行过程不被打断，但是保证共享对象在一个完整的操作流程中，始终只被一个执行流所操作，比如常用的互斥锁，进程 A 在获取锁之后，其他任何进程都无法再对锁住的对象进行操作。  

## 原子操作
对于原子操作，其实博主并没有找到一个合适的标准定义，在国内的网站以及教程中出现得最多的一种说法是：之所以叫做原子操作，是因为从物理上来说原子是一种不可分割的粒子(实际上现代物理证明并不是)，代表操作的不可分割性，原子操作因此得名，自然地，在程序中也代表着原子操作不会被其它的过程中断，要么不执行，一旦执行就会执行完成。   

定义是一方面，我们还是得关注 linux 中原子操作的具体实现，实际上 linux 中，或者说 arm 中提供的原子操作机制并非是不可打断的，这部分在下文中继续讨论。 

首先要弄清楚的一个问题是：为什么需要原子操作？

其实本质上原子操作和锁实现同样的功能，都是为了保护共享对象，按照标准的原子操作定义来说，原子操作是保护执行过程，而锁是针对数据的保护。

另一个区别在于共享对象的复杂度，通常如果是小于等于字的数据操作，可以使用原子操作，这是硬件提供的机制，对于复合型数据的操作，需要使用锁。 

同时，原子操作是硬件上必须提供的机制，至于为什么你可以思考一个问题：锁是怎么实现的？ 



## linux 中原子操作
在 linux 内核中，提供了一系列原子操作接口，这些接口都是针对简单类型的原子操作或者位操作，值得注意的是，在某些情况下，linux 中实现的原子操作接口并不是不可中断的，也就是说，在执行原子操作的过程中，它可能会被其它执行流打断，比如中断、进程切换,（和标准定义的原子操作有出入，又或者说原子操作并没有规定执行过程不能打断？）。

在本章中，我们就以 armv7-A 架构为例，讨论 linux 中原子操作的实现。 




## atomic* 函数族
在深入理解 linux 原子操作实现之前，至少得弄清楚如何使用 linux 内核中的原子操作。  

首先，原子操作需要使用特定的数据类型：

```c++
typedef struct {
	int counter;
} atomic_t;
```

尽管它的操作对象为简单的数据类型(int)，也不能直接使用 int 进行操作，这也就保证了原子变量和非原子变量之间的区分，同时定义所有原子变量操作函数(以 atomic 开头)只接受原子数据类型，以免用户混用这两种类型变量，可以想到，这种混用造成的 bug 是非常难以察觉的。  




|接口|接口含义|
|---|---|
|atomic_add(int i, atomic_t \*v)|给一个原子变量加上i|
|atomic_add_return(int i, atomic_t \*v)|同上，只是返回操作结果|
|atomic_sub(int i, atomic_t \*v)|给一个原子变量减去i|
|atomic_sub_return(int i, atomic_t \*v)|同上，只不过将变量v的最新值返回|
|atomic_cmpxchg(atomic_t \*ptr, int old, int new)|比较old和原子变量ptr中的值，如果相等，那么就把new值赋给原子变量。返回旧的原子变量ptr中的值|
|atomic_read|获取原子变量的值|
|atomic_set|设定原子变量的值|
|atomic_inc(v)|原子变量的值加一|
|atomic_inc_return(v)|同上，只不过将变量v的最新值返回|
|atomic_dec(v)|原子变量的值减去一|
|atomic_dec_return(v)|同上，只不过将变量v的最新值返回|
|atomic_sub_and_test(i, v)|给一个原子变量v减去i，并判断变量v的最新值是否等于0|
|atomic_add_negative(i,v)|给一个原子变量v增加i，并判断变量v的最新值是否是负数|
|static inline int atomic_add_unless(atomic_t \*v, int a, int u)|只要原子变量v不等于u，那么就执行原子变量v加a的操作。如果v不等于u，返回非0值，否则返回0值|

对于上述的 atomic\_\* 函数，所有接口都可以保证原子变量的安全性。也就是即使出现两个程序执行流同时操作该原子变量，这些接口的内部实现也可以保证原子操作是被串行执行的。当然，这里的原子操作指的是整个 取值-操作-写回 的过程。  




## atomic 实现
我们已经了解了为什么要使用到原子变量，以及如何使用原子变量，接下来就需要来看看原子变量的具体实现，这样才能对原子变量有一个整体的掌握。   

正如上文中所说的，原子变量的实现通常是依赖于特定的硬件指令，是架构相关的实现，基于 armv7-A 架构，可以在 arch/arm/include/asm/atomic.h 中找到原子操作对应的实现。   

以 atomic_add 为例：

```c++
#if __LINUX_ARM_ARCH__ >= 6    //如果是 armv6 之后的架构

ATOMIC_OPS(add, +=, add)

#define ATOMIC_OPS(op, c_op, asm_op)					\
	ATOMIC_OP(op, c_op, asm_op)					\
	ATOMIC_FETCH_OP(op, c_op, asm_op)

#define ATOMIC_OP(op, c_op, asm_op)					\
static inline void atomic_##op(int i, atomic_t *v)			\
{									\
	unsigned long tmp;						\
	int result;							\
									\
	prefetchw(&v->counter);						\
	__asm__ __volatile__("@ atomic_" #op "\n"			\
"1:	ldrex	%0, [%3]\n"						\
"	" #asm_op "	%0, %0, %4\n"					\
"	strex	%1, %0, [%3]\n"						\
"	teq	%1, #0\n"						\
"	bne	1b"							\
	: "=&r" (result), "=&r" (tmp), "+Qo" (v->counter)		\
	: "r" (&v->counter), "Ir" (i)					\
	: "cc");							\
}		

#else                 // 如果是 armv6 之前的架构

#ifdef CONFIG_SMP     // armv6 之前不支持 SMP 系统
#error SMP not supported on pre-ARMv6 CPUs
#endif

#define ATOMIC_OP(op, c_op, asm_op)					\
static inline void atomic_##op(int i, atomic_t *v)			\
{									\
	unsigned long flags;						\
									\
	raw_local_irq_save(flags);					\
	v->counter c_op i;						\
	raw_local_irq_restore(flags);					\
}									\


```

arm 架构中的 atomic_add 是由宏定义 ATOMIC_OP 来实现的，使用 ATOMIC_OPS 宏实现一个操作函数模板来定义 atomic_add 函数。  

在上面的代码可以看到：atomic_add 的实现分为两种情况，以 armv6 架构为分界线，armv6 之前架构和 armv6 之后(包括armv6)架构的实现是不一样的。  

在 armv6 之前的架构中，是不支持 SMP 系统的，对于 atomic_add 的实现比较简单直接：操作原子变量之前关中断，操作完成之后再开中断，这里的关闭中断就可以保证 v->counter += i 这个过程不会被其它执行流打断，以此来保证其原子性。

可以很明显地看出，这种操作方式是由纯软件实现的，armv6 指令集架构并没有提供特定的指令来实现原子操作，因此 armv6 架构之前原子操作的开销其实是比较大的，全局地关中断会影响系统的实时性，因为 armv6 指令集架构本身不支持 SMP，也就不用考虑多核下的原子操作。  

在 armv6 以及 armv6 之后，由于引入了 SMP 的支持，情况变得比较麻烦，因为在 SMP 架构中，内核中的任务是真正地并发执行，关中断无法实现安全的原子操作，因为在 SMP 系统中，没有软件接口可以关闭全局的中断，而只能使用 local_irq_disable 之类的接口关闭本地的中断，同时，即使是关闭了所有 CPU 的中断，也无法保证原子变量不被多个执行流同时访问，所以，SMP 下 atomic_add 的实现并不能完全依赖于软件层面。   

通过上面的 >=armv6 的代码分支可以看到，atomic_add 是由嵌入式汇编实现的，核心的代码如下：

```c++
__asm__ __volatile__("@ atomic_" #op "\n"			
"1:	ldrex	%0, [%3]\n"             // 将 v->counter 读出到 result 中						
"	" #asm_op "	%0, %0, %4\n"		// result = result + i (i 是 atomic_add 传入的加数)
"	strex	%1, %0, [%3]\n"			// v->counter = result;(将 result 写回到 v->counter 的内存)，将执行结果保存在 tmp 中
"	teq	%1, #0\n"					// 测试上一步的执行结果，如果为 0，表示执行成功，否则表示上一步执行失败，跳回到标号 1 处。
"	bne	1b"							
	: "=&r" (result), "=&r" (tmp), "+Qo" (v->counter)		
	: "r" (&v->counter), "Ir" (i)					
	: "cc");`		
```

鉴于大多数朋友对嵌入式汇编并不熟，可以查看每一行的注释，汇编的代码兜来转去，其实也就是执行了这一条指令：v->counter +=1，那么，这一段代码是如何实现原子操作的呢？  

关键在于 ldrex 和 strex 这两条指令上，了解 arm 汇编的都知道，ldr 和 str 分别是加载和回写的汇编指令，而 ex 是 exclusive 的缩写，表示"独占"，这种独占操作在处理器之间是互斥的，这条指令避免了多处理器在同时操作时造成的内存同步问题,既然 ldrex 和 strex 保证了处理器之间的原子操作问题，那么就只需要考虑单 CPU 下的同步问题了。   

但是，在 >= armv6 架构中的 atomic_add 实现中，并没有看到关中断的行为，也就是说，在 atomic_add 这个原子操作函数执行时，是可以被中断打断的，甚至发生进程切换，因此 linux 下的 atomic_* 原子操作接口并没有实现真正的不被打断，而只是像锁一样，针对目标对象进行保护，而不保护整个执行过程。  

那么，问题来了：此时，如果进程 A 正在欢快地执行，刚好执行完 ldrex 指令之后，来了一个中断，进入中断服务程序(同一个CPU上)，而刚好这个中断服务程序中同样访问到该原子变量，于是它也执行了 ldrex 和 strex，因为在进程中已经使用了 ldrex 独占指令(但是没有执行完 strex)，在中断中难道不会因为 strex 失败而陷入死循环吗？  

答案是：既然 linux 中是这么实现的，当然就不会出现这个问题。在上面的介绍中，我们讲到了 ldrex 和 strex 是独占指令，但是这两条指令的规则并不是和我们想象的一样。在我们的常规思维中是这样的：ldrex 对原子变量的内存设定独占标志，直到当前执行流执行 strex 才会清除独占标志，否则下一个执行流再执行 ldrex 时，会失败，如果 ldrex 和 strex 的实现是这样的，确实会导致上述的问题，但是事情并没有这么简单。  

它们的真正实现是这样的：当某个 CPU 对共享对象的内存使用 ldrex 加载内存数据时，会设置一个寄存器标志，而在执行 strex 时，会检查这个标志是否被置位，如果被置位，strex 就执行成功，否则执行失败，同时清除寄存器标志。  

重点是，如果执行流 A 设置了一个标志，而另一个更高优先级的执行流 B(如中断)再次使用 ldrex 设置标志，是不受影响的，所以当执行流 B 使用 strex 时，因为标志依旧存在，所以执行流 B 调用 strex 会成功，并清除掉寄存器标志，而当执行流 B 返回到执行流 A 时，因为标志被清除，所以执行流 A 执行 strex 会失败，失败导致的结果仅仅是重新调用一次 ldrex+strex，而此时因为重新调用了 ldrex，该指令会将由执行流 B 设置的新的值加载到寄存器中，也就保证了数据的同步。  

所以，即使不关中断、atomic_add 的过程被其他执行流打断，也不会影响 atomic_add 的执行结果。重点在于：新的执行流会完整地执行整个原子操作流程，而被打断的执行流将会失败，失败带来的结果也仅仅是重新执行一次，在重新执行的过程中也就加载了新的原子变量中(当然是在两个执行流"同时"操作一个原子变量的时候，如果不是，也就不需要考虑同步问题)。  

需要再次提醒的是，linux 中原子操作的实现和硬件的实现是强相关的，上述的示例只是针对 armv6 及以上的 arm 指令集架构。  



## atomic_set
在 atomic_\* 实现的系列原子操作中，有两个比较惹眼的操作实现：atomic_read atomic_set,分别对应原子变量的读和设置.  

```c++
#define atomic_read(v)	READ_ONCE((v)->counter)
#define atomic_set(v,i)	WRITE_ONCE(((v)->counter), (i))
```

其中，READ_ONCE 和 WRITE_ONCE 可以简单地理解为给 v->counter 这个变量赋予 volatile 的特性，以保证编译器不会对原子变量的操作进行优化，从而直接操作到内存，有些朋友会对这两个操作的实现有一些疑问：为什么这两个操作不需要做数据的保护？  

实际上，我们要了解的一个概念就是:对于某一个全局对象，并不是只要存在同时访问，就需要做数据保护，而是在同时访问会产生同步问题的时候才需要做数据保护.

那么，我们怎么判断一个全局对象的同时访问会不会出问题呢？  

当多个执行流同时读一个全局对象时，并不会有什么问题，只是该对象内存中的数据多读出来几次，每次读出来的数据都是一样的，这个数据也不会变，所以完全没有必要保护，这并不难理解。  

而对于 atomic_set 而言，它看起来和 atomic_add 很像，都是修改原子变量对应内存的值，对于 atomic_add 而言，操作流程为：读原子变量->原子变量加上某值->将新原子变量写回，需要数据保护的原因往往是前一个执行流 A 只执行了第一步就被高优先级执行流B所抢占执行，导致B执行完之后，A操作的还是旧值。

而对于 atomic_set 而言，并没有前两个步骤，仅仅是将新值写到某个内存地址，你可以理解为单条的 ldr 指令就可以完成这个工作，是不需要做数据保护的，关于这一点，你可以再思考思考。  



### 参考

4.9.88 源码

http://www.wowotech.net/kernel_synchronization/atomic.html

---

[专栏首页(博客索引)](https://zhuanlan.zhihu.com/p/362640343)

原创博客，转载请注明出处。
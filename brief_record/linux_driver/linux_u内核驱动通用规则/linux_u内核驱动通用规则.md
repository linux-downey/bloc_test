# Linux 驱动开发的通用技巧
在大多数 Linux 用户的印象中，Linux 灵活且非常强大，但是换一个角度，灵活往往意味着复杂，至少对于开发者是这样的。  

是的，即使是一个 gpio 的驱动框架，原本是设置几个寄存器的事，在 Linux 中就需要做类似于 注册设备、设置回调等一系列操作，尽管 Linux 的框架尽量地将设备驱动的编写变得更简洁，将论述题变成填空题(通常一个设备驱动只需要往结构体中填充相应字段即可)。   
  
随着设备驱动的简单化，即使做再多的填空题，我们也学不会怎样去实现一个完整的驱动框架，对于工作于底层的工程师来说，这并不是一件光荣的事。  

既然要着手研究内核框架，总归是要讲究一些方法，了解内核驱动程序中一些常用的编程技巧和注意事项，通俗地说就是一些套路，这样对于我们研究内核具有战略性的作用。  

在这一章，博主就斗胆和各位讨论讨论内核框架实现中一些通用的技巧。  

## 主机驱动和设备驱动
刚接触内核驱动的朋友可能对主机驱动程序和设备驱动程序的区分有些模糊，统一地认为就是某外设(i2c、USB等)驱动程序，对于一个非 BSP 驱动工程师而言，会比较少地接触到主机驱动程序，主机驱动和外设驱动的概念主要是体现在 IO 外设中，比如 i2c spi USB等，主机驱动主要实现外设的数据收发，而设备驱动则是在主机驱动实现了数据收发的情况下，进行数据上的交互以实现某些逻辑。  

比如 i2c 的主机驱动主要实现 i2c_write()、i2c_read() 等接口的具体实现，而设备驱动则是基于 i2c 的外围设备，比如触摸屏、传感器等。  

通常来说，主机驱动都是由厂商完成开发，驱动开发工程师(BSP工程师除外)的工作就是在其基础上开发各类设备应用，也就是外设驱动.主机驱动专注提供硬件的操作接口，通常都是涉及到寄存器操作，而设备驱动更多地偏向于逻辑处理。 


## 并发性
在驱动开发之前，完全有必要了解驱动是如何工作的。  

用户通过特定的驱动接口访问硬件设备，在用户空间自然没有硬件设备的访问权限，这时候将陷入内核，由内核代为执行，然后将执行结果返回到用户空间。

而用户访问的驱动接口就是由内核驱动生成的，在用户产生访问行为且通过权限检查之后，自然就调用到相应的内核驱动程序。由此可见，驱动程序驻留在内核中更像是一种服务程序，总是被动地被调用，同时，对于大部分的接口，通常都会有并发访问的需求，比较典型的比如 磁盘的IO、网络设备。这就需要内核驱动具备处理并发的能力。  

### 可重入性
驱动代码的可重入性是第一个基本的问题，可重入代码指可被多个函数或程序调用的一段代码(通常是一个函数),而且它保证在被任何一个函数调用时都以同样的方式运行(引用自百度百科)。通俗来讲，就是程序中尽量避免全局变量、静态变量这一类在多次调用中会出现不同表现的元素。  

不难想到，如果你的驱动程序提供应用程序接口，比如在 /dev /sys 目录下创建访问接口，你就需要注意这个问题。  

比如，在你的驱动程序中有一个全局标志位 flag，第一个应用程序 A 访问你的驱动程序时，因为做了某些事情，将 flag 设置为1，而第二个应用程序 B 刚执行时，又将 flag 设置初始化为0，因为进程的调度，随着 A 与 B 的交叉访问，导致程序的运行结果变得不可测。  


还有一种情况就是：一个驱动程序的 driver 部分经常存在被重复调用的情况。情况通常是这样的：一个系统中存在多个 gpio controller，这些不同的 gpio controller 只有寄存器地址、clock 输入这些细微的区别，通常在设备树描述中就使用相同的 compatible 属性,所以将使用到相同的 driver 部分，硬件上的差异就由设备树其它部分来描述。  
 
在这种情况下，一个 driver 被多次使用，软件上的体现就是其 driver 的 probe 函数被重复调用，上述示例中，每个 gpio controller 都有自己的私有数据，那么每个驱动相关数据如何保存呢？  

内核中的通用做法是：将所有该驱动需要用到的数据装在一个结构体内，在 probe 函数中申请对应的动态内存，最重要的是，将这片动态内存的指针保存在对应的 device->platform_data 中，由于每个设备都有独立的 device 结构，所以就可以实现每个设备都关联到自己的私有数据，这些数据被存储在堆内(动态申请)。  

对应的接口有：

```
static inline void dev_set_drvdata(struct device *dev, void *data)
{
	dev->driver_data = data;
}
```

对应的获取私有数据接口为

```
static inline void *dev_get_drvdata(const struct device *dev)
{
	return dev->driver_data;
}

```

### 同步机制
虽说需要注意代码的可重入性，但是有时候事情并非像想象中那么完美，尤其是涉及到系统资源的时候。总归系统资源就这么多，如果要多个程序要使用，就需要加入一些同步机制，以免因竞态而带来的系统问题。  

内核中最常用的要数自旋锁了、其他的还有互斥量、信号量等等，以下是对这部分常用的同步机制的简介：

* 自旋锁：一种忙等机制的锁，当请求资源失败时，并不进入睡眠，而是原地自旋等待，如果使用该锁需要确保你的加锁部分程序执行效率很高
* 互斥量：又被称为互斥锁，与自旋锁不同的是，当请求资源失败时，进入睡眠状态，从而释放系统资源
* 信号量：可以看成是多值互斥锁，当信号量小于1时，请求信号量的行为将导致睡眠。


## Linux 驱动框架与回调机制

如果你接触过 linux 的内核代码，可以发现内核驱动代码中充斥着各种各样的回调函数，不知道你有没有想过，为什么要设置这些回调函数接口？  

这个问题其实伴随着另一个问题：linux 为什么要使用"框架"，如果要在我们的开发板上实现自己的诸如 gpio、pwm、i2c 这一类简单的驱动，裸机代码反倒简单得多，为什么还要把事情复杂化。  

事实上，linux 面对的完全不是我们一个或者几个用户，面对各类设备，作为一个宏内核，如果每个设备都加入自己的裸机代码，那整个内核将会变得臃肿不堪，你可以简单地理解为：框架就是抽象的结果，抽象是指从具体事物抽出、概括出它们共同的方面、本质属性与关系等，而将个别的、非本质的方面、属性与关系舍弃的思维过程。  

被抽出的共同部分作为框架,而那些个别的、非本质的区别是哪些呢？  

对于 gpio，可能就是不同的 gpio 号，框架实现 gpio 的操作，而用户要做的就是传入一个 gpio 号，其他的框架已经实现好了，对于 i2c 而言呢，可能指的就是不同的 i2c 地址，不同的寄存器操作。  

而在 linux 中，几乎每一种外设、每一个资源都对应的相应的框架，才有了上文中说的，有时候实现一个外设驱动就是做填空题，linux 中框架通常所做的事情就是管理设备、提供用户访问接口。  

而设备的注册(这里所说的设备注册，其实是注册那些"有区别的"资源),就是用户动手实现，假设有这种场景，我们需要提供一个 gpio 驱动，用户通过某个文件接口实现对 gpio 状态的读写。  

事实上我们并不会知道用户什么时候会读写该 gpio，同时系统框架是没有能力定义该 gpio 的操作方式的，因为操作 gpio 的接口对于每个平台来说都是不一样的。  

那么，gpio 控制接口(通常就是寄存器操作)需要我们自己编写，用户在操作 gpio 的时候怎么调用到这个我们自己实现的 gpio 操作函数呢？就是通过回调函数.

讲到这里，你对回调机制的作用可能会有一些眉目了，是的，既然框架抽象出那些通用的部分，那么那些平台差异化的数据和操作怎么办呢？数据可以由配置文件导入(设备树)，而操作就以回调函数来实现，在适当的时候被调用。  

这就解释了为什么我们编写一个设备驱动程序时，通常要设置一些设备树参数和回调函数，而回调函数中大多是硬件相关操作，比如寄存器的操作之类的。  

## linux 内核之面向对象
尽管 C 语言不支持 C++ 的面向对象语法，但是在内核中，面向对象的思想随处可见，下面我们来看看面向对象的三大要点在linux内核中的实现。

### 封装
封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别。  

那么，内核中使用 C 语言中是怎么实现封装的呢？  

答案是：将结构体的定义放在 .c 文件中，将结构体的声明放在 .h 文件中，这种非常规做法非常少见。  

它达到了什么样的效果呢？外部文件包含该结构体声明的 .h 文件，仅仅是一个声明，比如 struct cls;struct device;导致外部文件无法访问内部的数据，因为它并不知道被声明的结构体的内部组成，只能使用该 .h 文件提供的函数接口来操作该结构体。  

如果要探究这种做法的原理，需要从两个角度来探究：
* 这种非常规做法是否能正常地通过编译链接？
* 为什么外部文件只能通过 .h 声明的函数接口进行访问而不能直接访问结构体内的成员。

这两个问题都需要从编译的角度来看，首先，一个你需要了解的基本编译知识是：程序是分离编译的，也就是说，每个 .c 文件在编译阶段都只与它包含的文件(一般是 .h 文件)进行结合，而不会与其他 .c 文件发生任何关系。  

对于只有声明而找不到定义的对象，编译器的做法是做一个标记，把问题的处理提交给下一步：链接，在程序链接的过程中负责将所有的定义与声明进行匹配。  

所以，对于引用了该 .h 文件的外部文件而言，使用对应的 struct cls(在 .h 中声明的结构体名) **指针**，至少在编译阶段是没有问题的，由于 .c 文件也将被编译，所以在链接阶段也是可以找到对应定义而链接成功的。  

为什么强调是被声明的结构体的指针，而不能是结构体的实例对象呢？  

假设 struct cls 被声明在 class.h 中，main.c 包含了class.h.对于 main.c 而言，看到的就是一个非常简单的声明，在编译 main.c 的时候压根就不知道  struct cls 的内容是什么，其实重点也并非在于一定要知道 struct cls 具体有些什么。而是因为如果声明的是实例，摆在面前的最大问题就是怎么给这个结构体分配空间，对于 main.c 来说是确定不了的，所以无法实现，而指针就不一样，它的大小是确定的。  

这也回答了上述的第二个问题：为什么外部文件不能访问结构体内的成员，也是因为对于 main.c 而言，只知道有 struct cls 这么个东西，尽管程序员知道，struct cls 中包含了 value 成员，但是对于 main.c 来说，你都没声明(只声明结构体，没声明及饿哦固体成员)，自然是不认的，这跟函数的调用一样，如果你不声明就在外部调用函数，同样也会报错。  


我们来看下面的例子,该示例由三个文件组成，供各位参考以及动手实验：

main.c:
```
  1 #include "class_file.h"
  2 
  3 
  4 int main(void)
  5 {
  6         struct cls *cls = NULL;
  7         cls_init(cls);
  8         //printf("cls->value = %d\n",cls->value);
  9 
 10         cls_free(cls);
 11 }
```

class_file.c:
```
  3 #include "class_file.h"
  4 
  5 struct cls{
  6         int value;
  7 };
  8 
  9 
 10 void cls_init(struct cls* cls)
 11 {
 12         cls = malloc(sizeof(struct cls));
 13         cls->value = 1;
 14 }
 15 
 16 void cls_free(struct cls* cls)
 17 {
 18         free(cls);
 19 }
```

class_file.h
```
  1 #include <stdio.h>
  2 #include <stdlib.h>
  3 
  4 struct cls;
  5 
  6 void cls_init(struct cls* cls);
  7 void cls_free(struct cls* cls);
  8 
```

该示例中，结构体 struct cls 被定义在 class_file.c 中，操作结构体内部成员的接口也由 class_file.c 提供，由 class_file.h 文件声明，在 main.c 中，只能使用 class_file.c 提供的接口来操作 struct cls 结构体。  

你可以试试，如果在 main.c 中定义 struct cls cls 而不是 struct cls *cls，再编译将会发生什么？  

或者是试试将第8行：

```
printf("cls->value = %d\n",cls->value);
```

的注释取消，再编译将会发生什么？

动手试试能帮你加深理解。

## 继承
内核中的"继承"机制设计得非常巧妙，而且是 linux 的核心机制，同样的，此继承非彼继承，并不是语法支持，而是通过 C 语言中结构体的特性来实现的。  

C语言中，结构体内成员的地址是按序排列的，尽管其中通常存在填充字节，如果我们知道结构体中某个成员的地址，是不是可以反推出结构体的基地址？  

答案是肯定的，linux中的"继承"机制就是基于这个特性而设计的，与 C++ 中继承关系不同的是，这种继承的基类是被定义在派生类中的，比如 linux 中随处可见的 struct device、struct kobj，都是这样实现的。  

比如下面的示例：

```
struct simple_dev{
  int value;
  struct device dev;
};
```

通过 linux 中的接口： container_of(), 我们就可以以 dev 的地址，获取到 simple_dev 的地址，从而访问到整个结构体。  

看起来很厉害，但是它到底是怎么使用的呢？  

一个容易理解且典型的示例就是内核中的链表，常见的链表是链表节点包含数据，而内核中的链表则是在数据成员中包含链表节点：

```
struct data{
  ...
  struct list_head list;
  ...
};
```

在传统链表中，需要所有数据节点保持同一个类型，对于不同的数据类型只能使用 void *，甚至还存在 void * 的嵌套，用过这种方式的都知道，如果想要在抽象接口中统一操作这类链表是非常麻烦的。  

而内核中的链表就不一样了，无论你的数据节点是什么类型，你要做的就是包含一个链表节点，在链表遍历时通过链表指针反向定位到数据部分，这无疑提供了极大的遍历。  

对于内核中的 container_of() 接口实现，可以参考另一篇博客：[linux内核container_of宏解析](http://www.downeyboy.com/2019/03/16/linux-container_of/)。  


## 多态
多态的实现事实上是基于对 GCC 的扩展，GCC 扩展了 __attribute__() 关键字，它的作用就是对目标进行修饰，比如指定目标在编译目标文件中所属的段，指定目标访问属性、对齐属性等。既然是 GCC 的扩展，自然就是影响到编译阶段的各种属性。  

而这里要讲的就是它的两个属性：__attribute__((weak)) 和 __attribute__((weakref)),一个是涉及到强弱引用，一个涉及到强弱符号。  

### 强弱引用
通常我们在函数调用或者变量引用时，默认是强引用，也就是被调用的目标对象不存在时将报错，相对的，我们可以使用弱引用，比如下面的语法：

```
__attribute__((weakref)) void func(void);
```

这个 func 就被定义为弱引用，也就是在别的地方可以调用 func 函数，如果 func 函数存在，就调用 func 函数，如果不存在，也不会链接报错。  

### 强弱符号
符号，即我们定义的函数、变量在目标文件中的条目，在我们印象中，同一个作用域中是不允许存在两个相同符号的，比如定义同名的两个全局变量。  

但是在 GCC 的扩展中，符号也有强弱之分，规则变成了在同一作用域中允许定义同名的符号，比如两个同名函数，同名变量，条件是两个都是弱符号或者一个强符号一个弱符号，强符号将覆盖弱符号而存在，如果同时两个强符号被定义，将会报错。  

对于变量而言，未初始化的符号为弱符号，而初始化的变量为强符号，同时，使用 __attribute__((weak)) 指定的符号也是弱符号，比如：

```
int __attribute__((weak)) value; 
```

对于函数而言，使用 __attribute__((weak)) 指定的符号也是弱符号，否则都是强符号。  

这种实现方式类似于 C++ 中的同名接口的定义。

对于强弱符号，这里只是做一个初步介绍，如果想要详细了解可以参考我的另一篇博客：[C强弱符号、强弱引用](http://www.downeyboy.com/2018/09/25/C_symbol_and_reference/)。



# Linux 驱动开发的通用技巧
在大多数 Linux 用户的印象中，Linux 灵活且非常强大，但是换一个角度，灵活往往意味着复杂，至少对于开发者是这样的。  

是的，即使是一个 gpio 的驱动框架，原本是设置几个寄存器的事，在 Linux 中就需要做类似于 注册设备、设置回调等一系列操作，尽管 Linux 的框架尽量地将设备驱动的编写变得更简洁，将论述题变成填空题(通常一个设备驱动只需要往结构体中填充相应字段即可)。   
  
随着设备驱动的简单化，即使做再多的填空题，我们也学不会怎样去实现一个完整的驱动框架，对于工作于底层的工程师来说，这并不是一件光荣的事。  

既然要着手研究内核框架，总归是要讲究一些方法，了解内核驱动程序中一些常用的编程技巧和注意事项，通俗地说就是一些套路，这样对于我们研究内核具有战略性的作用。  

在这一章，博主就斗胆和各位讨论讨论内核框架实现中一些通用的技巧。  

## 主机驱动和设备驱动
刚接触内核驱动的朋友可能对主机驱动程序和设备驱动程序的区分有些模糊，统一地认为就是某外设(i2c、USB等)驱动程序，对于一个非 BSP 驱动工程师而言，会比较少地接触到主机驱动程序，而主机驱动程序和设备驱动程序有着这样的区别：

主机驱动程序通常指外设本身的驱动程序


## 并发性
在驱动开发之前，完全有必要了解驱动是如何工作的。  

用户通过特定的驱动接口访问硬件设备，在用户空间自然没有硬件设备的访问权限，这时候将陷入内核，由内核代为执行，然后将执行结果返回到用户空间。

而用户访问的驱动接口就是由内核驱动生成的，在用户产生访问行为且通过权限检查之后，自然就调用到相应的内核驱动程序。由此可见，驱动程序驻留在内核中更像是一种服务程序，总是被动地被调用，同时，对于大部分的接口，通常都会有并发访问的需求，比较典型的比如 磁盘的IO、网络设备。这就需要内核驱动具备处理并发的能力。  

### 可重入性
驱动代码的可重入性是第一个基本的问题，可重入代码指可被多个函数或程序调用的一段代码(通常是一个函数),而且它保证在被任何一个函数调用时都以同样的方式运行(引用自百度百科)。通俗来讲，就是程序中尽量避免全局变量、静态变量这一类在多次调用中会出现不同表现的元素。  

不难想到，如果你的驱动程序提供应用程序接口，比如在 /dev /sys 目录下创建访问接口，你就需要注意这个问题。  

比如，在你的驱动程序中有一个全局标志位 flag，第一个应用程序 A 访问你的驱动程序时，因为做了某些事情，将 flag 设置为1，而第二个应用程序 B 刚执行时，又将 flag 设置初始化为0，因为进程的调度，随着 A 与 B 的交叉访问，导致程序的运行结果变得不可测。  


还有一种情况就是：一个驱动程序的 driver 部分经常存在被重复调用的情况。情况通常是这样的：一个系统中存在多个 gpio controller，这些不同的 gpio controller 只有寄存器地址、clock 输入这些细微的区别，通常在设备树描述中就使用相同的 compatible 属性,所以将使用到相同的 driver 部分，硬件上的差异就由设备树其它部分来描述。  
 
在这种情况下，一个 driver 被多次使用，软件上的体现就是其 driver 的 probe 函数被重复调用，上述示例中，每个 gpio controller 都有自己的私有数据，那么每个驱动相关数据如何保存呢？  

内核中的通用做法是：将所有该驱动需要用到的数据装在一个结构体内，在 probe 函数中申请对应的动态内存，最重要的是，将这片动态内存的指针保存在对应的 device->platform_data 中，由于每个设备都有独立的 device 结构，所以就可以实现每个设备都关联到自己的私有数据，这些数据被存储在堆内(动态申请)。  

对应的接口有：

```
static inline void dev_set_drvdata(struct device *dev, void *data)
{
	dev->driver_data = data;
}
```

对应的获取私有数据接口为

```
static inline void *dev_get_drvdata(const struct device *dev)
{
	return dev->driver_data;
}

```

### 同步机制
虽说需要注意代码的可重入性，但是有时候事情并非像想象中那么完美，尤其是涉及到系统资源的时候。总归系统资源就这么多，如果要多个程序要使用，就需要加入一些同步机制，以免因竞态而带来的系统问题。  

内核中最常用的要数自旋锁了、其他的还有互斥量、信号量等等，以下是对这部分常用的同步机制的简介：

* 自旋锁：一种忙等机制的锁，当请求资源失败时，并不进入睡眠，而是原地自旋等待，如果使用该锁需要确保你的加锁部分程序执行效率很高
* 互斥量：又被称为互斥锁，与自旋锁不同的是，当请求资源失败时，进入睡眠状态，从而释放系统资源
* 信号量：可以看成是多值互斥锁，当信号量小于1时，请求信号量的行为将导致睡眠。


## Linux 驱动框架与回调机制
如果你接触过 linux 的内核代码，可以发现内核驱动代码中充斥着各种各样的回调函数，不知道你有没有想过，为什么要设置这些回调函数接口？  

这个问题其实伴随着另一个问题：linux 为什么要使用"框架"，如果要在我们的开发板上实现自己的诸如 gpio、pwm、i2c 这一类简单的驱动，裸机代码反倒简单得多，为什么还要把事情复杂化。  

事实上，linux 面对的完全不是我们一个或者几个用户，面对各类设备，作为一个宏内核，如果每个设备都加入自己的裸机代码，那整个内核将会变得臃肿不堪，你可以简单地理解为：框架就是抽象的结果，抽象是指从具体事物抽出、概括出它们共同的方面、本质属性与关系等，而将个别的、非本质的方面、属性与关系舍弃的思维过程。  

而那些个别的、非本质的区别是哪些呢？  

对于 gpio，可能就是不同的 gpio 号，框架实现 gpio 的操作，而用户要做的就是传入一个 gpio 号，其他的框架已经实现好了，对于 i2c 而言呢，可能指的就是不同的 i2c 地址，不同的寄存器操作。  

而在 linux 中，几乎每一种外设、每一个资源都对应的相应的框架，才有了上文中说的，有时候实现一个外设驱动就是做填空题，linux 中框架通常所做的事情就是管理设备、提供用户访问接口。  

而设备的注册，就是用户动手实现，假设有这种场景，我们需要提供一个 gpio 驱动，用户通过某个文件接口实现对 gpio 状态的读写。  

事实上我们并不会知道用户什么时候会读写该 gpio，同时系统框架是没有能力定义该 gpio 的操作方式的，因为操作 gpio 的接口对于每个平台来说都是不一样的。  

那么，gpio 控制接口(通常就是寄存器操作)需要我们自己编写，用户在操作 gpio 的时候怎么调用到这个我们自己实现的 gpio 操作函数呢？就是通过回调函数!

讲到这里，你对回调机制的作用可能会有一些眉目了，是的，既然框架抽象出那些通用的部分，那么那些平台差异化的数据和操作怎么办呢？数据可以由配置文件导入(设备树)，而操作就以回调函数来实现，在适当的时候被调用。  

这就解释了为什么我们编写一个设备驱动程序时，通常要设置一些设备树参数和回调函数，而回调函数中大多是硬件相关操作，比如寄存器的操作之类的。  




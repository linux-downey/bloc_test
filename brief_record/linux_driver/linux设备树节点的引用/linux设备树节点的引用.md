# linux 设备树节点的引用
在设备树中，硬件以树状的层次被映射成设备树中的节点，从根开始，分别引出各级总线，有对应真实的物理总线(如i2c、spi等)，也有专门为了统一设备模型而引入的虚拟总线(platform bus)，所有连接在系统总线上的设备都被抽象成节点，尽管某些部分比如定时器、时钟、gpio，在实际的开发过程中，我们并不把它们看成总线，但是对于 linux 系统而言，对这些同样挂载在系统总线上的硬件资源进行统一的抽象，方便进行管理。   

虽然，从设备树的结构来看，各个节点之间层次分明，各个总线之间没有明显的联系。但是从系统的角度来看，各个硬件之间的耦合是必然存在的，最常见的就是：大多数总线都需用使用到时钟部分，引脚的 pinmux 复用。那么，既然硬件上有耦合，那么肯定就会体现在软件上，毕竟，在 linux 中，软件的模型总归是建立在硬件的拓补上的。

那么，就存在节点之间的相互引用。


## 引用语法
在设备树中，我们经常可以看到这样的内容：

```
gpiobank1:gpio@0x800000{
    gpio-controller;
	#gpio-cells = <2>;
    ...
}
devicectl{
    ...
    gpio_enable = <&gpiobank1 GPIO1 GPIO_ACTIVE_HIGH>;
    ...
}
```
这就是设备树中对于 gpio 模块的引用，在某些模块的使用时，可能用到一些指示灯或者 reset 引脚，需要额外地去操作 gpio，就需要在当前节点中引用对应的 gpio。  

在上述的示例中，可以通过 devicectl 节点看出，该节点引用 gpiobank1 的 GPIO1 对应的引脚，将其设置为高，那么，需要引用 gpio 需要多少个参数是由什么决定的呢？  

答案是通过对应 gpio bank，也就是 gpiobank1 的 #gpio-cells 节点来决定，在上述示例中，该值为2，所以引用的时候需要两个额外的参数来确定。  


## 内核对引用的处理
与 gpio 具有相同待遇的还有 clock，几乎每个模块都需要 clock 的支持，在大部分的系统中，每个模块的运行都需要指定 enable 相应的时钟，所以通常需要在设备树中指定需要用到的时钟来源，以便在驱动 probe 成功时开启它以确保外设的运行，





# linux 中常见的位操作
在内核中，为了提升程序的运行效率，数据操作通常是以位为单位，这也衍生出非常多位操作相关的内核接口，而且，熟练掌握位操作也是嵌入式工程师的必备技能。  

接下来，我们就来看看内核中有哪些位操作。  

## 置位和复位
在寄存器的设置中，通常需要使用到单一位的置位与复位，比如：

将一个数据中 bit3 置位(设置1)： x |=  (1 << 3);

将一个数据中的 bit 3 复位(设置0)： x &= ~(1 <<3); 

这个基本操作我就不做解释了，只是需要注意的是，在位操作中有个比较讨厌的地方，就是第一位是 bit 0，所以上述的 bit 3 是第四位，当然，计算机中的数据集索引从 0 开始，这是一个惯例了。  

## 获取数据中的位
类似于 1 << n 这一类的移位语法看起来不够直观，我们可以使用 BIT(x) 宏来代替：

```C
#define BIT(nr)		(1UL << (nr))
```
BIT 返回数据中指定的位，上述的例子可以写成 x |=  BIT(3);  

对于这一类的位操作，有一个容易被忽略的问题，就是目标数据的长度，比如一个 8 位的数据，当误使用 BIT(9) 又会发生什么？   

有两种可能的答案：BIT(9) = 0 或者 BIT(9) = BIT(1) = 2(数据溢出又循环回到 BIT(1) )。  

很多朋友可能认为答案是第二个，按照数据操作的常理，数据溢出是一个循环的过程，即 255 + 2 = 1，但是在位操作中，情况并非如此。 

移位操作的定义是：对被操作数的二进制数整体移动指定位数，空位由 0 补齐。即：8 位数据 0x80 向左移动移位结果为 0x00，因为最高位被移出，最低位由 0 补齐。  

教科书曾经告诉我们：当我们需要对一个数据乘以 2 的整数次幂时，我们可以直接使用移位的方式来操作，这样效率更高。  

这种说法通常是对的，但是我们需要考虑数据溢出的情况：
* 一个 signed char 类型的数据，值为 126，当我们左移一位时，并不会出现预想中的 252，得到的结果是 -4.
* 一个 unsigned char 类型的数据，值为 255 ，当数据左移一位时，结果是 0 。  

所以，当我们在做数据的移位操作时，需要优先考虑数据的溢出问题。  

## 获取指定类型数据中的位
当我们使用 1 << n 移位操作的时候，它产生的结果是 int 型数据，也就是说，当 n = 32 时，这个操作结果是 0,比如：

```
val |= 1 << 32;
```  
尽管 val 是 64 位的数据，但是这并不会将 val 的 bit32 置为 1 ，因为 1 << 32 的结果并非 0x100000000，而是 0x0，因为数据溢出。  
 
而且，int 类型本身也伴随着移植性的问题，在经典的 32 位或者 64 位系统中，int 型为 32 位，但是在一些 16 位或者 8 位平台下，int 型通常为 16 位，所以有时候在 32 位平台运行得好好的程序移植到 16 位平台上无法运行.  

尽管内核中的 BIT(nr) 使用的是 UL 类型，但是在 32 位平台上只有 32 位，同样可能溢出。  

所以，在某些时候需要指定数据类型，要考虑到溢出的情况，就得使用更大的数据类型，比如 long long，内核中的 BIT_ULL 就是起到这个作用。

```
#define BIT_ULL(nr)		(1ULL << (nr))
```
在 32 位操作系统中， val |= BIT_ULL(32);就可以得到理想的结果。  

BIT 和 BIT_ULL 获取指定的位， BIT_MASK 和 BIT_ULL_MASK 也执行相类似的操作：

```C
#define BIT_MASK(nr)		(1UL << ((nr) % BITS_PER_LONG))
#define BIT_ULL_MASK(nr)	(1ULL << ((nr) % BITS_PER_LONG_LONG))
``` 
不同的是，带 MASK 后缀的宏允许出现溢出的情况，该宏会先将参数对 BITS_PER_LONG 做取余操作，long 类型在 32 位和 64 位 CPU 中分别占 32 位和 64 位，所以相对应的，BITS_PER_LONG 在 32、64 位系统中分别等于 32、64。  

这一类操作通常出现在 hash 表或者位图中，在标记某个资源的时候允许对某个位重复使用，比如 id 为 1 和 33 的数据同时使用 1 号槽，BIT_MASK(1) 等于 BIT(33)。  


在内核中，对于某些 bool 型的数据，或者是 true/false 的 flag ，经常会使用到位图，用位来进行操作以获取空间和时间上的优化，bit map 就是内核中基于位图的实现，当单个数据无法容纳下所有的情况时，通常使用位图数组。   

而 BIT_WORD 宏就是用于获取位图数组中指定数组索引：

```C
#define BIT_WORD(nr)		((nr) / BITS_PER_LONG)
#define BIT_ULL_WORD(nr)	((nr) / BITS_PER_LONG_LONG)
```
BIT_WORD(33) 则表示该位位于数组中的第二个元素中，再使用 BIT_MASK(33) 同时可以获取所在位。即在位图数组中，id 为 33 的数据位于 arr[BIT_WORD(33)] 的 BIT_MASK(33) 位(数组中第二个数据的第二位)。


## 向上取整
同样是在位图操作中，当我们需要创建一个位图数组时，在申请空间的时候自然需要向上取整，比如申请一个 1000 位的空间时，自然会向上取整到 1024 位，即 128 字节，一个 32 个元素的 long 型数组，这时可以使用 BITS_TO_LONGS() 宏来获取目标数组的长度：

```
#define __KERNEL_DIV_ROUND_UP(n, d) (((n) + (d) - 1) / (d))

#define DIV_ROUND_UP __KERNEL_DIV_ROUND_UP

#define BITS_TO_LONGS(nr)	DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long))
```

其中，BITS_TO_LONGS(nr) 的功能是根据提供的目标位数(nr)获取 long 型数组的长度，具体实现为 __KERNEL_DIV_ROUND_UP 宏，该宏的运算公式为：

```
(((n) + (d) - 1) / (d))
```
n 为传入的目标位数，d 为单个数组元素的位数，(n + (d-1) / d) 则表示向上取整:

当 n % d > 0 时，n = n / d +1 
当 n % d == 0 时，n = n / d +1 

比如：

数组元素为 long 型，目标位数为 64， (64 + (32 - 1)) / 32 = 2
数组元素为 long 型，目标位数为 65， (65 + (32 - 1)) / 32 = 3

也就是说，即使多出一位，也需要多申请一个数组元素来装。  


## char 和 long
在上述示例中，申请 1000 位为什么是取整到 1024,而不是直接使用 1000 ，使用 char 型的数组呢？这样只需要申请 125 个字节的数据。  

事实上，在大多数的情况下(并非所有情况)，使用 char 型的数据并不见得比使用 long 型数据好。

这是因为数据对齐的缘故，同样是从数据处理的效率出发，无论是在结构体中还是在函数调用时的栈上，尽管是 char 型的数据，也会占用与内存对其单位的数据空间(char 型的数组)。   

通常，这种对齐一般为 4 字节或者 8 字节，与 long 型的数据刚好对应，也就是说 125 字节和 128 字节的处理效率是完全一样的，都是以 128 字节的方式进行处理，所以在内核中通常就直接使用 long 型的数组进行处理。  


## 位图操作
在内核中，使用位操作最多的部分自然是位图 bitmap 了,位图的结构就是上述所说的数组，该数组为 long 型数据，每一个独立的位表示一项参数。  

它的定义是这样的：

```C
#define DECLARE_BITMAP(name,bits) \
	unsigned long name[BITS_TO_LONGS(bits)]
```
位图的初始化很简单，传入两个参数：变量名以及该 bitmap 需要表示的最大位数。   

初始化一个 unsigned long 型数组，使用上述讲到的 BITS_TO_LONGS(bits) 宏，该宏向上取整，返回 bits 应该占据的数组元素大小。  

位图的设置则是下面的接口：

```
void __bitmap_set(unsigned long *map, unsigned int start, int len)

```
第一个参数表示 bitmap 的地址，第二个参数表示从哪一位开始，第三个参数表示需要设置多少位，从 start 开始的连续位。  


for_each_set_bit() 宏针对位图中所有设置的位进行特定的操作，这是非常常见的遍历手段。毕竟，通常位图就是用于设置某些二义性的标志位，该宏针对位图中所有被置位的部分进行遍历操作。    

```
#define for_each_set_bit(bit, addr, size) \
	for ((bit) = find_first_bit((addr), (size));		\
	     (bit) < (size);					\
	     (bit) = find_next_bit((addr), (size), (bit) + 1))
```
在该宏中，传入三个参数：
* bit 表示该 bit 在位图中的位置
* addr 表示位图的地址
* size 表示需要遍历的数量

也就是说，从 addr 表示的位图起始地址开始，遍历 size 位，找出其中每个被置位的位。  

比如：一个外部存储设备中，分成 100 个 block ，在内存中用一个位图来记录该 100 个 block 中是否有数据，毕竟直接访问内存比读写外部设备效率高得多，当我们需要遍历存储设备上的文件时，就可以使用到 for_each_set_bit 接口。  

可以看下列的示例：

```C

DECLARE_BITMAP(bitmap,1000);
static int __init hello_world_init(void)
{
        unsigned long pos = 0;
        bitmap_set(bitmap,1,3);
        for_each_set_bit(pos,bitmap,5)
                printk("pos:%d\n",pos);
        printk(KERN_DEBUG "hello world!!!\n");
        return 0;
}

```

加载之后的的输出结果为：
```
pos:1
pos:2
pos:3
```


参考：https://biscuitos.github.io/blog/BITMAP_for_each_set_bit/

















先要明白一个问题，锁的作用是什么？我们常说的是保护共享资源。千万别以为是保护代码。lock和unlock之间称之为临界区。
先从最简单的情况考虑吧
1. UP（单核）系统，内核态不支持抢占（CONFIG_PREEMPT=n）。


问题来了，这种情况下有哪些并发源？

1. hardirq
2. softirq
3. 进程

然后明白，进程可以被softirq打断，softirq可以被hardirq打断。OK?
打断可以理解成优先级高低的关系


接下来继续分情况了
a) 如果共享数据时不同的进程之间访问，不涉及hardirq或者softirq访问的话，其实我们什么也不需要做。因为内核态不支持抢占，进程不主动调度就不会有别的进程与之竞争共享数据访问。
b) 如果共享数据在进程和softirq都会访问，这种情况下需要local_bh_disable。bh关了，就不会有softirq打断进程，自然就不会有并发源。
c) 如果共享数据在进程和hardirq都会访问，这种情况下需要local_irq_disable。bh关了，就不会有hardirq打断进程，自然就不会有并发源。
d) 共享数据只在softirq上下文访问，什么也可以不做。因为单核不存在多个softirq并发。
e) 共享数据只在hardirq上下文访问，什么也可以不做。因为中断不支持嵌套。
2. UP（单核）系统，内核态支持抢占（CONFIG_PREEMPT=y）。
a) 如果共享数据时不同的进程之间访问，不涉及hardirq或者softirq访问的话，我们需要关抢占。防止进程之间并发。
b) 如果共享数据在进程和softirq都会访问，这种情况下需要local_bh_disable。bh关了，就不会有softirq打断进程，自然就不会有并发源。如果数据还会在不同进程之间访问，还需要关抢占。
c) 如果共享数据在进程和hardirq都会访问，这种情况下需要local_irq_disable。irq关了，就不会有hardirq打断进程，自然就不会有并发源。irq关了，其实抢占也关了。
d) 共享数据只在softirq上下文访问，什么也可以不做。因为单核不存在多个softirq并发。
19:59
e) 共享数据只在hardirq上下文访问，什么也可以不做。因为中断不支持嵌套。

所以你看到spinlock在UP系统的实现只需要关抢占。
spinlock在UP系统承担的角色就是防止不同进程并发
现在我们上升到MP系统（多核系统）。
首先需要明白，关抢占和关中断，都只能关闭local cpu的抢占和中断。
在MP系统下，并发变得复杂。中断可能并发（更准确来说是并行），softirq可能并发，进程也同样可以并发。这些都可以在不同CPU上并行执行。因为MP下，我们有多个执行单元，可以做到真正意义上的并行执行。
20:06
a) 先考虑最简单的情况，只有多个进程访问共享数据。不涉及softirq/hardirq。我们依然只管抢占可以吗？

关抢占后，禁止了本地CPU的进程并发。无法阻止其他CPU带来的并发。其他CPU依然可以并行执行其他进程同时访问共享数据。

所以我们需要额外的操作，保证多CPU不会并发。这个操作就是spinlock去除关抢占部分剩余的部分。


hardirq和softirq在多个CPU都可能并行执行，所以只关中断是不行的。那就借助一个变量flag，假设flag等于1时代表lock，等于0时代表unlock。多个CPU之间就通过flag防止并发。
这也是最初的spinlock的时候，一个变量两个状态值
最后发现有饥饿想象，改成了ticket spinlock
20:37
然后又发现更多核的系统下，多核cache一致性同步性能太差，再改成现在的qspinlock

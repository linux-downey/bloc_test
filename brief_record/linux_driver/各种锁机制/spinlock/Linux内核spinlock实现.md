# linux 内核 spinlock 的实现
在内核中，共享对象的互斥处理向来是个非常麻烦的问题，这种麻烦是源自于 linux 内核中复杂的并发机制，这种并发有可能是单核上多进程（线程）之间的伪并发、也可能是 SMP 架构中的真实并发，再考虑到中断和下半部机制的情况，并发编程变得非常复杂。  

在并发编程中，对共享数据加锁，这是一个最基本的共识，在 Linux 内核中支持各种各样的锁机制，以满足各种各样的并发情况，并没有哪一种锁机制能适用于所有的并发情况，即使有，那么这种锁机制肯定只是能用，而不是适用。毕竟，生活经验告诉我们：兼容性和针对性之间只能二选其一，兼容性带来更广的应用范围，而针对性带来更高的效能发挥。  

在所有的锁机制中，spin lock 和 mutex lock 是应用最为广泛的，如果一个进程请求某个临界区的资源，当请求不到时陷入睡眠状态，直到临界区资源重新开放可用时再进行处理，这是相当实用的做法，节省了 CPU 的运行资源。  

但是在某些情况下，mutex lock 并不合适：

一方面，从微观的角度来说，进程的切换尽管耗时很少，通常在 us 级别，如果程序员确定进入临界区的时间要小于这个时间，比如仅仅是置一个标志位，进程切换的开销相对来说就是不划算的。 

另一方面，通常也是开发者不使用 mutex lock 的原因，就是在中断上下文中不能睡眠，这是一个硬性条件，这个时候就需要使用 spinlock 来实现共享对象的互斥访问。  


## spinlock
spinlock 中的 spin 是旋转的意思，当进程对 spinlock 保护的临界区没有访问权，通俗地讲也就是无法获得锁时，就会原地打转等待资源，当然这个等待的过程伴随着不断地去查询是否能获得锁。  


### spinlock 的接口以及使用
spinlock 的使用是相当简单的，主要是三个过程：初始化锁、加锁、解锁。  

对应的编程接口为：

```c++
spinlock_t lock;         //定义 spinlock 变量
spin_lock_init(&lock);   //初始化 spinlock,或者直接使用 DEFINE_SPINLOCK 接口实现 定义+初始化
spin_lock(&lock);        //获取 spin_lock（也有给临界区加锁的说法），该接口会一直等待直到获取到锁
spin_lock(&unlock);      //解锁，被加锁的临界区只有在解锁后其它进程才可以进入。  
```

和 mutex 一样，spinlock 是二义锁，lock 和 unlock 需要成对出现，同时，需要注意的是，不要嵌套使用 spinlock，这会直接导致死锁。  
除了最基本的使用接口之外，还支持以下的接口以供在特殊情况下使用：

```c++
spin_lock_irq()      spin_unlock_irq()
spin_lock_irqsave()  spin_unlock_irqstore()
spin_lock_bh()       spin_unlock_bh()
spin_is_locked()     
```

spin_lock_irq 和 spin_unlock_irq 成对出现，表示在使用 spinlock 的同时禁止中断
spin_lock_irqsave 和 spin_unlock_irqstore 成对出现，同样是禁止中断，并将中断状态保存起来
spin_lock_bh 和 spin_unlock_bh 成对出现，表示禁止下半部
spin_is_locked 接口用于查询当前的 spinlock 是否已经被加锁   

对于 spin_lock_irq 和 spin_lock_irqsave 的区别，这和其它的 *irq 和 *irqsave 接口一样，前者是单纯地禁止本地中断，在 arm 架构上就是通过设置 CPRS 的 I bit 屏蔽中断接收，后者是在禁止本地中断之前保存中断状态，在屏蔽 CPSR 的 I bit 之前，会先保存 CPSR 寄存器的值到变量 flags 中。它们的实际区别在于：如果存在嵌套地 disable 中断行为，就需要使用 spin_lock_irqsave 接口，这是因为 spin_unlock_irq 接口是无条件地开启中断，如果在程序中禁止了两次中断（禁止中断并不一定是调用了 spin_lock_irq 接口，也可能是其它的 *irq 接口），而调用 spin_unlock_irq 一次就开启了中断，这明显是不符合开发者意图的。spin_unlock_irqstore 是回复到上次的中断状态，而不是直接无条件的开启中断。  

至于 spinlock 与中断或者其它并行执行流之间的纠葛以及什么时候该使用什么样的接口，我们接着看下文。  


## spinlock 涉及的并发情况
在分析 spinlock 之前，先考虑一个问题：如果让你来实现 linux 中的 spinlock，你会怎么做？  

本质上来说，全局对象需要使用锁来保护的原因是并发的产生，如果是单一的执行流，不需要考虑使用锁来做数据保护，所以第一个需要思考的问题是：spinlock 的使用过程中会有哪些并发的产生？  
* 内核的抢占
* 中断的抢占
* 下半部的抢占
* SMP 架构中的并发

### 内核抢占
linux 默认支持内核抢占，这个特性使得当前进程的执行可以被其它内核进(线)程抢占执行，这种抢占并不是无时不刻都在进行的，而是存在一些抢占点，比如从中断处理函数返回到内核中，比如调用 preempt_enable 使能内核抢占，因此可能出现这样的情况：

内核进程 A 正在执行，并获取了一个 spinlock，此时发生了中断并跳转到中断服务程序中，在中断中一个更高优先级的进程 B 被唤醒，在中断返回时 B 会抢占 A 并执行，如果这时候 B 也请求同一个 spinlock，问题就来了：B 因为请求不到 spinlock 而一直自旋，而占用 spinlock 的 A 因为被 B 抢占而得不到执行，无法释放 spinlock。  

因此，对于自旋锁而言，内核抢占是一个明显的风险点，作为最简单的处理，需要在使用自旋锁之前，就禁止内核抢占。  

## 中断抢占






# mutex lock
spin lock 是在 linux 内核中实现的一种忙等机制，本质上是对 mutex lock 的一种优化，对于那些执行时间非常短的临界区而言，没有必要让进程进入休眠，因为进程切换的开销可能远大于临界区执行时间，因此就设计了 spinlock 的机制代替 mutex lock 来提升锁的性能。  

而对于更小的共享对象操作，比如单个 int、long 类型的共享变量的操作，则通过原子操作来实现，这是架构相关的。   

mutex lock 本身在操作系统领域是一个通用的概念，不仅仅是 linux 中，对于其它的操作系统同样提供了 mutex lock，其操作接口基本上是一样的：使用互斥的临界区保护共享对象，当临界区被其它进程占用时，尝试进入的临界区的进程进入休眠，等待占用者退出临界区，这个占用和退出的过程对应 mutex 的加锁和解锁。  

对于 mutex 而言，尽管各操作系统之间对外的接口几乎一致，但是其具体的实现一般不同，本章节就是讨论 linux 内核中 mutex lock 的实现。    


# 互斥锁
抛开 linux 的实现，从通用的角度来看 spinlock 和 mutex lock 这种二义性的锁，它们的基本特性也比较简单：
1、加锁和解锁由同一个进(线)程完成
2、使用一个状态标志，通过这个标志来控制、判断加解锁
3、实现排队机制，作为同样等待的进程，先进入等待的先获取锁

通过这三点，可以发现通用的二义性互斥锁的实现其实是比较简单的，使用一个结构体来描述所有成员，结构体的成员包括：
* 当前进(线)程识别号
* 加解锁状态标志
* 排队结构体，通常是链表

## mutex 的使用
mutex lock 和 spin lock 都属于互斥锁一类，是二义性的锁，对应的操作接口也是非常简单：

* mutex_init()
* mutex_lock()
* mutex_unlock()

这三个接口分别对应初始化、加锁、解锁，

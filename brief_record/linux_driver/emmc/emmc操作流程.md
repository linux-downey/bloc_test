# emmc 设备识别流程:
主机发送 CMD0 让 emmc 进入到 idle state
通过 CMD1 来验证电压
如果上一步的返回是 r1b，表示 emmc 还没有准备好，还在上电阶段，重复上一步，直到 emmc 不在 busy 状态
使用 CMD2 通知总线上的所有设备发送自己的 CID 寄存器信息
使用 CMD3 依次给每个总线上的 emmc 分配地址，直到所有 emmc 设备地址分配完成。  

进入 idle state 有是三个条件：
1、boot 操作已完成。
2、CMD 没有拉低超过 74 个 clock，也就不会进入 boot 模式。 
3、重启后设备不支持 boot 模式。 

主机是怎么一个个地识别设备的：
当从设备接收到设备发出的 CMD2，所有从设备同时在 CMD 线上一位一位地发送 CID，此时，CMD 被配置为开漏输出，当 CMD 线上的电平和从机自己发出去的电平不一致时，从机立马停止发送。  
这里利用了引脚开漏输出的线与功能，只要有一个设备发送低，CMD 线就是低，其它发送高的设备就知道自己应该停止发送了。  


# 写一个 block 流程（am1808的操作）
1、发送 emmc 地址选择指令
2、设置需要操作的开始地址
3、读 card 的 CSD，以确定 card 的最大 block 长度
4、使用 SET_BLOCKLEN emmc 命令设置传输长度，如果这个长度和之前设置的不一样，需要是 512 的倍数
5、RESET fifo
6、设置 FIFO 方向
7、设置访问宽度
8、使能 mmc 中断
9、写开始的 32 bytes 到 数据传输寄存器
10、使用 WRITE——BLOCK 命令写指令
11、写寄存器，开始传输
12、等待中断
13、通过状态寄存器检查错误并解决错误

# 通过 edma 写单个 block（am1808的操作）
1、将其实地址写入寄存器
2、读 CSD 寄存器
3、使用 SET_BLOCKLEN emmc 命令设置传输长度，如果这个长度和之前设置的不一样，需要是 512 的倍数
4、RESET fifo
5、设置 fifo 方向
6、设置访问宽度
7、设置 fifo 阈值
8、设置 DMA
9、使用 emmc 的 cmd WRITE _BLOCK 到 emmc 设备
10、设置 DMATRIG 指令，开启传输
11、等待 DMA 传输事件
12 使用 MMCST0 检查错误。 

后续还有读单个 block，读写多个 block







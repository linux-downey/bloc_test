# linux 内核常用宏 —— likely 和 unlikely

## 程序的编译
嵌入式相关的开发人员或多或少地对程序的编译有一定的了解，大部分工程师都清楚，程序的编译分为四个部分：
* 预处理 ： 处理宏的展开和头文件的包含
* 编译 ： 将预处理完成的代码编译成汇编代码
* 汇编 ：将第二步中生成的汇编代码生成机器码
* 链接 ： 将模块化编译的目标代码链接生成机器上可执行的代码

这四个部分就是处理从源代码到可执行代码的一个完整流程。  

事实上，程序的编译是一个非常复杂的环节，上述四步中的每一个步骤背后都处理着各种复杂的情况。  

而这一章节所介绍的 likely 和 unlikely 宏，可以理解成一个辅助编译的宏，它的作用是对处理代码进行优化。

****

## 程序编译阶段的优化
如果你对编译器有那么一些了解，就清楚地知道：不管你愿不愿意，程序在编译阶段都会对代码进行优化，大多数情况下，这种优化都是对存储空间以及运行时间上的改进。  

但是，有时候这种优化也会带来一些副作用，关于优化带来的问题以及解决方案可以参考我的另一篇博客[原子操作、volatile、CPU执行顺序](http://www.downeyboy.com/2018/12/01/system_sync_mech/)。  

这种优化的粒度是可以控制的，在 gcc 中，我们可以使用以下的指令来查看编译器提供的优化选项

```
gcc -Q --help=optimizers
```

通常情况下，我们会使用到以下的优化选项：
* -O0：事实上这个选项不需要显式提供，它是默认的选项，规规矩矩地进行编译，且提供预期的 debug 结果，也就是源码和可执行文件的对应程度是最完整的，如果需要对程序进行 debug，最好不要进行优化，且提供 -g 选项专门编译调试模式下的可执行文件
* -O，-O1：提供有限度的优化，减少代码的 size 并且提高程序的运行效率。
* -O2：这是一个被广泛应用的优化选项，同时也是久经考验的，这种情况下的优化不仅提供指令集的优化，还会对部分代码进行顺序重排以适应现代 CPU 的特性：比如乱序执行、流水线技术，缓存技术。缺点是编译时间变长。    
* -O3：虽然理论上来说优化等级比 O2 高，官方的解释也是比 O2 的优化力度更强，但是这个选项并没有广泛接受，因为它并不稳定，最终的优化效果甚至有时候还不如 O2。
* -Os：针对代码的 size 进行优化
* -Ofast：针对代码的执行速度进行优化
* -Og：针对 debug 的用户体验进行优化

关于 gcc 优化选项更详细的信息可以参考[官方文档](https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html)。  

****

## likely 和 unlikely
在linux 内核中，经常能见到 likely 和 unlikely 的身影，事实上，这两个宏并不对程序的执行流产生任何影响，仅仅是提供优化信息给编译器。  

它通常的用法是这样的：

```
if(likely(expr)){
    ...
}
else{
    ...
}
```

要了解它是怎么工作的，那么最好的办法就是看源代码：

```
#define unlikely(x)    (__builtin_expect(!!(x), 0))
#define likely(x)    (__builtin_expect(!!(x), 1))
```

定义非常简单，在 __builtin_expect(!!(x), 0) 中，__builtin_expect 是 gcc 中的一个內建函数，传入两个参数，第一个参数为表达式，第二个参数为第一个参数趋向的结果。  

而函数本身则不做任何事，也就是说，但从程序逻辑来说,下列三者是等价的:
* if(unlikely(value))
* if(likely(value))
* if(value)

更通俗地讲，就是告诉编译器表达式 x 的结果大概率是第二个参数，这到底有什么用呢？  

对于汇编代码的层面来说，处理程序中 if-else 的分支，一般情况下，if 分支下的代码紧跟着程序上文，而执行 else 部分则需要调用到 jmp 指令跳转到 else 分支的代码中，如果我们的代码中 else 部分或某个分支有更大的可能被执行，那么每次执行到分支时，都需要执行跳转，如果这部分是核心代码，这将会对执行效率产生影响。  

而一旦一个分支由 likely 描述，最基本的优化是：编译器会将更可能被执行的分支紧跟着程序上文，从而不需要跳转。而 unlikely 相反，它表示括号中的表达式结果更可能是 1 。  

****

## 示例
下面我们来看一个示例，毕竟光说理论总归是苍白的：

```
  1 #include <stdio.h>
  2 
  3 #define unlikely(x)    (__builtin_expect(!!(x), 0))
  4 #define likely(x)    (__builtin_expect(!!(x), 1))
  5 
  6 int x=1;
  7 int main(void)
  8 {
  9     if(unlikely(x)){
 10         x++;
 11     }   
 12     else{
 13         x--;
 14     }   
 15 }
```

源码很简单，就不啰嗦地介绍了，这次调试的思路是：将源码编译成汇编代码，再从汇编的角度来查看结果。  

需要注意的是，编译的时候需要加上优化选项 -O2，默认编译等级并不对 __builtin_expect 进行处理，下面是编译指令：

```
gcc -c main.c      // 生成 main.o
objdump -S main.o  //输出汇编代码到屏幕，使用objdump生成的反汇编比直接生成的汇编代码更清晰
```

结果是这样的：

```
1 0000000000000000 <main>:
  2    0:   8b 05 00 00 00 00       mov    0x0(%rip),%eax        # 6 <main+0x6>
  3    6:   85 c0                   test   %eax,%eax
  4    8:   75 0d                   jne    17 <main+0x17>
  5    a:   c7 05 00 00 00 00 ff    movl   $0xffffffff,0x0(%rip)        # 14 <main+0x14>
  6   11:   ff ff ff 
  7   14:   31 c0                   xor    %eax,%eax
  8   16:   c3                      retq   
  9   17:   83 c0 01                add    $0x1,%eax
 10   1a:   89 05 00 00 00 00       mov    %eax,0x0(%rip)        # 20 <main+0x20>
 11   20:   eb f2                   jmp    14 <main+0x14>

```

其中第三行， test 表示测试条件，对应 if 判断语句，在上述的程序中，紧随着 if 判断语句的是 x++，但是这里换成了第五行：

```
  5    a:   c7 05 00 00 00 00 ff    movl   $0xffffffff,0x0(%rip)
```

这一条汇编语句对应 x--，编译器同样做了优化，因为编译器发现使用 sub 指令比直接赋值 0xffffffff 要慢，而且两者执行结果等价，从这里可以看出编译器分析上下文以及优化代码的能力了。  

而对应的 x++ 指令则被放到后面：

```
 9   17:   83 c0 01                add    $0x1,%eax
```

从整个分析可以看出，源码中由于在 if 分支使用了 unlikely，导致原本 if-else 部分的分支代码发生了替换，既然用户提示编译器 else 部分的代码更可能被执行，那么编译器就将 else 部分的代码放到更"趁手"的地方。  


****


# linux中断子系统 - arm gicV2 简介

起初对于中断的了解，仅仅是外设产生中断，CPU 接受中断，随着对中断的深入学习，发现事情并非这么简单，在一个系统上，外设的中断可能出现几十甚至上百个，而 CPU 对应的中断引脚寥寥无几，对于 arm 来说，仅有 FIQ 和 IRQ 两根中断线。   

那么，问题就来了，这么多的中断是怎样被管理的？这就涉及到我们一直在使用，但是很少关注的一个硬件控制器：中断控制器。顾名思义，这个硬件控制器的主要作用就是管理外设控制器与CPU之间的中断信号的传递，需要达到的目的是让 CPU 能有条不紊地处理每一个硬件产生的中断。  

一方面，中断控制器向下连接所有的硬件控制器，接收硬件控制器传递过来的中断信号，另一端向上连接 CPU，将硬件控制器传递过来的中断信号转发给 CPU：



中断控制器就是如此简单，但是将其放到一个系统中就会涉及到一些更复杂的问题：
* 接收和转发中断是如何与外部进行交互的？
* 在多个中断同时产生时，中断控制器是如何处理竞争关系的？
* 针对系统的实时性，每个外设应该对应不同的优先级，这个优先级是如何制定的？是否支持外设中断的嵌套？
* 如何支持多核的系统？
* 如果硬件中断数超过一个中断控制器的控制上限，应该采取什么样的策略。

在这一章，我们就来寻找这些问题的答案，总的来说，汇聚成一个问题就是：中断控制器是如何实现的？  

## 早期的中断控制器
传统的的可编程中断控制器比如 8259A，支持 8 个中断 IRQ 输入线，向上连接 CPU 的 IRQ 引脚，它可以对中断进行优先级排列，当多个中断同时发生时，将更高优先级的中断发送给 CPU。同时还能选择性地多中断进行屏蔽。  

当外设中断的数量超过 8 个时，使用两个 8259A 芯片级联的方式进行扩展，也就是第二个 8259A 被视为一个"普通的外设"连接到第一个 8259A 的中断引脚上，只是这个"普通的外设"的作用同样是接收和上报中断,上报的目的地从 CPU 变成了父级中断控制器。  

## arm中断控制器
随着软硬件的发展，中断控制器的功能也强大了很多，而且市面上的中断控制器类型也百花齐放，目前，基于 arm 核的处理器在消费市场独占鳌头，同时，arm 也推出了中断控制器标准，GIC（Generic Interrupt Controller）是ARM公司提供的一个通用的中断控制器规范，其architecture specification目前有四个版本，V1～V4。  

虽然，每一类中断控制器软硬件设计上都有一些差别，但是其本质上还是服务于中断的管理，我们只要摸清楚一款现代中断控制器的实现，弄清楚其原理，对于其它种类的中断控制器其实是一通百通的。   

所以，这一章我们基于 arm GICv2 规范来分析一个中断控制器到底是如何实现的。  

## GIC v2
GIC v2 只是 arm 推出的一个中断控制器规范，就像它的内核业务，只负责卖 IP 核，不负责生产 CPU，而中断控制器也一样，arm 提出中断控制器的规范，而具体的实现同样是由厂商来做，

GIC v2 算是一个比较折中的版本，它既包含了现代中断控制器的一些必要功能，又没有 v3、v4 版本那样的复杂性，因为我们主要关注核心的中断部分，所以对于 GIC 的扩展功能：security extension 和 virtualization extension 就不做探讨，安全和虚拟化的实现是非常复杂的，博主暂时也没搞明白，能力有限，见谅。  

(注：本文所有的内容都来自[官方手册](https://developer.arm.com/docs/ihi0048/b/arm-generic-interrupt-controller-architecture-version-20-architecture-specification)：ARM Generic Interrupt Controller Architecture version 2.0)

### GIC v2 的特性
作为一个现代化的中断控制器，GIV v2 具有以下的特性：


#### 支持多种中断类型
在 GIC v2 中，涉及到多种不同的中断类型，主要包括 SPI、PPI、SGI。

SPI(Shared Peripheral Interrupt)：共享中断，也就是我们最常接触到的那一类外设中断，比如串口、GPIO中断。对于每个外部中断，可配置触发方式为边沿触发、电平触发  

PPI(Private Peripheral Interrup):私有中断，共享和私有其实是针对于 CPU 的概念，共享表示所有 CPU 可见，可执行，而私有中断则只绑定于特定的 CPU。  

SGI(software generated interrupt):SGI 并不属于外设中断，因为它不需要硬件触发，而是由软件生成的，通过写 GIC 的寄存器来触发一个软件中断，同样会被转发到 CPU 进行处理。


#### 多核的支持
一个 GIC 最多支持 8 个核，涉及到 SMP 自然就涉及到中断分发的支持，中断的分发策略并不是由中断控制器来决定的，而是由内核实现，中断控制器只需要能够对中断分发服务提供资源的支持，比如对每个 CPU 分配一个接口负责管理中断控制器与 CPU 之间的数据交互，比如为每个 CPU 提供寄存器副本。  


#### 中断输入信号
GIC v2 针对不同的中断类型，一共支持 1024 路中断信号，分别被排序为 ID0~ID1023。  

其中：
ID0~ID15 对应 SGI，也就是软件产生的中断。
ID16~ID31 对应 PPI，也就是 CPU 的私有中断。
ID32~ID1019 对应 SPI，也就是我们常用的外设硬件中断。
ID1020~1023 保留作为特殊用途，比如作为虚假中断，在异常时被传递。

同时，对于中断的输入信号，可以指定地进行 enable 和 disable，相对于 CPU 的中断 disable，GIC 的中断 disable 情况有所不同。  

CPU 级别的中断 disable，指的是在这段时间内暂时不处理中断，恢复中断时中断不会丢失，而中断控制器选择屏蔽某个中断线，则不会接收该中断线的触发信息，中断会直接丢失。  


#### 系统睡眠时唤醒
在系统睡眠时，GIC 可以支持产生唤醒事件将系统唤醒，GIC 的唤醒需要电源管理系统的支持，同时 GIC 内部寄存器为电源管理应用程序中的状态保存和恢复提供支持。  



## GIC 的结构
GIC 内部被分成两个部分：distributor 和 CPU interface，从名称上来看，一个是分发器，也就是负责中断的分发，一个是 CPU 接口，用于与特定 CPU 的交互。  

要理解为什么会产生这样的内部结构也不难，对于 SMP 架构而言，外设中断(或者 SGI)的输入需要被转发到 CPU 上执行，这时候的中断有两种处理模型：

* 1-N 的处理模型
* N-N 的处理模型

对于 SPI 而言，产生的中断会被发送到一个 CPU 上执行，其它的 CPU 则不再处理





# Linux 中 对pwm 设备的使用
PWM，全称为"脉宽调制输出信号"，在嵌入式开发中，这是一类非常基本的引脚输出方式，pwm 输出信号也就是我们口中常说的"方波"。  

在 Linux 的驱动开发中，通常会有 pwm 驱动的开发需求，比如简单的呼吸灯控制、或者复杂一点的电机控制。   

如果你完全不了解它准备去了解它，那么我建议你先了解它是什么，然后再深入到 Linux 的 pwm 内核框架中。  

## pwm 裸机控制
通常，pwm 控制器都是集成在 CPU 里的，直接连接在系统总线上，所以可以直接通过内存寻址，以操作寄存器的方式来操作 pwm 控制器所提供的接口。  

pwm 控制器被编址在 CPU 对应的哪一部分内存完全是由厂商来决定的，我们只需要知道，当我们有操作一个平台上 pwm 的需求时，先通过手册查到 pwm 对应的寄存器地址，然后根据寄存器列表去配置它。通常，pwm 信号的输出依赖于定时器提供时钟，同时需要配置定时器。配置完成之后，pwm 信号就会在指定的引脚上输出。    

在某些时候，当我们有大量的 pwm 输出需求时，需要外部扩展多路 pwm，这种扩展的 pwm 芯片和内置的 pwm 是有本质区别的，这类芯片需要通过板级协议(i2c、spi等)进行控制输出，而不能直接接在 CPU 的系统总线上，读写 pwm 芯片寄存器的方式也由直接寻址变成了通过预定的通信协议字段交换数据。  

涉及到 pwm 的控制一般有几个概念：
* period: 周期,由于 pwm 输出是方波，表示多长时间一个方波，周期的倒数是频率，表示每一秒有 1/period 个方波。
* cycleduty: 占空比，在每一个周期中，高低电平占有的比例。
* polarity: 极性，确定有效电平

## Linux 中的 pwm 
pwm 的操作本身是简单易用的，而且它的配置通常不复杂，即使是在 Linux 上，要操作 pwm 或者编写一个 pwm 控制驱动都是比较简单的事，而复杂的 pwm 内核框架实现我们后续再讨论。  

老规矩，先了解它怎么用，然后再深入了解它的实现机制。

### pinmux 的设置
pwm 的输出最终体现到引脚上，既然是引脚输出，那就不得不面临一个麻烦的问题：引脚的 pinmux 设置。毕竟，各种外设需要的引脚数量是非常庞大的，在软件复杂度的控制和成本控制之间做选择并不会太难，厂商总是选择成本控制，所以通常情况下，一个引脚的 pad 都会复用为好几个外设的输入输出引脚。    

在驱动调试过程中，要做的第一件事就是设置正确的引脚 pinmux，具体的设置方法通常是在设备树中进行指定，具体的设置方法可以参考我的另一篇博客：TODO

做这一类事情向来是需要非常细心的，好在 Linux 给我们提供了系列的接口以便我们对这些配置进行检查。  

对于，pinmux 的设置，我们可以参考下面几个文件：



### /sys 目录下的 pwm 操作
如果你不是一个 bsp 工程师，在日常的开发中，操控一个 pwm 引脚设备甚至不需要我们进入到内核层面，在常见的开发板中，比如：树莓派、beaglebone 以及各大厂商为自家开发板提供的开发包中，其中就包含了部分引脚的 pwm 驱动，我们可以直接通过 /sys 目录对应对其进行操作。 

比如



但是，看似简单的东西，到了 Linux 上，总会变得相对复杂，Linux 上总是会考虑到兼容性、扩展性这些系统层面的东西，所以通常是以框架的方式来实现。  

在这篇文章中，博主并不准备讨论 pwm 驱动在内核中的实现



# cpu 拓扑结构
在研究 cfs 调度器的时候,碰到一个难缠的问题:进程迁移,进程的迁移总是发生在多核之间,在之前对其它内核组件的分析中,比如内核中的锁,往往是把"多核"或者 SMP 当成一个黑盒子,所讨论的都仅仅是需要多考虑一种多核的并发情况.   

但是,在分析进程的迁移时,再把多核架构对应的软件处理当成黑盒子就不合适了,因为多核系统的内部架构将直接影响到进程在核心上的调度行为.  


## 硬件上的多核架构
在 linux 内核中,软件架构总是基于硬件的抽象,因此,想要研究内核中的软件实现,第一步需要做的就是先弄清楚硬件上是怎样的.  

对于 cpu/多核 这些概念是硬件强相关的,不同的体系架构自然是天差地别,最常见的 x86 架构几乎统治了个人电脑和服务器两个领域,对于这两个领域,一个要求响应速度,一个要求吞吐量,因此对于基于 x86 的平台而言,高主频,超标量,超线程,多级流水线这些都是常见配置,因为这些东西可以实实在在地提升一台主机的程序执行速率.  

另一方面,移动端的兴起让主打低功耗的 arm 架构获得市场的青睐,就目前而言,arm 的特性在于 cpu 的程序执行效率和功耗之间的平衡,不需要太高的主频,cpu 也不会集成大量的运算器件,同时精简指令集也可以简化硬件的设计,以至于 arm 和 x86 在不同的领域各自为王.但是,目前已经在移动领域站稳脚跟的 arm 也不再满足于现状,开始向服务器领域进军,至于未来会怎样,time will tell.  

尽管不同的架构针对不同的领域有不同的硬件设计,但是对于效率的追求总是不变的,在主频的提升遇到瓶颈之后,各个架构都不约而同地转向了多核架构的研究,而一旦打开了多核设计这个潘多拉魔盒,事情就变得一发不可收拾起来.  

在多核设计中,不得不提的另一个概念是缓存技术,缓存是很早之前就存在的一种设计思想,比如仓储的设计,被应用在计算机中,从一台完整电脑的角度来看,cpu 内部寄存器是 cpu cache 的缓存,cpu cache 是内存的缓存,内存是磁盘的缓存...  

不得不说,缓存和多核这两种技术对 CPU 性能提升是巨大的,对于硬件设计人员来说这是两把利器，俗话说，死道友不死贫道，硬件设计人员圆满地完成 KPI 的同时，软件工程师面对越来越复杂的硬件所带来的复杂性，发际线越来越高，毕竟在已有硬件升级的前提下，软件工程师的工作就是修改软件，重新适配硬件，没有合适的软件，硬件只是一堆带电的元器件，而需要发挥 多核+多级缓存 的性能优势，软件工程师需要十分相当的功底。  

一个基本的 cpu 中通常包含 总线、寄存器组、ALU 以及可选的 MMU、浮点计算器、协处理器等器件，这些器件完成 CPU 的基本工作，或是控制，或是运算，其本质都是对于数据的处理，每个 CPU 内部器件通力合作，在一个指令周期内完成一条具体的指令，这条指令可能是更新内存，也可能是做逻辑运算。   

可以想到，在这种情况下，影响指令执行效率的因素就是 CPU 的指令周期大小，也就是常说的 cpu 主频，cpu 内所有的元器件都根据 cpu 的 clock 进行同步，提高 cpu 的主频自然而然成了提升 cpu 的一个主要途径，但是执行一条指令需要经过取出指令、译码器进行译码、再将具体指令送到 ALU 或者寄存器其它部件等多个步骤，而 cpu 的一个 clock 至少要等到一条完整的指令操作完成，才能发起下一个 clock，，在这种情况下，主频的提升上限受到硬件的限制。  





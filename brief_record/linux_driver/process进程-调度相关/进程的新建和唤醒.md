# linux 调度之进程的创建与唤醒
除了核心的周期性调度和主调度器之外，进程创建和进程唤醒时调度相关策略的实现也值得关注，进程的新建是一切的开端，而进程的睡眠唤醒也是非常重要的，毕竟系统中几乎所有进程都是不断地处于 睡眠-唤醒 的循环过程中。  


## 新建进程的调度设置
fork 创建新进程时，大部分资源都是从父进程复制过来的，调度方面也不例外，用户进程的 fork 发起内核中对应的 fork 系统调用，fork 将调用 _do_fork，在 _do_fork 函数中，首先会调用 copy_process 为子进程创建并初始化一个 task_struct 结构，进程描述符中大部分内容都是从父进程 copy 过来的。  

其中，对于调度相关的 copy 为 sched_fork 函数：

```c++
int sched_fork(unsigned long clone_flags, struct task_struct *p)
{
    ...
    int cpu = get_cpu();
	__sched_fork(clone_flags, p);             ...............................1

    p->state = TASK_NEW;
    p->prio = current->normal_prio;

    if (unlikely(p->sched_reset_on_fork)) {   ................................2
		if (task_has_dl_policy(p) || task_has_rt_policy(p)) {
			p->policy = SCHED_NORMAL;
			p->static_prio = NICE_TO_PRIO(0);
			p->rt_priority = 0;
		} else if (PRIO_TO_NICE(p->static_prio) < 0)
			p->static_prio = NICE_TO_PRIO(0);

		p->prio = p->normal_prio = __normal_prio(p);
		set_load_weight(p);

		p->sched_reset_on_fork = 0;
	}

    if (dl_prio(p->prio)) {                     ..............................3
		put_cpu();
		return -EAGAIN;
	} else if (rt_prio(p->prio)) {
		p->sched_class = &rt_sched_class;
	} else {
		p->sched_class = &fair_sched_class;
	}

    __set_task_cpu(p, cpu);                    ...............................4
	if (p->sched_class->task_fork)
		p->sched_class->task_fork(p);
	raw_spin_unlock_irqrestore(&p->pi_lock, flags);

#if defined(CONFIG_SMP)                        ...............................5
	p->on_cpu = 0;
#endif
	init_task_preempt_count(p);
#ifdef CONFIG_SMP
	plist_node_init(&p->pushable_tasks, MAX_PRIO);
	RB_CLEAR_NODE(&p->pushable_dl_tasks);
#endif

	put_cpu();
}
```










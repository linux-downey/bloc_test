# 设置进程调度属性
linux 中的进程在创建之初就确定了其调度属性，包括它所属的调度器、优先级，但是这些并不是完全静态的，用户可以通过特定的接口修改它们，这一节来讨论如何对进程的调度属性进行动态地设置，以及这些设置将会引发的调度行为。 

## nice
nice 值是对用户进程优先级的描述，这是 linux 诞生之初就使用的方式，nice 值的范围是 -20~19，值越大优先级越小，这个取值范围着实有点让人摸不着头脑，按照计算机中的编程惯例，要么将负数排除在外，要么将 0 排除在外，因为这样处理起来会显得更优雅、更方便，为什么使用这么一个区间？真相已经淹没在历史的长河中了，而且为了兼容之前的代码，nice 的取值以及用法也就沿袭了下来。  

nice 值只有 40 个取值范围，很明显只对应于用户进程的优先级，在内核的调度行为中，并不使用 nice 值，相对应的使用 static_prio 来替代 nice 作为进程的优先级表示，并且直接提供 nice 与 static_prio 的转换，static_prio 的 100~139 对应 nice 值的 -20~19，其它的对应实时进程的优先级。  

用户程序可以通过 nice 值调整当前进程的优先级，可以通过 man 2 nice 查看 nice 接口：

```c++
int nice(int inc);
```
nice 接收一个 increment 参数，该函数将在当前进程 nice 值的基础上增加 inc 个 nice 值，可以传入负数，表示降低 nice 值，提升进程优先级。  

成功返回新的 nice 值，失败返回 -1，但是有意思的是，正确的返回值也可能是 -1，如果返回 -1，还需要去判断全局变量 error 来确定是正确返回还是错误返回。  

对于普通用户而言，只能加大 nice 值，也就是降低优先级，如果需要减小进程的 nice 值，需要系统权限，或者需要对当前进程的资源限制进行特殊的配置。  

glibc 中的 nice 函数会发起一个系统调用，对应内核中的 nice syscall:

```c++
SYSCALL_DEFINE1(nice, int, increment)
{
	long nice, retval;

	nice = task_nice(current) + increment;
	nice = clamp_val(nice, MIN_NICE, MAX_NICE);

	retval = security_task_setnice(current, nice);

	set_user_nice(current, nice);
	return 0;
}

```
对于 nice 系统调用而言，第一步是做参数的检查以及权限的检查，毕竟对于没有特殊权限的用户，是不能提升进程的优先级的，如果 nice 值的设置超出了允许的范围(-20~19),处理方式就是将其设置为对应的极限值，比如当 inc 为 -80 时，nice 系统调用并不会报错，而是设置为它的极限值 -20。  

完成参数检查之后，就需要调用 set_user_nice 函数，从名称可以看出，这是真正执行 nice 值操作的函数，该函数将在下面的程序中解析。  

## setpriority
nice 的使用方式比较单一，只能针对当前进程进行设置，而不能针对用户组或者用户进行统一设置，setpriority 函数满足了这个需求，与 nice 一样，glibc 中的 setpriority 函数对应内核中的 setpriority 系统调用。  

了解 setpriority 的使用方式，最好的方式同样是通过 man 2 setpriority，它的函数原型为：

```c++
int setpriority(int which, id_t who, int prio);
```
根据 man 手册提供的信息，setpriority 可以为特定进程、进程组以及用户设置优先级，which 和 who 两个参数用来确定需要设置的对象，which 指定是设置哪种类型的对象，有 PRIO_PROCESS/PRIO_PGRP/PRIO_USER,而 who 和 which 相关，用来执行类型对象中的具体对象，如果 which 为 PRIO_PROCESS，那么 who 就应该是指定进程的 PID，同样的，PRIO_PGRP 对应组 ID，PRIO_USER 对应 user id。

而 prio 是需要设置的优先级，和 nice 中的 inc 不一样的是，这个 prio 是本次设置的最终优先级，也就是 prio 为 10 时，目标在设置完成之后优先级就是 10.  

由于 setpriority 支持多种类型对象的优先级设置，对应的系统调用处理也就相对复杂一些，实际上对于进程组和用户这种特殊目标而言，也只是遍历组或者用户中从属的每个进程，再对其依次操作，本质上还是对进程的操作，同时鉴于 setpriority 同样只针对用户进程，而且使用的优先级也是以 nice 值为参考，底层实现其实和 nice 系统调用一样，都是通过 set_user_nice 来对单个或多个目标进程进行操作。  


## set_user_nice
set_user_nice 是内核中用来修改一个进程优先级的接口，接受的参数很简单，第一个是 task 指针，第二个是进程需要设置的 nice 值。对于 nice 系统调用而言，task = current，而对于 setpriority 而言，就不一定了。 
task_nice 的实现并不难：

```c++
nice->set_user_nice:
setpriority->set_one_prio->set_user_nice:

void set_user_nice(struct task_struct *p, long nice)
{
    ...
    rq = task_rq_lock(p, &rf);            ......................................1

    queued = task_on_rq_queued(p);
	running = task_current(rq, p);
	if (queued)
		dequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);
	if (running)
		put_prev_task(rq, p);             ......................................2

	p->static_prio = NICE_TO_PRIO(nice);
	set_load_weight(p);
	old_prio = p->prio;
	p->prio = effective_prio(p);
	delta = p->prio - old_prio;

	if (queued) {
		enqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);
		/*
		 * If the task increased its priority or is running and
		 * lowered its priority, then reschedule its CPU:
		 */
		if (delta < 0 || (delta > 0 && task_running(rq, p)))
			resched_curr(rq);
	}
	if (running)
		set_curr_task(rq, p);
    ...
    task_rq_unlock(rq, p, &rf);
}

```
注：上面的代码省略了一些参数检查、错误处理以及其它调度器的处理，以简化流程便于分析。   

注1：在分析内核中的代码时，得养成一个习惯：时刻注意并发问题，对于 rq 而言，尽管它是 percpu 的，但是并不代表它只会被当前 CPU 访问，当我们唤醒一个进程的时候，很有可能需要把进程 pull 到其它 CPU 上，当我们设置一个进程状态时，也完全有可能这个进程正在其它 CPU 上欢快地运行着，每个 CPU 的 rq 都可能正在被其它 CPU 访问，因此，如果你要操作 rq，请务必小心地给它上锁。

注2：从 cfs 调度算法的角度来说，当重新设置一个运行进程或者已就绪进程的优先级时，最方便的做法就是将让该进程以新设置的参数重新加入调度，也就是先将它从就绪队列中移除，然后像一个新进程一样参与调度，而不是基于历史调度情况去做复杂的增减操作，这样操作既简单，也不失公平。 

如果需要操作的进程在队列上，需要将操作的任务先 dequeue_task，而如果需要操作的进程正在运行，需要对这个进程调用 put_prev_task。  

判断进程是否在队列上通过 p->on_rq 标志位，而判断进程是否运行通过 p->on_cpu 标志位(单核下通过rq->curr == p 来判断)，实际上，一个正在运行的进程是同时满足这两个条件的，一个正在运行的进程与单纯只存在于就绪队列上进程的区别在于运行进程不在红黑树上，通过还有一些标志位比如 cfs->curr,p->on_cpu 的设置。  
当然，如果一个进程正在睡眠中，那就简单了，既不需要执行 dequeue_task 也不需要执行 put_prev_task.  

dequeue_task 在之前的文章(TODO)有解析，对于没有正在运行的进程而言，就是将该进程从红黑树上移除(正在运行进程不需要这一步)，更新时间、设置一些标志位比如 on_rq，同时还要处理可能存在的组调度行为。  

如果进程正在运行，就需要调用 put_prev_task，该函数对调用 task 对应调度器类的 put_prev_task 回调函数，对应 cfs 调度器的 put_prev_task_fair，该函数通常在 schedule 函数中被调用，用于将 cfs 上当前运行的进程设置为非运行状态，如果该进程 p->on_rq 为 1，就把它重新加入到红黑树，否则不加，同时设置 cfs->curr 为 NULL。  






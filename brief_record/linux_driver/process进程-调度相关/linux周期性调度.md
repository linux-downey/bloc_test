# linux 周期性调度 tick
对于目前市面上的大多数操作系统,都存在时间片轮转的调度方式,而使用时间片的初衷在于,系统通过时间片可以很方便地度量一个进程应该运行多久和一个进程已经运行了多久,以此作为唯一的或者辅助的依据来执行任务的调度.   

通常来说,时间片是由 tick 定时器实现的,选取一个固定的时间间隔,产生定时中断,一次中断的产生代表一个时间片的逝去,系统统一在中断处理过程中来对运行进程的时间片进行递减,该进程的可执行时间慢慢地减少直到最后让出执行权.在这里, tick 定时器看起来扮演了一个 timeline(时间刻度) 的角色,所有的进程都参照这个 timeline 进行调度.  

但是,对于调度而言,如果系统仅仅是需要一个 timeline 的话,tick 定时器也不是必须的,硬件上并不缺能够作为 timeline 的 counter,而且事件精度远高于 tick 定时器中断,从上电开始累加,同样地可以作为参照,一个运行中的进程完全可以通过检查 timeline 的方式来确定自己是否需要让出 CPU,而不需要通过系统实现一个 tick 定时器的方式,当然,我们都知道这样不合理,一方面是实现的复杂性,另一方面而言,在调度行为上,不应该依赖于进程的自觉性,而是让系统统一管理.   

因此,一个 tick 定时器的作用在于:
* 提供一个进程视角的 timeline
* 系统通过该 tick 回调函数,对进程以及调度行为进行统一管理

早期版本的 linux 内核中,也存在时间片的调度策略,自从引入 CFS 调度器之后,时间片的概念就从内核中消失了,取而代之的是虚拟时间,调度器通过虚拟时间来确定哪个进程应该投入运行,而虚拟时间并不是以 tick 的时间刻度进行计算的,因此 CFS 调度器中,tick 定时器作为 timeline 的功能被弱化了,只是用来更新 jiffies,jiffies 依旧作为系统中的 timeline.   

tick 中断最大的一个作用在于,周期性地更新系统中的进程信息,然后检查当前进程是否需要调度,检查调度这个行为直接影响到进程运行的时间粒度,







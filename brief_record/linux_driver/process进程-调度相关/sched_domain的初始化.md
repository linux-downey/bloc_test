# linux sched_domain 的初始化
在前面的章节中，介绍了 CPU 拓扑结构以及 CPU 的初始化处理，CPU 的拓扑结构被保存在 cpu_topology 这个结构体数组中，包括 CPU 对应的 cluster_id,core_id 等，对于内核而言，CPU 和内存一样，也被看成一项硬件资源，它被动地接收调度器的安排，负责从内存中取出指令、执行指令、必要的时候将执行结果写回到内存。  

在单核系统中，只有一个逻辑 CPU，针对 CPU 的优化就是在有工作需要处理时尽量地不让它停下来，比如在 CPU 等待资源的时候切换到其它工作。在多核中的逻辑也是一样的，比如在一个简单的双核系统中，目标就是尽量地让两个核都不要停下来，除了单核下的那些优化方法之外，还涉及到另一个问题：如何让工作平均地分配到每个核上。  

系统中程序的最小执行单位为线程，也就是说调度器会将线程或者进程分配到 CPU 上执行，实际上，一个进程从诞生开始，通常都会在睡眠与唤醒之间来回切换，调度器无法预测哪些 CPU 上的进程将会睡眠而什么时候会被唤醒，可能某个 CPU 上的进程已经全部陷入睡眠而其它 CPU 上不堪重负，因此就涉及到一个优化问题：CPU 之间任务的负载均衡，也就是动态地将繁忙 CPU 上的任务迁移到相对空闲的 CPU 上。  

这个迁移的过程涉及到几个问题：
* 什么时候需要迁移？迁移发生在某些特定的场景下，比如 tick 中断、CPU 空闲时。 
* 如何确定哪个 CPU 繁忙而哪个 CPU 空闲？这个统计由调度器完成，调度器可以实时地记录 CPU 对应就绪队列上的负载。  
* 如何确定需要被迁移的任务？找到最繁忙的 CPU 的就绪队列和最空闲的就绪队列，从就绪队列上找到需要迁移的进程。
* 如何进行迁移？一旦确定了要迁移的任务，就直接将任务从源 CPU 的就绪队列上摘下来，放到目标就绪队列上。    

从理论上来说，这三点都是比较简单的，但是对于实际的实现，又涉及到很多非常繁琐的细节处理，比如繁忙和空闲的程度要达到一个什么样的比例才需要迁移？哪些进程不能被迁移？等等.  

在本章中，我们将重点讨论上文中的第一三四点，即确定迁移的进程以及迁移的具体操作，对于第二点 CPU 负载的计算并不详细讨论，这并不是进程迁移的重点。  

## CPU 调度域


## 负载均衡的场景
负载均衡的触发实际上是非常频繁的，在 tick 中断中会尝试执行负载均衡，也就是内核会周期性地检查 CPU 之间的进程间是否平衡，tick 中断的周期由全局变量 HZ 决定，通常是 10ms 或者 4ms，对应的源码如下：

```c++

```


同时，在一个 CPU 上没有可执行的进程时，也就是即将调度执行 idle 进程时，同样将触发负载均衡，这并不难理解，CPU 自己没工作需要执行了，自然要去别的 CPU 上看看有没有多余的工作可以转移过来，对应的源码如下：

```c++
```

上述的负载均衡执行的是整体上的负载均衡，而下面几种情况则是为即将运行的进程选择合适的 CPU，对系统的负载均衡有所贡献，但是并不算严格的负载均衡：
* 在执行 fork 创建子进程时，子进程被第一次调度运行时，将会选择一个合适的 CPU 执行。 
* 在进程发起 execve 系统调用时，将会选择一个合适的 CPU 执行。 
* 当进程被唤醒时，同样会选择合适的 CPU 执行。 






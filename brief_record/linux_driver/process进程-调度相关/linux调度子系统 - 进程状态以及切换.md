# linux调度子系统 - 进程状态以及切换
在 linux 中，各个进程总是伴随着调度的发生从而在各种状态中切换，而状态的切换过程也直接反映了系统调度的过程，从进程状态的角度来了解 linux 中调度的执行过程，可能是一个不错的切入点。  




## 进程的种类
linux 作为一个复杂的系统，需要处理各类系统需求，自然也就衍生出一些不同属性的进程，这些进程总体可以分为三类：用户进程、守护进程、内核线程。   



### 用户进程
一个系统中守护进程和内核线程的数量通常是相对固定的，而系统的繁忙程序通常就取决与用户进程的多少，用户进程通常运行在用户空间，它也可以运行在内核空间，但这并不是任意的。  

一个用户进程想要进入到内核空间必须得到系统的"授权"，进入内核空间的原因通常是请求硬件资源，比如内存请求、io请求，发起一个系统调用，等待内核返回系统调用的执行结果。  

对于内核与用户空间的交互，有两种不同的理解：

一种是将用户进程视为两部分：进程的用户空间部分和进程的内核空间部分，在具体的实现上看起来也确实是这样的，当进程因为某种需求需要进入到内核空间时，发起一个系统调用，该进程关联的内核部分将会被执行，完成对应的请求并返回，这种理解的依据在于每个进程存在用户栈和内核栈。  

而大部分人更倾向于将内核视为一个独立的整体，和用户空间相互独立，其依据在于每个进程的 0~3G 用户空间是独立的，而内核并不区分进程，内核中所有资源共用 3~4G 的空间(32位系统下)，而且内核中的资源是为所有进程服务的，并不为某个单一用户进程而存在，用户进程发起的系统调用只是由内核接管并代为执行，执行完成之后返回结果到用户空间，而为每个用户进程设置内核栈的做法仅仅是在实现上比较方便，就像内核中需要保存进程相关数据一样。  



### 守护进程
守护进程也是用户空间的应用程序，不同的是它通常不完成具体的、用户可见的工作，而是提供后台服务，而且通常由 root 用户进行管理，以实现系统中的某些基础功能，比如 sshd 负责监听网络端口、crond 负责管理用户定时任务。  

守护进程通常在系统 boot 阶段随之启动，生存周期直到系统关机，当然这也取决于用户是否需要对应的功能，比如 sshd、httpd、crond，当用户不需要对应的 ssh、http、crontab 功能的时候，可以将其关闭。  



### 内核线程
内核线程有时候又被成为内核进程，这两者在概念上是一样的，只是有时候为了和用户进程作区分，刻意地称它为线程，实际上用户进程和内核线程在内核中的表现形式是完全一样的，都是由 task_struct 结构来描述，不同的是内核线程跟用户空间没有任何关系，完全独立生存在内核中空间，因此用来描述用户空间内存结构的 mm 数据结构为空。  

内核线程的特殊性还在于，如果内核线程创建者不主动向内核空间提供操作接口，用户空间几乎不可能改变内核线程的行为，包括使用 kill 指令，尝试杀死一个内核线程通常都是无效的，原因也很简单：系统中默认存在的内核线程都是系统运行所必要的，用户没有理由去停止它们或者修改它们的行为。  

如果需要修改内核线程的行为，大概率需要重新编译内核。  

需要注意的是，本系列博客主要的视角放在内核的调度行为上，影响调度行为的因素主要是调度策略以及优先级，尽管我们在这里讨论了linux系统中上述三种不同的进程，但是上述三种不同的进程并不直接影响调度行为，只是为了给读者建立一个对于进程的基本印象。  



## 进程状态
以最粗的粒度来看，一个进程要么就是在 CPU 上运行，要么就没有，而对那些没有运行的进程，又分为多种不同的状态：
* 可运行的状态
* 休眠状态
* 停止状态
* 僵尸进程或终止状态

获取系统中当前进程的状态可以使用 ps aux 命令，这个命令会输出系统中各个进程的简要信息，其中 STAT 列就表示对应进程的状态，其中和进程运行状态相关的标志为:
* R - 正在运行或者可运行状态
* S - 处于休眠状态
* D - 不可中断休眠状态
* T/t - 停止或Trace状态
* Z - 僵尸进程
* X - 即将结束的进程(几乎看不到)

在 ps aux 命令的显示中，对进程状态进行了进一步的细分，其它的还包括优先级，进程 leader等，这里我们仅将进程分为上面提到的四种状态分别讨论.  



### (可)运行状态的进程
当一个进程被创建完成时，它的状态就被设置为 TASK_RUNNING 状态，表示可运行状态，在单核或者多核系统中，可同时运行的进程数量是有限的，就绪的进程很可能大于 CPU 可运行的进程数量，这些进程统一都被设置为 TASK_RUNNING ，实际上有些进程正在运行，而有些还在等待. 至于为什么统一设置为 TASK_RUNNING 状态，可以参考后续文章中分析的调度器实现.  



### 休眠状态的进程
一个进程进入到休眠状态都是对系统资源的求而不得，当某项资源无法获取，需要等待时，继续占用 CPU 是一件非常不明智的做法，于是将 CPU 资源礼让出来让其它 CPU 运行，当系统资源满足要求的时候被系统唤醒并继续执行.  

大多数进程的休眠都是可中断的休眠，也就是可以接收信号，kill 系统调用可以直接唤醒对应的进程，让进程先处理信号，这个信号可能是终止当前进程，也可能是其它操作，这种休眠方式对应的标志位为:TASK_INTERRUPTIBLE.  

另一种是不可中断的休眠，这种休眠不接收信号，也就是必须等到需要的资源被满足，该进程才会被唤醒执行，这种情况通常出现在 I/O 操作中，Linux 中所有的硬件资源都由内核统一管理，用户请求 I/O 操作最终会执行对应硬件驱动程序的底层 I/O 操作.  

其实，并不是所有硬件的 I/O 都不能被信号中断，只有少数比较特殊的硬件或者硬件中比较特殊的操作才有这样的特性，比如有些硬件要求在交互时执行严格的时序，一步接着一步，每一步都对应着不同的状态，如果这次操作失败，目标硬件可能无法恢复到初始状态，从而导致系统问题.还有一些硬件可能对时延的要求非常严格，比如音视频数据的操作，在等待过程中如果临时去处理信号，耽误了处理数据帧的时间，很可能造成掉帧的情况.  

因此，对于特殊的硬件 I/O 操作，需要使用不可中断的休眠状态，对应的状态标志为:TASK_UNINTERRUPTIBLE.



### 停止或Trace状态
向一个进程发送一个 SIGSTOP 信号，它就会进入到 TASK_STOPPED 状态，除非它进入了 TASK_UNINTERRUPTIBLE 的休眠状态，解除休眠状态可以发送一个 SIGCONT 信号.   

同时，当进程使用 gdb 调试时，设置一个断点，并在断点处停下，这时候进程的状态就会显示为 t，即调试状态.  



### 僵尸进程
进程的僵尸状态是一种非常特殊的状态，在进程退出之后，进程实际上已经退出，大部分资源都已经释放了，同时，由于 linux 中所有进程组成一个树状结构，所有进程(除PID为1的进程)都存在其父级进程，父进程很可能需要了解当前进程的退出情况，退出码，以及一些统计信息，以方便父进程做一些特殊的处理，这是必要的.所以，所有退出的进程会向父进程发送一个信号SIGCHLD，然后留下一个 task_struct 空壳，成为一个僵尸进程，等待其父进程做最后的处理.  

同时，因为进程已经实际退出，无法通过发送信号的方式来终止僵尸进程，因此某些处理不严谨的系统中会出现大量的僵尸进程，尽管一个僵尸进程所占的资源几乎可以忽略不计，但是不断增长而不进行处理的僵尸进程就值得关注了.  

在实际的应用或者在内核中，进程状态会有进一步的细分，比如在内核执行 fork() 对应的系统调用时，会将进程先置为 TASK_NEW 而不是直接设置为 TASK_RUNNING，以保证还没准备好的新进程被意外地投入运行.不过总体来说，进程的状态分为上述的几个大类来理解是没有问题的，也方便后续的分析.  



## 进程状态的切换
了解进程状态的目的在于了解进程的状态在内核中是如何切换的，这才是最重要的部分，只有理解了这个，才能对 linux 中的进程调度有一个基本的概念.   

对于进程切换，可以参考下图:

![](https://gitee.com/linux-downey/bloc_test/raw/master/zhihu_picture/schedule/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2-new.jpg)

根据上图，透露出几个比较关键的信息:
* 所有进程的状态切换都是在内核中完成.
* 一个当前处于非可运行态的进程，想要获得执行权，一定是先切换为就绪态.

  




### 就绪态与其它状态的互相切换
如果一个进程需要投入运行，那么它一定是先被添加到就绪队列中，这个操作叫做入队，对应的接口为 enqueue_task，入队之后成为就绪态进程，至于它什么时候会被执行，这取决于该进程的优先级。  

除了切换到运行态，就绪态不能切换到其它任何状态.  



#### 运行态和就绪态的相互切换
尽管进程的运行态和就绪态同属于 TASK_RUNNING，但是这两者在进程调度时是完全不一样的，顾名思义，运行态表示进程正在运行，而就绪态表示进程可以投入运行，但是由于CPU的资源限制暂时还没有运行。  

尽管在进程运行标志上没有区别，但是在内核的处理上自然是有所区分的，所有处于就绪态的进程将会添加到 CPU 的就绪队列上，在 cfs 调度器中(本系列博客专注于分析cfs调度器的实现)，就绪队列并不是一个队列，而是一颗红黑树，所有进程以动态优先级(你可以暂时理解为动态优先级，实际上不算是，参考后续文章)为键值排列在红黑树上，每当调度器执行调度程序时，它总是选择红黑树最左边的节点运行。   

所有就绪态进程都在就绪队列上，那处于运行状态的进程呢？当红黑树最左边的进程被选中投入运行时，它被调度器从就绪队列的红黑树中摘出来，因此，运行态的进程并不在红黑树上，比较有意思的是，在内核的实现中，当前运行的进程确实是从红黑树上被 dequeue 了，但是其对应的标志位 on_rq 却没有被置位.因此，尽管表示进程状态的标志位同为 TASK_RUNNING，但是内核对运行态和就绪态的进程的处理区别很大.  

至于一个进程在什么情况下会从就绪态切换为运行态，又会在什么情况下从运行态切换为就绪态，这就是调度器的核心实现，后续将会花大量的篇幅来对其进行分析.  



#### 休眠态与就绪态的切换
通常情况下，我们经常说到的发送一个信号给某个进程，实际上真实的过程是怎样的呢？当我们使用 kill 发送一个信号时给某个进程时，实际上 kill 系统调用会唤醒对应的进程(SMP下也可能进程正在其它CPU上运行)，而这里的唤醒并不是让目标进程立马投入运行，而是将目标进程添加到就绪队列中，这样它在不远的将来会投入运行然后处理信号(如果他没屏蔽信号)，当然，处理完信号之后发现需要的资源依旧不能满足的情况下，将会继续进入休眠。   

对于不可中断的休眠进程，信号是不管用的，不过内核中封装了唤醒接口，比如 wake_up_process，将会唤醒对应的进程，对于可中断休眠或者不可中断休眠进程都是有效的，同样的，一切的唤醒都只是将进程添加到就绪队列中，然后将调度的难题交给调度器来解决。  



#### 新建进程

默认情况下，新进程被创建之后也会被设置为 TASK_RUNNING，即添加到就绪态，在创建进程时，父进程自然是处于运行态的，而父进程执行一次 fork()，得到两次返回也正是这个原因，在调用 fork() 的那一刻一分为二，严格来说并不是一次调用两次返回，这并不符合 C 语言的规范，而是在调用 fork 开始就产生了两个进程，正常情况下，用户空间发起一个系统调用最后将会返回到用户空间，因为父子进程共享程序的代码数据段，而现在经过复制的父子进程都会返回到自己的用户空间，因此看来有两次返回，实际上这不是一个函数的返回，而是两个不同进程中的两个相同函数的返回。   



#### 停止态与就绪态的切换
停止态到就绪态的切换在上中就有所描述，进程因为接收到 SIGSTOP 信号停止，然后接收到 SIGCONT 信号继续被投入运行.




### 运行态切换到其它状态
所有非运行态的进程状态，都是由运行态切换而来，包括就绪态，终止态，停止态，休眠态.  



#### 就绪态与运行态的切换
运行态与就绪态之间的切换参考上文.  



#### 运行态到终止态
进程终止通常是因为接收到了 exit 指令，这时候进程被唤醒执行，知道自己已经走到了生命尽头，于是默默地清理掉自己所占用的大部分资源，只留下一些必要的退出信息，发送信号给父进程以让其获取这些信息，最后调用 schedule() 函数，切换到下一个应该运行的进程，而当前进程的进程标志 task->state 设置为 TASK_DEAD.  




#### 运行态到休眠态/停止态
参考上文. 




### 进程迁移
在多核架构中，存在一种特殊的情况，就是从就绪态到就绪态，指的是一个就绪态的进程从一个 CPU 的运行队列转移到另一个 CPU 的运行队列，每个 CPU 都能执行一个单独的进程，自然也会维护一个独立的运行队列，从调度的角度来看，进程是系统中所共有的资源，而运行队列可以不止一个，默认情况下，一个进程可能运行在任意的一个 CPU 上，对于共享的中断，也是同样的道理.   

因此，当一个CPU上运行队列负载和其它CPU相比不均衡时，就会发生进程迁移的情况，这在内核中被成为进程的负载均衡，进程的迁移从原理上来说，也就是将进程从一个CPU上的运行队列转移到另一个 CPU 的运行队列，但是实际的负载均衡实现是比较复杂的，最重要的问题是怎么确定进程迁移的时机，执行某次进程迁移是不是真的能带来负载的平衡从而获得效率上的收益?通常需要综合考虑 TLB，cache 缓存的影响，统计历史负载量以及预测CPU将来可能到来的负载量，迁移过程所带来的实际开销等.  




[Understanding Linux Process States](https://access.redhat.com/sites/default/files/attachments/processstates_20120831.pdf)

https://www.cnblogs.com/programmer-tlh/p/11593330.html
# 计算机数字编码实现：源码反码补码



## 十进制和二进制

在实现世界的数字系统中，计数的方式是十进制的，大概是因为人只有10个手指，10个手指数不过来的时候就产生进位。  =

而在计算机的实现中，传输的只有电信号，0~3.3v的电信号或者是0~5v的电信号，那么在计算机中是不是可以将5v电压分为5级从而使用5进制呢？这种想法和人类的手指计数方式类似，看起来是可行的。  

理想很丰满，现实很骨感，一个最主要的限制因素在于电信号传输会衰减，5v的电压发出可能到了对端就变成了4v，这样就导致传输的错误，在这种情况下，使用二进制可以获得最大的稳定性和容错。  

对于二进制的电平标准也有很多，最常见的TTL电平标准定义输入电平低于1.2v为逻辑0，输入电平高于2.0v为逻辑1。  

所以，针对使用二进制的计算机，人类的计数法能不能适用呢？  

对于正数而言，倒是简单，直接将十进制转换成二进制即可，比如十进制10，对应二进制

0b1100，十进制255，对应二进制 0b11111111(为了方便讨论，以下的数字讨论都基于8位的数据).  

但是对于负数而言，如何使用二进制表示就成了一个问题。

 

## 原码

要用8位二进制表示一个负数，最直接的方式就是模仿十进制的做法：既然十进制是在数字前加一个 ’-’ 号，那么我们就选取8位中其中一位作为符号位，用其他七位来表示数值。  

这种方式是最好理解的，比如 -1 就可以使用二进制 0b10000001 表示，-127 使用 0b1111111 表示。  

 

### 原码编码的问题

尽管这种方式是非常浅显易懂的，但是计算机并不会因此而感到快乐，因为这种编码方式对它而言非常地不友好。  

数字存在的意义在于它将现实事物进行抽象，然后非常方便地进行运算，假设我们要使用计算机来计算 1+(-1)，对应竖式运算为：

|      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 1    |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| +    | 1    | 0    | 0    | 0    | 0    | 0    | 0    | 1    |      |
|      | 1    | 0    | 0    | 0    | 0    | 0    | 1    | 0    |      |

 

运算结果是 0b10000010，按照原码解析为 -2，这明显是不对的，所以对于加减法计算而言，对负数原码的编码方式是不合理的。  

 

 

## 反码

既然原码编码不合理，那么我们就换一种方式，使得编码能够满足二进制的加减法，反码就应运而生。  

反码的编码规则为：在原码的基础上，符号位不变，所有其它位取反。

-1 的反码表示为  0b11111110，-127 的反码表示为  0b10000000.  

 

再来计算 -1+1 的结果为：

|      | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 0    |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| +    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 1    |      |
|      | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |      |



结果是 0b11111111，这个值是多少还真不太能一眼看出来，我们将它转换成原码为：0b10000000，根据原码编码的规则，第一位为符号位，后续位为值，所以该结果为 -0。  

该计算结果满足了我们的要求，但是还存在一个问题：在反码中，0b00000000 和 0b10000000 都表示 0。  

 

所以反码编码的分布如下：

![img](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8920\wps3.jpg) 

 

而且在加法运算中，会出现 0+1 等于0的情况，比如：0b11111111+0b00000001=0b00000000，很明显这也是不合理的做法。  

 

编码的原则在于，所有编码系统的设计，都在追求连续性和唯一性，而反码的编码规则破坏了这一规则，既不连续也不唯一。  

 

因此，反码编码是一个可接受的编码解决方案，对于其中一些瑕疵，可以通过一些特定的方法来解决，但这并不是一个优秀的解决方案。  

 

\## 补码

既然反码不够”优雅”，于是人们开始寻找另外的解决方案，最后提出了补码的编码方式，这种编码方式也沿用至今。  

 

补码的规则非常简单，就是在反码的基础上加1，同时规定 0b10000000 对应 -128，相对应的，0b10000001 为 -127，以此类推。  

 

在这种情况下，-0 变成了 -128，整个编码空间变成了这样：

![img](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8920\wps4.jpg) 

 

 

 

\## 编码的连续性

事实上，补码相对反码来说，解决的并非仅仅是唯一性问题，这里需要讨论一个更深层次的问题：编码的连续性。  

 

连续性编码从字面上很好理解，就是连续，但是实际情况下，通常由于编码上限的限制，当需要编码的对象超出系统所容纳的上限时，就会出现断点，然后沿系统继续循环。  

 

举个例子你就明白了，最常见的就是手表的表盘，最大值是12，当超过12点时重新回到一，这样就避免了编码的无线延长，这种断点的本质在于系统无法表示超出范围的结果。于是，出现了13点由1点表示，15点由3点表示。  

 

同时我们可以将数学计算运用到表盘上：

 

4+4=8：相当于在4点时顺时针拨动4小时。

8+8=4：相当于在8点时顺时针拨动8小时。

1-2=11：相当于在1点时逆时针拨动2小时。  

 

 

而计算机的二进制编码也是同样的道理，如果是一个8位的系统，编码所能覆盖到的最多达到2^8=256个数字，超过的数字同样产生溢出从而进行回环。  

 

 

我们再回过头来看反码与补码的编码分布：

 

![img](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8920\wps5.jpg)![img](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8920\wps6.jpg) 

反码             补码

 

假设我们需要计算 (-2)+(-127)的结果，对于反码而言：-2 的编码为0b11111101，-127的编码为 0b10000000，所以它们的计算结果为0b1111101，即125。 

 

但是，如果我们按照编码的连续性来计算， (-2)+(-127) 相当于将 -2 逆时针旋转 127，按照这样的算法结果是 126(-2逆时针旋转125是-127，再旋转2就是126，参考上图)，但是按照二进制的加法结果却是 125.因此可以看出，这个编码环并不是连续且自洽的，在产生溢出时会出现跳跃性，对于计算机而言，不连续意味着特殊处理。  

 

而对于补码形式来说，(-2)+(-127)，表示为二进制为：0b11111110+0b10000001=0b01111111，结果为127。  

 

同时，在编码环中，(-2)+(-127) 相当于 -2 逆时针旋转 127，结果是 127，可以发现，这和二进制运算得出的结果是一致的，说明这种编码方式是连续且自洽的。   

 

 

所以，补码的实现相对于反码要更加严谨，另一方面，这种严谨所带来的好处就是简化了计算机的工作，也意味着效率的提升，尽管这种编码方式对人而言比较反直觉。  

 

参考:[知乎回答](https://www.zhihu.com/question/20159860)
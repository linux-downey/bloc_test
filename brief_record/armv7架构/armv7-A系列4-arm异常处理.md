# armv7-A系列4 - arm异常处理
在嵌入式中，中断这个概念渗透到方方面面，几乎每一场面试中，都会出现中断的知识点以检验面试者对嵌入式系统的了解程度，这无疑也是个难点，所以非常值得在讨论处理器时单独用一章的篇幅来分析中断的底层行为。  

当然，这仅仅是整个中断子系统的冰山一角，不过，了解处理器的异常处理是掌握整个 linux 中断系统的必经之路。  


## 异常类型
在处理器架构层面，软件中断、IRQ 和 FIQ 被统称为异常，异常还包括 Abort 和 undefined 指令等，在工作中最常接触的就是软件中断和 IRQ，所以从实际出发，这一章我们着重地分析软件中断和 IRQ 这两种在 linux 中占据重要地位的异常。  

在 linux 中，通常我们所说的软件中断就是通过 svc 指令发起，在老版本的 arm 架构中也被称为 swi，这两者互为别名的关系，并没有什么区别，软件中断即 svc 是用户空间进入内核空间的唯一通道，也是 linux 实现系统调用的关键所在。  

而 IRQ 则是指硬件中断，由 CPU 上引出一条 IRQ 线，这条 IRQ 线通常连接到 GIC(中断控制器) 上，GIC 向下再连接各外设，当外设产生中断信号时，经由 GIC 传递到 CPU 的 IRQ 引脚上，在 CPU 执行指令的间隙会查看是否有中断产生，如果有，则跳转到中断向量表的位置执行相应的异常处理程序。处理器的 IRQ 可以通过 CPSR 状态寄存器的中断屏蔽位屏蔽掉 IRQ。  

FIQ 在 linux 中并没有使用到，相对于 IRQ 而言，FIQ 拥有更高的优先级，它可以抢占 IRQ 的执行，同时 FIQ 本身的执行速度比 IRQ 要快一些，这类中断通常用在对响应时间有极高要求的系统中，比如 armv7-R 系列的处理器中会使用到。FIQ 的快速执行一方面体现在它有更高的优先级，另一方面，它拥有单独的寄存器，省去了参数的压栈时间，且处于中断向量表的最后一项，其执行代码不需要经过跳转。  

至于为什么 linux 中不使用 FIQ，同时禁止 IRQ 中断的嵌套，这是因为支持中断的嵌套会给系统带来更大的复杂性，同时，过多中断的嵌套很可能导致栈的溢出，另一方面，随着硬件的发展，系统性能的瓶颈并不受限于中断的处理，当然，禁止 FIQ 以及中断的嵌套会略微地降低实时性，但是明显它带来的那点实时性提升并不足以弥补它所带来的缺点，两相权衡之下，在新版的内核中便取消了中断嵌套的支持(老版本中是支持的).



## 中断向量表
向量表中保存了一系列的跳转指令，当系统发生异常时，由处理器负责将程序执行流转到向量表中的跳转指令，最常见的就是中断向量，应用工程师只需要使用固定的函数名编写中断处理程序，在中断发生时该中断处理程序就会被自动调用，这背后的实现就是中断向量表的功劳。  

在 armv7 中，中断向量表可以设置在两个地址：0x00000000 和 0xffff0000，由协处理器 cp15 的 SCTLR 的 bit13 来控制，默认情况下，中断向量表的位置在 0x00000000，实际上，对于操作系统而言，比如 linux，会更倾向于将中断向量表放在 0xffff0000 处，因为 0x0 处在用户空间下，需要额外做一些限制，而 0xffff0000 处在内核空间，另一方面，0 地址通常是 NULL 指针访问的地址，这需要 MMU 做相应的访问限制规则，总之，将向量表放在高地址处会更方便。

armv7 架构中向量表地址内容见下表：

![](https://gitee.com/linux-downey/bloc_test/raw/master/zhihu_picture/armv7/armv7%E5%90%91%E9%87%8F%E8%A1%A8.jpg)

当对应的 exception event 发生时，系统会自动地修改 CPSR 状态寄存器，并跳转到上表中的地址执行指令，而软件上要做的，就是在该地址上放置对应的代码，除了 FIQ 之外，其它模式对应的都是一条跳转指令，如果存放多于 4 字节的指令，将会覆盖调用后续的异常向量，因为 FIQ 是最后一条异常向量，根据其特殊性，FIQ 的处理指令可以直接放置在以 oxffff001c 处，当然，具体怎么做由软件的实现来决定。  

比如，在 U-boot 中，armv7 对应的 vector.S 中(启动代码)可以看到这样的代码(uboot中向量表配置在0地址处)：

```
_start:
    b	reset
    ldr	pc, _undefined_instruction
    ldr	pc, _software_interrupt
    ldr	pc, _prefetch_abort
    ldr	pc, _data_abort
    ldr	pc, _not_used
    ldr	pc, _irq
    ldr	pc, _fiq
```

因为在链接脚本中定义了 ENTRY(_start)，所以程序的第一条指令就是 b reset，尽管后续的指令得不到执行，但是它们在编译链接之后就被放置在以 0x4 开始的地址处，每一条指令占4字节，从指令内容可以看出这些指令都是跳转指令。   

在汇编中标号表示标号之后的第一条指令的地址，比如，当发生 irq 中断时，处理器会强制跳转执行 ldr pc, _irq 这条指令，它的内容是这样的：

```
_irq:			.word irq

irq:
	get_irq_stack
	irq_save_user_regs      //保存断点
	bl	do_irq
	irq_restore_user_regs  //恢复断点
```

也就是说，中断向量表定义了在异常发生的那一刻，程序将要跳转执行的地址，这是由硬件自动进行设置的。  




## 异常进入处理
在异常产生的时候,会发生什么?硬件做了哪些事,软件需要做哪些事?这是我们必须要知道的,下面就是异常发生时 arm 处理器自动执行的操作:



* 将异常发生前所属模式的 CPSR(user下为APSR) 拷贝到异常发生后将要进入模式的 SPSR\_\<mode\> 中,除了 System 模式,其它所有 PL1 特权级模式都有 SPSR bank 寄存器,这个操作并不难理解,就是保存现场,方便在异常处理完成之后还原之前的 CPSR.  
* 将返回地址保存到 LR 寄存器中,返回地址自然是当前指令的下一条指令的地址,但是因为指令流水线的存在,PC寄存器中保存的是当前指令地址 +8 处的指令,所以需要针对 PC 做一个偏移,这个偏移并不是固定的,而是根据不同模式有不同的值.  
* 修改 CPSR 中的某些 bit:
    
    * 修改 CPSR 的 mode 部分,修改为异常处理模式下的模式
    * 设置 CP15 的 TE bit
    * J(指令集模式) bit被清除,同时 E(大小端) bit 设置为 EE(exception 大小端) bit.
    主要是根据预先的设置配置异常处理的指令集模式和大小端.  
* 设置 PC 指针到对应的异常模式向量处,执行软件定义的异常处理程序.  

硬件主要设置了状态寄存器,中断处理的配置以及中断向量的自动跳转,对于异常处理这当然是不够的,还需要软件的配合,通常情况下在进入异常后软件需要保存断点信息,将异常发生前模式的所有寄存器保存在栈上,在异常返回时才能进行恢复.  

## 异常退出流程
异常的退出流程和进入流程几乎是相反的:



* 将 SPSR 中的值 copy 到 CPSR 中,对于 SPSR 的 copy 并没有定义单独的指令,而是在操作 PC 指针时,在指令后添加一个 'S' 后缀即执行 SPSR 的拷贝,在阅读源代码时这种操作很容易被人忽略,因为普通的指令也可以带 S 后缀,表示当前操作是否更新 CPSR,另一种更新 SPSR 的方式是在 LDM* 指令后添加 ^ 后缀,也是一样的效果,但是在 STM* 指令后添加 ^ 并不是同样的意思,这个需要注意.  
* 将保存在栈上的中断前模式的所有寄存器值恢复到寄存器中,返回程序断点.  
* 设置 PC 寄存器到异常发生前的返回地址,这时候返回地址并不一定还保存在 lr 中,很可能 lr 已经被程序其它部分挪用,这取决于实现.

## bank寄存器的访问
细心的朋友会发现这里存在一个问题:在进入异常后会将原模式下的寄存器全部保存在异常模式下的栈中,以便后续程序的恢复,但是问题在于,lr 和 sp 通常是 bank 类型的,比如在 IRQ 模式下访问 sp 事实上访问的是 sp_irq,而不是发生中断前的 sp_user 或 sp_svc,那么如何将 sp_irq 的值保存到 irq 模式的栈上呢?  

arm 的实现并没有什么精巧的做法,而是直接定义了特殊指令,可以实现跨模式的bank寄存器操作:

```
stmdb	r8, {sp, lr}^
```
stm* 指令后添加 ^,表示操作的不是当前模式下的 sp,lr,而是 USER 模式下的寄存器,这是取自内核中的一条指令.  


## 中断处理流程
中断其实是属于异常的一种,鉴于它对于驱动工程师的重要性以及硬件上的特殊性,有必要单独拿出来讲一讲,而且我们讨论 linux 下的情况,所以不涉及 FIQ 和中断的嵌套,下面是中断发生时 arm 处理器自动执行的操作:



* 当处理器接收到一个 IRQ 信号时,处理器可能位于 user 和 svc 两种模式下,和异常处理一样,先会将返回值保存到 LR,接着保存 CPSR 到 SPSR_IRQ,需要注意的是,这里还有一个操作:设置 CPSR 的 I bit 为 1 屏蔽中断,直到软件上重新使能,才会接收新的中断,而软件上何时将中断打开决定了中断执行的策略,如果软件中的实现是在执行用户定义的中断服务函数之前打开中断,那么中断嵌套就可能发生,如果在执行完用户定义的中断服务函数之后打开,中断就不允许嵌套.  
* 指令跳转到 IRQ 对应的中断向量处,对应的中断向量处的执行代码有两种情况:针对 svc 模式下发生中断的处理和针对 user 模式下发生中断的处理.  
* 中断服务子程序中保存中断发生前模式的所有寄存器值到栈上,由软件实现
* 处理用户定义的中断处理程序,由软件实现.
* 中断返回时,将 SPSR 拷贝到 CPSR,并将所有保存在栈上的寄存器值恢复到寄存器中,设置 PC 返回到程序中.  

实际上 linux 的中断处理并不仅仅涉及到 IRQ 模式,在中断发生时仅仅是短暂地位于 irq 模式下,真正的中断处理流程是在 svc 模式下执行的.关于中断处理部分后续还会开专题详细讨论.  



### 参考

[armv7-A-R 参考手册](https://gitee.com/linux-downey/bloc_test/blob/master/%E6%96%87%E6%A1%A3%E8%B5%84%E6%96%99/armv7-A-R%E6%89%8B%E5%86%8C.pdf)



[专栏首页(博客索引)](https://zhuanlan.zhihu.com/p/362640343)

原创博客，转载请注明出处。
# armv7 汇编系列-0
随着计算机行业的发展，C/C++ 几乎都已经沦落为"低级语言"了，更别提最靠近底层的汇编了，在大家的印象中，汇编语言早已经半截入土，作为一门最靠近硬件的语言，在应用程序中确实早已经销声匿迹了。   

编程效率低、几乎不可移植、学习成本高，汇编的这三个特点随便拿出一个都能让工程师对它敬而远之，但是很遗憾的是：如果你是驱动工程师或者想成为一名驱动工程师，汇编这个坎儿还真是绕不过，也没有什么很复杂的原因，仅仅是因为汇编在CPU底层操作方面的不可替代性，也就是：别的都不能使。  

那么，如果工作不涉及驱动或者内核，需不需要学习汇编语言呢？如果你有时间，最好还是学一学，而且越早越好，那么，为什么要学汇编，或者说它有什么好处？  

## 为什么要学汇编
对于大多数软件工程师而言，应该都有过这么一个疑问：计算机到底是如何工作的？但是对于绝对部分的人而言，这种想法也只是一闪而过，或者是尝试找了一些资料后发现这个问题太过于复杂就放弃探寻了。  
学习汇编，就是探索计算机是如何工作的一个过程，但是学习汇编的过程，并非仅仅是学习汇编那几条指令，更多地是需要涉及到指令的编码、程序的运行、内存的分配等一系列计算机的底层行为，一方面是满足好奇心，另一个更重要的方面是了解计算机是如何运行的。  

问题是，了解计算机工作原理对写应用程序有什么作用吗？  

答案当然是有用的，由这个问题可以引申出很多镜像问题：
* 健身教练有没有必要了解营养学、解剖学
* 赛车手有没有必要了解汽车内部构、实现原理

对人体构造、营养学没有研究的健身教练一样可以工作得不错，只需要保持一个良好的学习状态，实时地引入业界一些新的健身理念、健身方法并尝试使用，但是永远做不到创新，也无法对健身这个理念有多深刻的理解。  

对汽车构造没有了解的赛车手同样可以跑得不错，只要肯学习，肯花时间练习，孰能生巧。但是一旦遇到新的状况，无法从根源上进行分析并制定合适的方案。  

同样的，一个不了解计算机工作原理的程序员，持续地学习可能让他很优秀，但是绝对不会是顶尖的，我们来讨论下面几个问题：
* 浮点运算和整型运算哪个更耗时？为什么程序在做2次幂的乘除法时比做非2次幂的乘除法要快？
* 当程序运行出现错误时，通过打印调试无法解决问题，如何使用更有效的调试方法？
* 当需要对可执行文件进行裁剪、转换，甚至自定义修改时，如何做？
* ...

上面的问题也是比较常见的问题，如果不具备计算机原理相关知识，是没有办法解答的，我们可以来讨论讨论：

对于第一个问题，这是在算法中常见的问题，如果是计算机自带硬件浮点单元，浮点运算和整型运算不会相差太多，如果没有，浮点运算自然是要比整型运算更耗时的，其执行效率之差甚至达到几十倍，因此在做优化的时候就有必要想办法将浮点运算转换成整型运算。  

同时，在执行 2 次幂的乘除法时，实际上被编译器优化成了移位指令，所以执行效率要更快。  

第二个问题，在调试的时候，或者说程序出现错误时，在打印调试无法解决问题时，这时候可以这么做：生成一些调试文件，比如 core dump 文件，或者是使用 gdb，或者 android 的 adb，但是这些工具生成的信息中通常包含系统的栈信息、寄存器信息，如果你对这些没有一定的了解，也就无从下手。  

第三个问题，程序的加载和执行所涉及到的知识和计算机原理、操作系统工作原理息息相关，如果你需要做相关的工作，必然要对程序编译、加载、elf 文件、链接等有一定的认识。  

你可能会说，你说的这些东西我都用不到，或者说这些东西都是人家封装好的现成的，我直接调用就行了，又或者说，我的工作都涉及不到你说的这些算法、优化之类的，你说的这些根本没有意义。  

如果是这样，那么我很遗憾地说，你的工作其实没有什么技术含量，正是因为这些基础知识的缺乏，让你成为了一个平庸的工程师。  

当然，了解计算机工作原理并不一定要通过学习汇编程序，但是学习汇编程序一定是最有效率的做法。  


## 汇编是如何工作的
在学习汇编之前，多多少少会接触到一些汇编相关的理论，它是最贴近硬件的语言，它的形式类似于这样：

```
操作指令  操作数 操作数 ...
```

那么，问题是：
* 汇编最终会被编译成机器码，机器码和汇编到底是如何对应的呢？
* 这个操作码是如何被定义的？为什么操作码不能所有平台通用从而做到可移植呢？
* C语言被编译成汇编指令，C 和汇编指令又是怎么对应的呢？
* 程序到底是如何在内存中被执行的？


曾经的博主就是带着这一系列的问题来学习汇编，幸运的是，经过一段时间的学习，这些问题都得到了解答，接下来我们一个个地讨论这些问题：

****

```
汇编最终会被编译成机器码，机器码和汇编到底是如何对应的呢？
```
关于这个问题，可以参考我的另一篇博客： armv7-A系列-arm指令集 TODO。

****

```
这个操作码是如何被定义的？为什么操作码不能所有平台通用从而做到可移植呢？
```

正如上一个问题所说，不同的汇编指令对应不同 CPU 操作，比如加减法操作、内存操作，对于这些操作，需要给它定义一个识别号，也就是操作指令，同时每个操作都有不同的操作数，于是汇编指令格式被定义为：操作指令+操作数。  

同时，汇编指令针对的是汇编器，在厂商开发汇编器的基础上，汇编指令的命令可以是非常随意的，你怎么命名，我就怎么进行指令解析。或者将汇编指令标准发布出去，第三方开发汇编器也是没有问题的。    

那么，为什么各家厂商要使用不同的汇编命名和操作方式而不使用统一的呢？  

答案是，做不到。为什么做不到呢？因为硬件千差万别，不同的 CPU 有不同的设计，汇编通常操作的是寄存器、内存、模式控制、协处理器等，但是不同的厂商通常生产的 CPU 有不同的特色，针对不同的领域，导致寄存器、内存的支持数量，内存访问方式千差万别。   

那么，是不是针对同一领域，CPU 结构类似且资源相差不大的情况下，不同厂商之间的汇编指令可以兼容呢？  
理论上是可以的，但是有一家会因为竞争而倒闭...

那么，是不是可以开发一个通用汇编语言的编译器转成各个平台的汇编语言然后再汇编呢？  
有，这个事 50 年前就有人做了，这个通用的汇编语言叫 C 。

****

```
C语言被编译成汇编指令，C 和汇编指令又是怎么对应的呢？
```
对 C 语言有一定了解的会知道，对于 C 程序而言，最后编译的结果是这样的：

C 程序编译完成之后会生成主要的三个段，data、text、bss，还有一些其它可选的段。其中：
* 代码部分放在text段，只读的数据可以放在 text 段
* 已初始化全局数据、静态数据放在 data 段
* 未初始化的全局、静态数据放在 data 段

相对应的，汇编语言中直接通过指令 .section 定义这些段，然后往这些段中放置数据：

对于 data 部分而言，C 语言的定义行为比如 int g_param = 1，在汇编中直接对应 

```
.data
g_param:
	.word 1
```
在使用时，C 语言中直接使用 g_param ,汇编中使用其标号即可。  


对于 bss 段而言，C 语言中的定义行为比如 int g_param = 0;,在汇编中对应为：

```
.global g_param
.bss
.size g_param, 4
```
也就是仅仅做一个标记，表示 g_param 占用四个字节，使用方式和 data 段数据类似。

对于 text 段而言，这个过程是最复杂的，需要将 C 语言指令转换为对应的汇编指令，比如：

```
int a = 1;
int b = 2;
int c = a + b;
```

对应的汇编指令为：
```
movs    r3, #1
str     r3, [r7, #4]
movs    r3, #2
str     r3, [r7, #8]
ldr     r2, [r7, #4]
ldr     r3, [r7, #8]
add     r3, r3, r2
str     r3, [r7, #12]
```
对应的过程就是，分别将 1 2 加载到寄存器中，然后保存到栈上，然后再取出来放到寄存器中，两个寄存器中的值相加，再保存到栈上。  

整个过程非常麻烦，按照人类的思维，完全可以直接将 1 、2加载到寄存器中，相加，然后将结果保存到栈上，为什么汇编指令这么麻烦？这是因为C和汇编指令都是一一对应的，int a = 1，这条指令就是在栈上为局部数据分配空间，所以每条定义指令最后都会保存到栈上，同时，arm 处理器中规定不能直接对内存进行操作，所以要先加载到寄存器中，至于下次要操作，就重新取，如果使用编译器优化的功能，倒是可以优化得更方便。   

那代码中的符号 a、b 和 c 去哪儿了，答案是这些符号被丢弃了，这些符号没有被导出到外部，因此直接将这些符号删除，因为汇编程序不再依赖这些符号进行寻址，直接在栈上寻址就可以找到对应的局部变量。  

关于汇编程序与 C 的转换在后续的文章中我们会详细提及。  

****

```
程序到底是如何在内存中被执行的？
```
这是个十分复杂的问题，要详细地表述清楚短短的一篇文章自然是不够的，但是我们可以简化这个问题：一个简单的可执行程序是如何被执行的？  

一个简单的可执行程序可以只包含三个必要的段：text、data、bss，且以来动态库，只有非常简单的几条指令，假设这个程序在链接阶段指定的三个段的加载地址为：0x1000,0x2000,0x3000。  

首先，对于这个简单的可执行文件而言，text 段包含所有待执行的指令，data 段包含全局数据，bss 段中只有全局数据的标记，不占内存空间。  

在这个可执行文件被加载时，text、data、bss 段分别被加载到对应的地址 0x1000,0x2000,0x3000，然后 PC 指针跳转到 text 段开始处执行代码，通过上文中机器码的介绍以及我的另一篇文章：TODO 的介绍，可以知道：每一条机器码都包含 要执行的操作+操作参数，所以每一条机器码(armv7中4字节)都是可以独立运行并产生相应结果的，这个结果可能是保存在某个寄存器中，可能是保存在内存中。  

如果这片内存映射了对应的外设，其指令结果就可以操作到对应的外设，比如点亮一颗灯、发送一个串口数据等等。  

而需要操作到全局变量时，也对应一条加载指令，ldr，假设 ldr 对应的编码如下：

```
高四位 0001 表示 ldr 的编码
中间四位表示加载到目标寄存器
最低24位表示加载地址
```
将 0x2000 处的四字节全局变量加载到 r2 寄存器中的指令编码就是：0x12002000(TODO,是不是相对位移)，这条指令就相当于全局变量的引用操作，对于 bss 全局数据也是如此。  

如果程序只有 text 段而没有 data 段和 bss 段可不可以呢？其实是不可以的，这三个段都必须存在，但是 data 段和 bss 可以为空，也就是整个程序只有 text 部分，这种代码被称为位置无关代码，因为它不需要引用任何的外部数据，所以它无论被 copy 到内存中哪个位置都是可以直接执行的。  

****



# armv7汇编系列-2-跳转指令
由于arm使用的是精简指令集,相对于 x86 的汇编,指令编码要相对简单很多,每条 arm 指令都是 32 位而且操作都是地址对齐的,跳转指令是程序运行的核心部分,自然需要重点将.  

armv7 的跳转方式分为以下两种:
* b,bl 指令,指定地址进行跳转
* 设置 PC 指针的值,实现跳转

同时,因为 armv7 同时支持 arm 和 thumb 指令集,所以在跳转时还会涉及到指令集的切换,在这一章中,我们将讨论这两个话题:跳转和指令集切换.  


## 跳转

### 跳转指令

标准的跳转指令有两种:b,bl,由此衍生出的 bx,blx,bnz 等等,b 和 bl 的区别非常简单: 
* b 表示直接跳转
* bl 先将下一条指令地址保存在 lr 中,然后执行跳转,这样有利于程序的返回,如果是是汇编调用 C 程序,在需要返回的情况下,只能使用 bl 指令,如果是汇编代码中的互相跳转,倒是都可以,因为返回到跳转点的方式有很多.   

除了标准跳转指令,还涉及到 armv7 指令集的一个特性:条件执行,几乎每条指令的最高四位的编码都带有条件指令部分,关于这个可以参考我的另一篇博客TODO,所以由此衍生出来各种各样的条件跳转,比如 beq,bge,blcc 等,这些条件后缀可以根据我的另一篇博客进一步详细了解,当然也可以参考 reference manual,这是最好的方法.这里就不再赘述了.   

需要注意的是,在编写跳转指令的时候,大多都是通过标号的形式进行跳转,很少会直接使用硬编码的地址,但是我们需要了解的是:程序的跳转是相对地址跳转而不是绝对地址跳转,也就是跳转的偏移值为 目标地址-当前地址. 而且因为指令编码的原因,并不是可以在 4G 的地址空间内随意跳转,不同的指令有不同的跳转范围,跳转指令的范围可以见下表:TODO

至于为什么跳转指令不能自由地在整个 32 位地址空间内跳转,这涉及到指令的编码,可以参考我的另一篇博客TODO.  


### 基于 PC 的跳转
PC 指针的跳转原本是非常简单的,往 PC 中写一个特定的地址值,程序就会跳转到对应的地址处执行,这样的操作也是没有问题的,但是在很多情况下,是基于当前 PC 指针的偏移地址进行跳转,这个问题就要稍微复杂一些.  


#### PC 指针的获取
PC 指针中存储的是下一条执行的指令，这是大多数资料中对 PC 寄存器的描述，但是随着硬件的发展，这个说法开始变得不那么正确了。  

这得从 CPU 的流水线机制说起，对于每一条指令，都需要经过取指、译码、执行的过程，在传统的机器上，这三个步骤是串行的，也就是执行一条指令并不仅仅是一个指令周期。  

于是硬件上引入了流水线机制，在同一个时钟周期，取指、译码、执行三个步骤同时进行，这三个步骤并不是同时针对一条指令，而是不同的三条指令，也就是当前指令正在执行，当前指令的下一条指令进行译码，同时取下下条指令，这种三级流水线机制可以加速指令的运行，而 PC 指针则是指向取指的指令，所以在 arm 指令集下，PC 的值为 当前地址+8

最初的流水线通常是三级，即取指、译码、执行，随着硬件的发展，芯片厂商对于速度提升的需求并不会减弱，于是越来越多级别的流水线被加到芯片中，到后来的 5 级甚至 8 级流水线，以五级流水线为例，其流水线流程为：取指、译码、执行、访存、回写。 即使是这样，相对于当前执行的指令而言，PC 指针始终为 当前指令+8.  

既然流水线可以执行并行的运算，加速指令的执行，是不是流水线越多越好呢？其实也并非这样，在实际的程序中，往往会存在非常多的条件执行或者跳转指令，对于条件执行指令而言，流水线如何确定要执行哪个分支呢？  

其实是没有很好的办法来确定的，唯一的做法就是猜，但是这个猜不是瞎猜，而是根据之前指令执行的行为来推测需要将要执行的分支，这种技术叫分支预测，armv7 对分支预测有直接的支持，尽管这种分支预测有比较好的表现，但是一旦分支预测错误，就需要将整个流水线 flush，而重新填充整个流水线需要消耗多个指令周期，这时候流水线越长，分值预测失败所带来的开销就越大，所以对于流水线而言，一方面想办法提升分值预测的准确度，另一方面，也需要限制流水线的长度。  






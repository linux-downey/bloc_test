# armvv7汇编系列-2-常用汇编指令汇总
上一章介绍了伪汇编指令,这一章我们来介绍硬件汇编指令.  

和伪汇编指令不一样的时,硬件汇编指令不针对编译器,而是处理器设计厂商定义的硬件操作指令,正如前文中所说,汇编指令是硬件强相关的,所以在了解硬件汇编指令之前,我们必须对硬件环境有充分的了解.  

armv7 核心寄存器相关知识可以参考我的另一篇博客:TODO
armv7 状态寄存器相关知识可以参考我的另一篇博客:TODO
armv7 协处理器相关知识可以参考我的另一篇博客:TODO
armv7 处理器模式相关知识可以参考我的另一篇博客:TODO
armv7 指令集相关概念和知识可以参考我的另一篇博客:TODO


## armv7 硬件汇编通用信息
除了 armv7-A 架构相关的知识,对应硬件汇编指令而言,有一些公共的,通用的规则需要有一定的了解,才能更方便地编写和阅读汇编指令.  

### 指令后缀
不知道你有没有碰到过这样的情况：在代码中看到某条汇编指令，不清楚它的意思，于是到 armv7 手册中查询，居然也查不到这条指令。这就是因为 armv7 指令集中的汇编指令在一些特定的情况下可以带有一些指令后缀，当然，不同的指令后缀有不同的含义.  

#### 条件执行
armv7 的 arm 指令集中每一条指令的最高四位为 cond 位，表示当前指令的"条件执行"，大部分指令都可以通过指示指令条件来决定当前指令是否执行，通常用作分支指令，而这种指定是否执行的方式就是添加条件执行的后缀，比如 beq，b 是一条跳转指令，而 eq 后缀表示只有当状态寄存器 CPSR 的 Z 位为 1 时才会执行当前指令。  

对于条件执行部分，具体的可以参考我的另一篇博客：TODO。

#### 更新 CPSR
默认情况下，大部分指令都不会更新处理器的状态寄存器 CPSR，但是对于这些指令，可以通过添加后缀 S 来影响 CPSR，比如 adds 指令，如果运算结果为负，CPSR 的 N 位将会被置为，对于其它的状态位也是同样的效果。  

#### 指定指令的长度
armv7 支持多种指令集，对于 thumb 指令集而言，有 16 位指令和 32 位指令两种，Thumb1 只有 16 位，而 thumb2 扩展了 32 位的指令，对于同一个操作，比如 mov r0,#1 ，同时使用 16 位和 32 位的指令都可以实现，汇编器会选择 16 位的指令实现。  

如果添加后缀 .W(wide) 则强制使用 32 位指令，相对应的如果使用 .N(narrow)，则强制使用 16 位指令，16 位和 32 位指令在指令密度、功耗、执行效率等方面都有一些区别，在实际应用中可能因为这个因素而选择不同位数的指令。  

但是，如果强制使用 16 位的指令，但是该指令无法对该指令进行编码，比如寻址范围超出，就会报错。  

因为 arm 指令集都是 32 位的，如果在 arm 指令集中使用 .N 将会直接报错，而 .W 不会产生任何影响。  


### 立即数的合法性
对于一个 32 位或者 16 位的指令，是无法将一个 32 位的立即数装进指令的，所以这时候就需要一些技巧，就是从指令中划分出特定的一些位来表示立即数，通常是 12 位及以下，特殊指令会达到 16 位甚至以上，拿 12 位举例：

其中 8 位表示基数，其余 4 位乘以 2 表示循环位移的位数，8 位最多表示 0~0xff，而循环位移的位数为 0~30，范围可以覆盖到 4G，但是并不是完全覆盖，关于立即数的使用可以参考我的另一篇博客：TODO

### 指令表达式描述约定
对于每一条指令,都对应一条通用表达式,描述该指令的行为,该表达式通过特殊的命名方式代替参数,比如下面是 instruction 指令的描述:

```
instruction{S}<c><q> <Rd>, <Rn>, <Rm>{, <shift>}
```
instruction:标准汇编指令,比如 ADD,SUB,MOV 等.
{ }:被大括号括起来表示可选.
< >:对于参数列表而言,尖括号表示必须的参数,但是指令后缀的 \<c\> 不必须提供.
S:可选的后缀,表示是否更新 CPSR,参考前文中的后缀描述.
c:条件执行后缀.
q:指令宽度后缀,.w 或者 .n,在 thumb 模式下指定指定宽度. 
Rd:目的寄存器,对于 armv7 的汇编指令而言,第一个参数必定是一个寄存器,也体现了 arm 架构中数据只能在寄存器中处理的特性,通常指令结果保存在当前寄存器中.
Rn:第一个操作数寄存器
Rm:第二个操作数
Rs:用于位移的寄存器,同样以 add 指令为例,通常的搭配是: add Rd,Rn,Rm,ROR Rs,表示将 Rm 循环右移 Rs 寄存器中值的位数,得到新的 Rm,然后再执行:add Rd,Rn,Rm,表示 Rd = Rn + Rm .
{,\<shift\>}:可选的移位部分,在上面 Rs 的示例中,示例为 ROS,表示循环右移,其它的移位指令也可以,比如 LRL/ASR/LSR/ASR 等.
\<type\>:同 shift,表示位移指令.  


## 硬件汇编指令
armv7 手册中列出的硬件汇编指令数量比较多,但是就目前而言,学习 armv7 汇编的主要目的是两个:
* 通过学习汇编了解 armv7 架构,同时对处理器的运行原理建立一个大概的认识.
* 对于 linux 底层驱动工作而言,需要使用到汇编语言,比如 Uboot 启动,内核启动,进程调度等贴近底层的部分,要求我们能读懂系统的汇编代码以及能进行相应的修改.  


基于以上两点,博主不会对所有的指令进行详细地解析,而是重点分析一些常用的指令.   

通常情况下,每一条汇编指令可能会对应多种指令集,多种指令形式,以 add 指令为例:
* 对应 thumb 指令集分别存在 thumb1,thumb2,thumb3 三种指令编码
* 对应 arm 指令集存在 arm1,arm2 两种指令编码
* 对应多种指令形式,比如对应寄存器操作类型的,对应立即数操作类型的,不同的类型还可能分为多种小类型,这种指令形式的多样式主要是为了支持指令的灵活性.比如 add r0,r1,r2 和 add r0,r1,#1 两种.

对于使用哪种指令形式,由对应的汇编程序直接指定,而对于使用哪种编码方式,则由编译器自主选择,原则是如果一条汇编指令可以由多种编码实现,时钟选用简单的那种,举个例子,在 thumb 模式下,对于 mov r0,#1 这条指令,使用 16 位指令编码和 32 位 thumb 指令编码都可以,这时候默认使用 16 位指令,当然可以使用 .w 后缀强制指定 32 位.   

**对于一种指令,存在多种编码或者形式,因为篇幅有限,博主只将最常用的几种列出,有兴趣的朋友可以翻阅参考手册来获取更详细的信息.**  

### 数据处理指令

#### mov,movt,movw
mov 是出场率最高的指令之一,表示移动数据到寄存器中,第二操作数可以是:合法的立即数,寄存器.

```
    MOV<c> <Rd>, <Rm>            //Rd = Rm
    MOV{S}<c>.W <Rd>, #<const>   //Rd = #const
```

movw：将一个 16 位数据移动到寄存器的低 16 位，并把高 16 位清零。
movt：将一个 16 位数据移动到寄存器的高 16 位，低 16 位不处理。

因为 movw 和 movt 两条指令可以接受任意的 16 位数据，而不像其它的 mov 类型的指令，需要特定的合法立即数，所以这两条指令经常被用作加载一个 32 位数据：


```
movw r0,0x5678
movt r0,0x1234
```
无论是 thumb 下还是 arm 下，通过这种方式将立即数 0x12345678 加载到 32 位寄存器中是非常方便的。所以，在加载复杂的立即数时，这两条指令非常常用。   


#### add，adc 
add 指令表示加法，对应的表达式：

```
ADD{S}<c>.W <Rd>, <Rn>, #<const>    // Rd = Rn + #<const>
ADD<c> <Rd>, <Rn>, <Rm>             // Rd = Rn + Rm
```

将第一操作数加上第二操作数，结果放在目标寄存器中，操作数可以是目标寄存器。  

adc 表示 add with carry，即进位加法，与 add 指令唯一的区别在于它会加上 CPSR 的 carry 位，在 64 位的加法中，低 32 位数据产生 carry 位，高 32 位在相加的同时就需要使用 adc 指令添加上 carry 位，相当于数学计算中的添加进位。  


#### sub, sbc, rsb, rsc
sub 表示减法指令，对应的表达式为：

```
SUB{S}<c>.W <Rd>, <Rn>, #<const>    // Rd = Rn - #<const>
SUB<c> <Rd>, <Rn>, <Rm>             // Rd = Rn - Rm
```

sub 为减法指令，第一操作数减去第二操作数，结果放在目的寄存器 Rd 中。  

sbc 为带借位的减法指令，在减法指令的操作后减去 !C, C 是 CPSR 中的 carry 位。  

rsb 为 reverse sub 版本的减法指令，它和 sub 的区别在于这是第二操作数减去第一操作数，将结果放在目的寄存器中。  

rsc 为 reverse sbc 版本的减法指令，同样是第二操作数减去第一操作数，同时减去 !C,结果放在目的寄存器中。  



#### and, bic, orr, eor
逻辑处理指令中比较常见的有 逻辑与，位清除，逻辑或，位或。  

and 即位与，逻辑很好理解，就是将操作数位与，然后将结果放在目的寄存器中，操作数可以是寄存器，移位寄存器，表达式如下。  

```
AND<c> <Rdn>, <Rm>                       // Rdn = Rdn & Rm
AND{S}<c> <Rd>, <Rn>, <Rm>{, <shift>}    // Rd = Rn &  (<Rm>{, <shift>})
```

bic 为 清除指定的位，清除源寄存器中给定的位：

```
BIC<c> <Rdn>, <Rm>                       // Rdn = Rdn & ~Rm
BIC{S}<c> <Rd>, <Rn>, <Rm>{, <shift>}    // Rd = Rn &  ~(<Rm>{, <shift>})
```

可以直接使用目的寄存器作为源操作数，清除位由寄存器或者移位寄存器给出。  


orr 表示位或，两个值位或，结果放在目的寄存器：

```
ORR<c> <Rdn>, <Rm>                     // Rdn = Rdn | Rm
ORR{S}<c> <Rd>, <Rn>, <Rm>{, <shift>}  // Rd = Rn | <Rm>{, <shift>}
```

eor 表示异或，两个值异或，结果放在目的寄存器,异或的原则是，相同的位异或结果为 0，不同的位异或结果为 1：

```
EOR<c> <Rdn>, <Rm>                        // Rdn = Rdn ^ Rm
EOR{S}<c> <Rd>, <Rn>, <Rm>{, <shift>}     // Rd = Rn ^ <Rm>{, <shift>}
```


#### lsl, lsr, asr, ror
这一些都是位移指令，位移的特性在于：位移一位相当于乘以2或者除以2，因为位移是处理器直接支持的，所以有很多乘除法直接被优化成位移指令，位移的类型有多种，包括：
* lsl：logical shift left，逻辑左移
* lsr：logical shift right，逻辑右移
* asr：Arithmetic Shift Right，算术右移，带符号位的右移
* ror：Rotate Right，循环右移，被移出的位补充到最高位

上述的位移指令表达式都是一致的：

```
LSL<c> <Rd>, #<const>                   // Rd = Rd << #<const>
LSL{S}<c> <Rd>, <Rm>, #<imm5>           // Rd = Rm << #<imm5>
```


#### cmp, cmn, teq, tst
测试指令，与其它指令不同的是，这些指令会自动将结果更新到状态寄存器中，而不需要选择条件执行。  

cmp：compare 比较指令，实际的操作是将第一操作数减去第二操作数。  
cmn：compare Negative，与 compare 执行相反的操作，将第一操作数加上第二操作数。  
tst：test 指令，将两个操作数位与
teq：test equivalence，测试相等，将两个操作数异或

对于上述四种测试指令，其使用方法相差无几，就以 cmp 为例，列举对应的表达式：

```
CMP<c> <Rn>, <Rm>                   //CPSR.N.Z.C.V = Rn - Rm
CMP<c> <Rn>, <Rm>{, <shift>}        //CPSR.N.Z.C.V = Rn - <Rm>{, <shift>} 
CMP<c> <Rn>, #<const>               //CPSR.N.Z.C.V = Rn - #<const>
```

状态寄存器 CPSR 更新的原理是根据运算结果进行更新，如果结果为负，则 N 置位，为 0，则 Z 置位，产生进位，C 置位，产生溢出，V 置位，关于进位和溢出的规则可以参考我的另一篇博客TODO。

#### msr， mrs
arm 和 thumb 指令集都提供了对状态寄存器的操作，相对于其它核心寄存器而言，状态寄存器更为特殊，因为它涉及到整个系统的状态输出以及部分的系统资源控制，在处理器中，系统资源相关的功能是有严格的权限控制的，所以对于状态控制器的读写也需要遵循相应的规则。  

armv7-A 架构分为九种模式，也可以粗略地分为特权级和非特权级模式，user 模式运行在非特权级，其它模式运行在特权级下，非特权级下不能直接控制状态寄存器即 CPSR，而是访问它的受限版本：APSR。   

对于特权级下，就可以访问所有的 CPSR 资源。  

关于 armv7-A 的处理器模式以及状态寄存器可以参考我的另两篇博客：TODO，TODO

撇开处理器模式不谈，假设当前可以访问所有的 CPSR 资源，对于状态寄存器的操作比较简单：

```
msr cpsr,Rn      //cpsr = Rn
mrs Rn,cpsr      //Rn = cpsr
```

读和谐就是将状态寄存器与核心寄存器之间的数据进行 copy，用户空间下可以使用 cpsr 或者 apsr。



#### ldr, str, stmda，stmdb，stmib
ldr 和 str 是内存操作指令，因为 arm 不支持内存的直接操作，所以它们执行内存和寄存器之间的操作，同样是使用非常频繁的指令。  

对于内存操作，相对其它的指令要复杂一些，在实现操作的前提下，还需要考虑内存访问效率，所以内存操作通常有几种操作模式：
* 使用寄存器进行寻址
* 使用寄存器+偏移地址进行寻址
* 先偏移，取地址值，再对偏移的操作数赋上操作后的值
* 先取地址值，再偏移，然后再对偏移的操作数赋上操作后的值。  

定义看得有些不明白，我们来几个示例就会清晰很多了,值得注意的是，ldr 中存放地址的操作数需要使用 [] 包含：

****

**寄存器直接寻址：**

```
ldr r0,[sp]
```
表示将当前 sp 地址处的数据加载到 r0 中。  

****

**使用寄存器+偏移地址进行寻址：**

```
ldr r0,[sp,#4]          //[sp,#4] 表示 sp+4，其中立即数可以为负数
```
表示将当前 sp+4 地址处的数据加载到 r0 中。  

****

**先偏移，取地址值，再对偏移的操作数赋上操作后的值**

```
ldr r0,[sp,#4]！    //注意需要添加 !。
```
表示取 sp+4 处的地址值，然后将 sp 更新为 sp + 4。

****

**先取地址值，然后再对偏移的操作数赋上操作后的值**

```
ldr r0,[sp],#4
```
先取 sp 地址上的值，在将 sp 更新为 sp + 4.

****

上面的解析是针对于 ldr，事实上对于 str 而言，其寻址模式也是如此，只不过由存变成了取，str 的表达式语法为：

```
str Rn,Rm{,<shift>}   // 表示将 Rm 中地址处的数据加载到 Rn 中。  
```

为什么要做这么多的寻址模式，而不是仅仅实现地址的存取呢？  

这是因为绝大多数的内存操作都来源于对栈的操作，而栈是动态地伸缩的，所以需要对栈的这种自动伸缩特性进行支持，所以就出现了在操作内存的同时对指定的内存地址进行递增的内存寻址模式。  
****

除了常用的 str 和 ldr 之外，还有连续的内存操作指令：stmda，stmdb，stmia，stmib.

其对应的表达式为：

```
STMDA<c> <Rn>{!}, <registers>
```

表示将一系列的寄存器值保存在 Rn 所表示的连续地址处，它们的区别在于：

stmda：Decrement After，操作完一个寄存器之后将 Rn 中保存的地址递减 4.  
stmdb：Decrement Before，操作寄存器之前将 Rn 中保存的地址递减 4.
stmia: Increment After，操作完一个寄存器之后将 Rn 中保存的地址递增 4. 
stmib：Increment before，操作寄存器之前将 Rn 中保存的地址递增 4.  

这种操作通常在切换处理器模式时用于保存现场，将所有寄存器的值保存在当前栈上或者某个内存地址处。  



#### pop，push
pop 和 push 针对的是栈的操作，push 表示将数据压栈，并更新 sp 指针的值，而 pop 表示将数据弹出，并更新 sp 指针的值。  

表达式如下：

```
POP<c> <registers>
PUSH<c> <registers>
```

对于列表的操作(即使是一个)需要使用 { } 包含寄存器列表，而压栈或者出栈的顺序是从右到左，比如：

```
push {r0,r1,r2}
```
表示将 r2，r1，r0 按照顺序 push 到栈上。  




在本章中，所列出的只是一些常见的指令，实际上整个 armv7 支持非常庞大的指令集，甚至包括高级的 SIMD，这里只起一个抛砖引玉的效果，详情可以参考手册 A5 章节对于所有指令的介绍。  









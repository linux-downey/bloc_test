# armvv7汇编系列-2-常用汇编指令汇总
上一章介绍了伪汇编指令,这一章我们来介绍硬件汇编指令.  

和伪汇编指令不一样的时,硬件汇编指令不针对编译器,而是处理器设计厂商定义的硬件操作指令,正如前文中所说,汇编指令是硬件强相关的,所以在了解硬件汇编指令之前,我们必须对硬件环境有充分的了解.  

armv7 核心寄存器相关知识可以参考我的另一篇博客:TODO
armv7 状态寄存器相关知识可以参考我的另一篇博客:TODO
armv7 协处理器相关知识可以参考我的另一篇博客:TODO
armv7 处理器模式相关知识可以参考我的另一篇博客:TODO
armv7 指令集相关概念和知识可以参考我的另一篇博客:TODO


## armv7 硬件汇编通用信息
除了 armv7-A 架构相关的知识,对应硬件汇编指令而言,有一些公共的,通用的规则需要有一定的了解,才能更方便地编写和阅读汇编指令.  

### 指令后缀
不知道你有没有碰到过这样的情况：在代码中看到某条汇编指令，不清楚它的意思，于是到 armv7 手册中查询，居然也查不到这条指令。这就是因为 armv7 指令集中的汇编指令在一些特定的情况下可以带有一些指令后缀，当然，不同的指令后缀有不同的含义.  

#### 条件执行
armv7 的 arm 指令集中每一条指令的最高四位为 cond 位，表示当前指令的"条件执行"，大部分指令都可以通过指示指令条件来决定当前指令是否执行，通常用作分支指令，而这种指定是否执行的方式就是添加条件执行的后缀，比如 beq，b 是一条跳转指令，而 eq 后缀表示只有当状态寄存器 CPSR 的 Z 位为 1 时才会执行当前指令。  

对于条件执行部分，具体的可以参考我的另一篇博客：TODO。

#### 更新 CPSR
默认情况下，大部分指令都不会更新处理器的状态寄存器 CPSR，但是对于这些指令，可以通过添加后缀 S 来影响 CPSR，比如 adds 指令，如果运算结果为负，CPSR 的 N 位将会被置为，对于其它的状态位也是同样的效果。  

#### 指定指令的长度
armv7 支持多种指令集，对于 thumb 指令集而言，有 16 位指令和 32 位指令两种，Thumb1 只有 16 位，而 thumb2 扩展了 32 位的指令，对于同一个操作，比如 mov r0,#1 ，同时使用 16 位和 32 位的指令都可以实现，汇编器会选择 16 位的指令实现。  

如果添加后缀 .W(wide) 则强制使用 32 位指令，相对应的如果使用 .N(narrow)，则强制使用 16 位指令，16 位和 32 位指令在指令密度、功耗、执行效率等方面都有一些区别，在实际应用中可能因为这个因素而选择不同位数的指令。  

但是，如果强制使用 16 位的指令，但是该指令无法对该指令进行编码，比如寻址范围超出，就会报错。  

因为 arm 指令集都是 32 位的，如果在 arm 指令集中使用 .N 将会直接报错，而 .W 不会产生任何影响。  


### 立即数的合法性
对于一个 32 位或者 16 位的指令，是无法将一个 32 位的立即数装进指令的，所以这时候就需要一些技巧，就是从指令中划分出特定的一些位来表示立即数，通常是 12 位及以下，特殊指令会达到 16 位甚至以上，拿 12 位举例：

其中 8 位表示基数，其余 4 位乘以 2 表示循环位移的位数，8 位最多表示 0~0xff，而循环位移的位数为 0~30，范围可以覆盖到 4G，但是并不是完全覆盖，关于立即数的使用可以参考我的另一篇博客：TODO

### 指令表达式描述约定
对于每一条指令,都对应一条通用表达式,描述该指令的行为,该表达式通过特殊的命名方式代替参数,比如下面是 instruction 指令的描述:

```
instruction{S}<c><q> <Rd>, <Rn>, <Rm>{, <shift>}
```
instruction:标准汇编指令,比如 ADD,SUB,MOV 等.
{ }:被大括号括起来表示可选.
< >:对于参数列表而言,尖括号表示必须的参数,但是指令后缀的 \<c\> 不必须提供.
S:可选的后缀,表示是否更新 CPSR,参考前文中的后缀描述.
c:条件执行后缀.
q:指令宽度后缀,.w 或者 .n,在 thumb 模式下指定指定宽度. 
Rd:目的寄存器,对于 armv7 的汇编指令而言,第一个参数必定是一个寄存器,也体现了 arm 架构中数据只能在寄存器中处理的特性,通常指令结果保存在当前寄存器中.
Rn:第一个操作数寄存器
Rm:第二个操作数
Rs:用于位移的寄存器,同样以 add 指令为例,通常的搭配是: add Rd,Rn,Rm,ROR Rs,表示将 Rm 循环右移 Rs 寄存器中值的位数,得到新的 Rm,然后再执行:add Rd,Rn,Rm,表示 Rd = Rn + Rm .
{,\<shift\>}:可选的位移部分,在上面 Rs 的示例中,示例为 ROS,表示循环右移,其它的移位指令也可以,比如 LRL/ASR/LSR/ASR 等.
\<type\>:同 shift,表示位移指令.  


## 硬件汇编指令
armv7 手册中列出的硬件汇编指令数量比较多,但是就目前而言,学习 armv7 汇编的主要目的是两个:
* 通过学习汇编了解 armv7 架构,同时对处理器的运行原理建立一个大概的认识.
* 对于 linux 底层驱动工作而言,需要使用到汇编语言,比如 Uboot 启动,内核启动,进程调度等贴近底层的部分,要求我们能读懂系统的汇编代码以及能进行相应的修改.  

基于以上两点,博主不会对所有的指令进行详细地解析,而是重点分析一些常用的指令.   

通常情况下,每一条汇编指令可能会对应多种指令集,多种指令形式,以 add 指令为例:
* 对应 thumb 指令集分别存在 thumb1,thumb2,thumb3 三种指令编码
* 对应 arm 指令集存在 arm1,arm2 两种指令编码
* 对应多种指令形式,比如对应寄存器操作类型的,对应立即数操作类型的,不同的类型还可能分为多种小类型,这种指令形式的多样式主要是为了支持指令的灵活性.比如 add r0,r1,r2 和 add r0,r1,#1 两种.

对于使用哪种指令形式,由对应的汇编程序直接指定,而对于使用哪种编码方式,则由编译器自主选择,原则是如果一条汇编指令可以由多种编码实现,时钟选用简单的那种,举个例子,在 thumb 模式下,对于 mov r0,#1 这条指令,使用 16 位指令编码和 32 位 thumb 指令编码都可以,这时候默认使用 16 位指令,当然可以使用 .w 后缀强制指定 32 位.   

对于一种指令,存在多种编码或者形式,因为篇幅有限,博主只将最常用的几种列出,有兴趣的朋友可以翻阅参考手册来获取更详细的信息.  

### 数据处理指令

#### mov,movt,movw
mov 是出场率最高的指令之一,表示移动数据到寄存器中,第二操作数可以是:合法的立即数,寄存器.

```
    MOV<c> <Rd>, <Rm>            //Rd = Rm
    MOV{S}<c>.W <Rd>, #<const>   //Rd = #const
```











# GNU 链接脚本1 -  section 的输入输出

### SECTIONS 相关命令

SECTIONS 是一个链接脚本的主体部分，后接一个大括号，大括号中放置各种子命令，告诉链接器如何将一个或多个输入文件中的段映射到输出文件中，SECTIONS 的子内容中默认包含地址定位符 "."，所有程序段、数据段的最终分配地址都是根据这个地址定位符来确定。  

通常每个链接脚本中都会存在这个关键字，如果一个链接脚本中没有指定 SECTIONS，链接器会执行默认行为：将所有输入文件中名字相同的段放到一起，按照各个段出现的先后顺序，不做任何合并，最终生成出来的输出文件自然会是非常散乱的，正常情况下，链接脚本都会有规划地将相同属性的段放到一起甚至进行合并成同一个段，然后多个同属性的段链接到同一个 segment 中，加载和运行都作为一个整体。所以 SECTIONS{} 的行为更像是一个容器。  

SECTIONS 中子命令主要包含下列这些功能：



* 指定程序入口点(见上文)
* 符号定义和操作
* 输出文件的描述
* overlay 操作描述

### 地址定位符

地址定位符 "." 是內建在 SECTIONS 命令中,用于指示当前虚拟地址定位的,当输出段不显式指定虚拟地址和内存区域时,该段的所属的运行时内存地址等于当前地址定位符的值.  

初始状态下,地址定位符为 0,可以通过赋值语句给地址定位符赋值,同时,地址定位符会在放置输出段时自动更新,比如当前地址定位符值为 0x100,放置了 .text,size 为 0x123,则地址定位符自动更新到 0x223.  

### 输出 section

输出的 section 的完整描述是这样的：

```
section [address] [(type)] :
[AT(lma)]
[ALIGN(section_align)]
[SUBALIGN(subsection_align)]
[constraint] {
output-section-command
output-section-command
...
} [>region] [AT>lma_region] [:phdr :phdr ...] [=fillexp]
```

看起来是非常复杂的，在上述的示例中我们仅仅是使用了 .text = {*(.text) 来生成 .text 段，实际上大部分可选参数只有在一些复杂的应用下才会出现，既然列出来了，自然是要说一说的。   

### section 名称

链接器并不仅仅只是针对 linux 下的 elf 格式,还有 a.out,coff 等格式,对于某些格式而言,对于输出段的名称有严格的限制,比如 a.out 对段的数量和段名有相应限制,只支持特定名称的段:.text,.data,.bss(不同平台会有一些小区别),不允许随意地自定义段名.  

而对于 elf 而言,支持自定义段及段名,在系统默认的链接脚本中,所有的段名都是以 "." 开头,用户也可以使用 "1FOO" 这种比较特殊的段名,尽管对命名没有硬性限制,但是实际编程中遵循标准语法是一种好习惯.   

自定义段是通过 gcc 的扩展实现的,下面的例子就是将全局变量放置到自定义段中:

```
__attribute__((section(".mfoo"))) int global = 0;
```

一般情况下,在链接脚本中会定义一个变量来指示该段的起始地址,然后在程序中通过该变量对段中的数据进行操作,可以看下面的示例:  

```
__mfoo_start = .
.mfoo = {*(.mfoo)}
__mfoo_end = .
```

在程序中通过 \_\_mfoo_start 和 \_\_mfoo_end

两个变量定义段数据的位置,至于自定义段中的数据如何处理,完全取决于编程者.  

尽管在程序编译时这两个变量还没有定义,这就像一个模块中使用另一个模块的符号(变量)一样,使用 extern 关键字进行声明,链接脚本中定义的变量和其它的全局变量一样会被添加到全局符号中,链接时同样通过符号解析和重定位将变量地址绑定到引用变量的程序处.   




### 输出段地址

输出段的地址直接决定了该段在内存运行的虚拟地址(arm32下是相等的,arm64下会多一层映射,因此不相等),这个地址可以由三种方式给定,优先级依次降低:



* 可以在脚本中直接给出,在对应的输出段后指定,比如: .text 0x1000 :{*(.text)} 就指定了 .text 的地址为 0x1000
* 通过内存区域进行分配,段分配到哪个内存区域就会被分配对应的
* 如果前两者都没有指定,就会使用地址定位符的当前值.   

在上文中我们提到了每个段都对应两个地址,VMA 和 LMA,对于 lma 而言也可以通过指定或者指定到定义地址内存区域:

```
MEMORY
{
    rom(rx) : ORIGIN = 0x8000,LENGTH = 10K
    ram(w) : ORIGIN = 0x10000,LENGTH = 10K
}

SECTIONS
{
    ...
    .text 0x2000 : AT(0x30000) { *(.text) } >rom AT>ram
    ...
}
```

我们可以看上面的示例, .text 后的 0x2000 表示直接指定段的虚拟地址,尽管之后将其指定到了 rom 内存区域处,由于内存区域的优先级低于直接指定,所以最后的 .text 的虚拟地址为 0x2000.同时,由于指定了 AT>ram ,.text 的加载地址为 ram 的地址范围,具体加载地址取决于 ram 中是否已经保存了数据,紧随在上一个段数据之后.  

我们可以通过 readelf -S 命令来查看各个段信息,其中 addr 表示虚拟内存地址,然后使用 readelf -l 查看各个 segment 的信息,其中 VirtAddr 表示虚拟地址,PhysAddr 表示加载地址.   



### 对齐参数

在计算机中,大多数地方都可以看到对齐的概念,对齐的主要目的是提高数据访问的速度,elf 文件中也不例外,每个段都带有特定的对齐参数,在段命令中也可以设置对齐参数,对齐主要使用命令:ALIGN.  

ALIGN 表示输出段之间的对齐参数,即输出文件中每个段的的起始位置需要满足的条件.比如 ALIGN(8) 表示当前起始地址需要能被 8 整除,如果不能被 8 整除,就向上调整到能被 8 整除的第一个值,而不是需要增加一个 8 字节的间隔.  

ALIGN 有两种形式:



* ALIGN(align_num)
* ALIGN(exp,align_num)
  第一种方式默认使用地址定位符 '.' 作为基准,表示在地址定位符的值上进行对齐,第二种中的 exp 可以是任意的表达式,返回在 exp 的基础上进行对齐.   

比如 ALIGN(0x1234,0x1000) 表示在 0x1234 的基础上向 0x1000 对齐,返回对齐值.    

需要注意的是,ALIGN 命令只是返回对齐后的地址值,仅仅做算术运算,并不会改变地址定位符的值.  

来看下面的例子:

```
SECTIONS
{
    .text ALIGN(0x1000) : {* (.text)}
}
```

在上述示例中, ALIGN(0x1000) 表示返回当前地址对齐 0x1000 后的地址,假设当前地址是 0x1234,对齐之后地址为 0x2000,上述命令就变成了:

```
SECTIONS
{
    .text 0x2000 : {* (.text)}
}
```

这条命令就相当于设置 .text 起始地址为 0x2000,同时将地址定位符更新到 0x2000,这种用法是比较常见的,还有一种情况是 ALIGN 仅用于计算的时候:

```
_start = ALIGN(0x1234,0x1000)
```

结果为 _start 的值为 0x2000,这种结果并不会对地址定位符产生任何影响.  

一般来说,ALIGN 的应用都是直接放在段命令中,纯应用于算数的情况并不多.  



### 输出段数据

在链接脚本中支持显式地往段中添加自定义数据，使用 BYTE, SHORT, LONG, QUAD, SQUAD 这些命令可以添加对应字节数长度的数据，如果使用地址定位符，表示添加到当前地址定位符指定地址处，地址定位符同时更新，同时也可以添加到指定的区域中。  

当系统为 64 位时，QUAD 和 SQUAD 都是 8 字节，32 位系统时，QUAD 为 4 字节，而 SQUAD 是 8 字节。所有的这些值设置命令需要包含在段命令中，而不应该放在段命令和段命令之间：

```
错误做法：
    SECTIONS { .text : { *(.text) } LONG(1) .data : { *(.data) } }
正确做法：
    SECTIONS { .text : { *(.text) ; LONG(1) } .data : { *(.data) } }
```

同样也可以使用 FILL 命令在段中填充数据。  



### 输出 segment

链接器自动地将相同属性的段组合成一个 segment,同时对一些特殊的段进行特定处理,比如为 .dynamic 段生成一个 PT_DYNAMIC 属性的 segment,对于 PT_LOAD 属性的 segment 而言,这些段是程序运行所必须的指令或者数据,一般情况下链接器会根据读写执行属性划分出两个 segment,一个 R/E 的只读 segment,一个 R/W 的读写数据 segment,在加载的时候比较方便.   

链接器划分 segment 的行为主要从内存空间考虑,即相同的段尽量合并,如果相连的段对应虚拟地址之间存在较大的空隙,就会另立一个 PT_LOAD 的 segment,同时,用户可以在链接脚本中手动地指定某个段对应的的 segment:

```
PHDRS { text PT_LOAD ; }
SECTIONS { .text : { *(.text) } :text }
```

上面的指令指定了一个名为 text 的 segment,为 PT_LOAD 属性,在 SECTIONS 中指定最后生成的 .text 段放置在该 segment 中.  

需要注意的是,一旦使用了这种指定 segment 的指令,随后所有的段都会默认放置在指定的段中,比如上面的指令中,如果不再特殊指定,链接脚本中 .text 段后面列出的所有段都会放到 text segment 中,同时链接器生成 segment 的默认行为将失效,也就是不会再为 .dynamic 生成特殊的 segment,手动指定 segment 需要非常小心,一旦手动指定,你就需要手动地完成所有段的 segment 分配.    

同样的设计思想在上面指定内存区域处也有体现,一旦设定内存区域,SECTIONS{} 中的地址定位符 "." 将不再起作用,意思很明确:如果你要手动指定,那就全部由你手动指定.  



## 输入文件(段)

### 输入文件格式

在之前的示例中,都是简单地使用 *(.text) 来组织输入文件,实际上,输入文件的指定也是非常灵活的.  

指定输入文件内容的基本规则为: file(sections),比如 

```
.mix : data.o(.data .text) 
```

表示输入的段为 data.o 文件中的 .data 段和 .text 段,输出段为 .mix. 除了直接指定文件名之外，还支持指定库中的文件，比如通过 $archive_name:$file_name(sections) 指定静态库中特定文件， $archive_name:(sections) 表示指定库，:$file_name(sections) 指定非静态库中的文件。 $file_name 表示将整个文件中的所有段作为输入合并到一个输出段中。  

在实际的链接中，指定单个输入文件的情况并不多见，通常情况下存在多个输入文件，而多个输入文件中段内容是相似的，如果一个个地指定是非常麻烦的，因此，一般的链接脚本都是用通配符。  

最常用的就是通配符 '*',链接脚本中支持以下通配符:



* '\*':匹配所有字符,\*(.text) 中的 \* 所有文件名中的 .text 段
* '\[chars\]':范围匹配,比如[a-z]表示匹配所有小写字符
* '?':匹配单个字符
* '\':转义字符
  在使用通配符时不会将 '/' 作为通配符对待,因为在linux中这是目录分隔符.下面是一些使用通配符的示例：

* \*(.text .rdata):表示将所有文件中的 .text .rdata 作为输入段，放置顺序为每个文件的 .rdata 紧随着 .text.
* \*(.text) \*(.rdata):将所有文件的  .text .rdata 作为输入段，放置顺序为先是所有文件 .text 的组合，然后是 .rdata 的组合
* \*(EXCLUDE_FILE (\*crtend.o \*otherfile.o) .ctors):除了以 crtend.o 和 otherfile.o 为结尾的文件，将其它所有文件的 .ctors 段作为输入段。  

如果一个输入部分同时匹配多个输入语句，可能 foo.o(.text) 被作为某个输出段的输入，同时又匹配上了某个输入规则为 *(.text) 的输出段，链接器会选择第一个匹配成功的语句而忽略后续的。   

除了选择输入的段之外，还支持对多个将要合并的段排序，默认情况下，段的合并顺序是根据提供的文件的先后顺序，这时可以通过一些內建函数来调整各个输入段的放置顺序：



* SORT_BY_NAME(files(sections)):将输入的段以名称进行升序排序
* SORT_BY_ALIGNMENT(files(sections)):将输入的段以对齐参数进行升序排序
* SORT：SORT_BY_NAME 的别名

SORT_BY_NAME 和 SORT_BY_ALIGNMENT 实现的功能也可以通过命令行传入，分别对应 --sort-section name 和 --sort-sections alignment。对于大部分的软件而言，当命令行和配置文件有冲突时，以命令行参数为准。    



### COMMON 段的输入

gcc 中有一个段需要特别拿出来解释一下，那就是 COMMON 段，在我们之前读过的书中，大部分都会说到：未初始化的全局变量会保存在 bss 段，在可执行文件中这是没有问题的，但是在目标文件和静态库中，它是被保存在 COMMON 部分的，这是因为 gcc 强弱符号的机制，也就是程序不同的文件中可以定义同名变量，而已经初始化的变量为强符号，为初始化的为弱符号，强符号可以覆盖弱符号(关于gcc强弱符号的扩展可以参考 [c语言强弱符号](https://zhuanlan.zhihu.com/p/363018967))。  

因此，如果两个目标文件中定义了同名变量，如果将它们都放在 data 或者 bss 段，在原本的编译器实现中，是不允许 data bss 段中存在同名变量的，又因为强弱符号机制是后续的扩展功能，不能修改原先的机制，所以需要使用其它的机制来实现：先把弱符号放在 COMMON 段，在链接的时候再决定使用哪个。  

COMMON 段实际上不是一个真正的段，查看段表信息也看不到任何和 COMMON 相关的信息，COMMON 部分的信息被保存在符号表中，符号标志位为 COMM，使用 nm 指令或者 readelf -s 查看。

在链接脚本中，通常会见到这样的段命令：

```
.bss 
{ 
    *(.bss) 
    *(COMMON)
    ... 
}
```

也就是将各个文件中的 COMMON 符号放到 bss 段中，其中会涉及到强弱符号的解析，某些 COMMON 符号可能会被删除，尽管COMMON 并不是一个段，但是连接脚本中将它当成一个输入段。   



#### 保留输入段

在链接的过程中，为了节省空间通常会删除一些不必要的段，通常是没有被引用的部分，KEEP 命令用于将那些未引用的段保留，
这些段可能另作他用，比如提供给加载器的辅助信息，或者 debug 信息。  



#### 输出段生成规则

在链接阶段,链接器只会生成有实际内容的段,当一个段命令中的输入段不存在时,并不会生成输出部分,举个例子:

```
 .foo : {*(.foo)}
```

只有当至少一个输入文件中包含 .foo 段时,才会在输出文件中生成 .foo 段,否则不生成.  

如果需要显式地忽略某个输入段,可以使用 /DISCARD/ 命令进行设置,例如:

```
/DISCARD/ : {*(.note.GNU-stack) }
```

表示将所有输入文件中的 .note.GNU-stack 段丢弃. 




## 链接脚本中的表达式

链接脚本中的表达式和 C 中的表达式是一样的,所有的的表达式结果都是整型,而且 size 是一样的,在 32 位下为 32 位,64 位系统为 64 位.可以使用变量符号的值进行计算.  

在链接器中,内部定义了一系列的函数以及宏可以在表达式中使用.  

### 整型常量

在 C 中,对于整型可以使用 0 开头表示八进制, 0x 或者 0X 表示十六进制,链接脚本语法在其基础上进行了扩展,可以使用后缀 h 或 H ,o 或者 O ,b 或者 B ,d 或者 D 表示对应的进制数.  

同时,还扩展使用 K 和 M 后缀来表示 1024 和 1024*1024,这对于内存的操作是非常方便的.

### 符号常量

MAXPAGESIZE:最大的的 page size,在 32 位 arm-gcc 上为 0x8000;
COMMONPAGESIZE:默认 page size,在 32 位 arm-gcc 上为 0x1000;

这两者不能单独使用,通常和 CONSTANT(name) 组合使用,例如:

```
.text ALIGN(CONSTANT (MAXPAGESIZE)) : { *(.text) }  //对齐到 MAXPAGESIZE
```

### 內建函数

在链接脚本的规则中,提供了许多內建函数以方便链接脚本的编写.



* ADDR(section):返回指定名称的段地址(VMA)
* ALIGN(align_value),ALIGN(exp,align_value):返回根据对齐参数对齐后的地址,详情在上文中有介绍
* ALIGNOF(section):返回对应段的对齐参数
* DATA_SEGMENT_ALIGN(maxpagesize, commonpagesize):等于 (ALIGN(maxpagesize) + (. & (maxpagesize - commonpagesize))),其中 maxpagesize 的值必须大于等于 commonpagesize.  
* DEFINED(symbol):检查符号是否定义
* LENGTH(memory):返回定义内存区域的长度
* LOADADDR(section):返回指定段的加载地址
* MAX(exp1, exp2),MIN(exp1, exp2):比较两个表达式的值,返回大/小值
* ORIGIN(memory):返回一个内存区域的 ORIGIN 值,即起始值
* SEGMENT_START(segment, default):返回指定名称的 segment 的地址,如果该 segment 没有被指定地址,就返回 default 值, segment 名是在链接过程中使用的一个中间名称,用户可以在命令行通过 -Ttext-segment,-Trodata-segment 等默认 segment 的地址, segment 名只有在链接过程有意义,不会保存到输出文件中.  
* SIZEOF(section):返回一个段的 size
* SIZEOF_HEADERS,sizeof_headers:返回 Program header 的 size



## 隐式链接脚本

当用户指定的输入文件不能被链接器解析为目标文件时,链接器会尝试将它当做链接脚本进行解析,如果解析失败,链接过程将会报错,通过这个规则可以实现链接过程的隐式链接脚本,隐式链接脚本的优先级低于默认的链接脚本.





### 参考

[The GNU Link](https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_mono/ld.html#SEC16)

---

[专栏首页(博客索引)](https://zhuanlan.zhihu.com/p/362640343)

原创博客，转载请注明出处。








# arm 的嵌入汇编
在靠近硬件的编程部分，通常使用 C/C++ 来实现，这是因为 C 足够底层，提供了直接对内存的精准操控，这是某些上层语言所不具备的功能，而应用程序员写代码本质上都是在内存中对各种数据进行处理。  

但是，在贴近硬件的一侧，事实上还有很多 C 语言所做不到的事，需要汇编语言来实现，比如获取当前栈指针、操作 CPU 内部的状态寄存器,在这种情况下，需要直接使用汇编来实现更灵活的操作。  

汇编和 C 语言各自有着非常明显的特点，C 语言有更好的开发效率，而执行效率较汇编要低，汇编在编码速度、代码可读性、可维护性等方面的缺陷是非常明显的，而汇编带来的执行效率的提升也被硬件的高速发展稀释，所以只有在必要情况下，才会使用汇编语言来实现功能，这中必要情况通常是两种情况：



* C 语言做不了但是汇编能做的事：最典型的就是系统的 bootloader 部分，C 语言的执行是依赖于一定的执行环境的，而这个环境需要更底层的汇编语言给它创造，所以操作系统的 bootloader 的 early start 部分由汇编实现，当然，除了这个还有很多硬件强相关的操作都需要汇编来做，比如进程切换时、中断的初始化。
* 对执行效率有极高要求的情况，最典型的情况在于系统执行非常频繁的部分，因为执行非常频繁，很小的效率提升叠加起来也足够引起重视。   



## C 和 汇编的混合使用
相对于汇编来说，C 确实是太好用了，好用到能用 C 的情况下坚决不使用汇编。又或者说我在 C 函数中需要获取栈指针的值，这需要使用到汇编，但是我又不想破坏函数结构，这就要求 C 和汇编能够混合使用，这其中就包含两个要求：



* 汇编中可以直接嵌入 C 函数
* C 中可以嵌入汇编代码



## 汇编调用 C 函数

汇编嵌入 C 函数的实现非常简单，当我们需要在汇编中调用 func 时，直接使用下面的汇编代码就可以实现：

```
bl func
```
bl 是一条跳转指令，程序流将跳转到目标符号地址执行，并将返回地址(当前指令的下一条地址)保存在 lr 寄存器中，提供子程序的返回。



## C 代码中嵌入汇编

而 C 中嵌入汇编代码由 gcc 编译器实现的，实现也非常简单，使用由编译器提供的 asm 或者 \_\_asm\_\_ 关键字即可,这两者没有任何区别，然后将需要执行的汇编指令使用("")包含起来即可，对应的汇编指令就会被执行。  

我们来看看下面的嵌入汇编代码：

```
void func(void)
{
	...
	asm("mov r1,r0");
	__asm__("mov r2,r1");
	...
}
```

代码非常简单，将寄存器 r0 的值赋值给 r1，然后赋值给 r2。这是最简单的汇编指令，但是，通常情况下，这样的汇编代码没有产生输入输出的行为，也就对函数的执行不能做出正向的贡献。  

事实上，在子程序的调用时，这种代码可能是有用的，因为在 arm 中 r0~r3 被用来传递参数和返回值。

之所以说正向的贡献是因为这种操作可能产生负面的影响，因为 r0~r2 寄存器很可能正在被程序的其它部分使用而在这里被意外地修改。

而更多地情况是，C 函数中调用汇编函数，是需要汇编指令进行一些特定的操作，然后在 C 函数中使用相应的操作结果，实现 C 和嵌入汇编代码的"交互"，这就需要使用到嵌入汇编的另一种表达形式：

```
asm(code : output operand list : input operand list : clobber list);
```

这种嵌入汇编的形式一共分为四个部分：



* code
* [attr]output operand list
* [attr]input operand list
* clobber list


output operand list：表示输出的操作数，通常是一个或者多个 C 函数中的变量。  

input operand list：表示输入的操作数，通常是一个或者多个 C 函数中的变量，attr 部分表示操作数的属性，以字符串的形式提供，是必须的参数。  


code：汇编的操作代码，一条或者多条指令，如果是多条指令，需要在指令间使用 \n\t 隔开。与通用的汇编代码有一些不同：因为支持 C 变量的操作，所以在操作由第二、三部分提供的操作数时，使用 %n 来替代操作数。  

clobber list：被破坏的列表，这部分我们放到后面讨论。  

看下面的示例：

```
void func(void)
{
        int val1 = 111,val2 = 222;
        asm("mov %0,%1"
        :"+r"(val1)
        :"r"(val2)
        :);
        printf("val1 = %d\n",val1);
}

```

先说结论：func 函数的输出结果为：

```
val1 = 222
```

显然，val1 的值原本是 111，val2 的值为 222，嵌入汇编指令部分实现了将 val2 的值赋值给 val1.  

由上面对指令语法的描述进行分析：



* 输出操作数为 val1，属性为 "=r"。
* 输入操作数为 val2，属性为 "r"
* code 部分为 mov %1,%0, %0 表示输入输出列表中的第一个操作数，%1 表示操作数列表中提供的第二个操作数，以此类推，这条汇编指令很明显就是将第二个操作数(val2)赋值给第一个操作数(val1),所以最后的结果为 val1 = 222.  。  
	code 中的操作数命名顺序为输出操作书列表递增，输入操作数列表递增，比如增加一个操作数的代码为：
	```
		int val1 = 111,val2 = 222,val3=333;
		asm("mov %0,%2"
		:"+r"(val1)
		:"r"(val2),"r"(val3)
		:);
	```



### 操作数属性值
在上述的示例中，输入操作数和输出操作数都会使用到 attr 字段，即操作数的属性，下面是其属性对应的列表：

![](https://gitee.com/linux-downey/bloc_test/raw/master/zhihu_picture/armv7/pre_attr_pic.jpg)



* "=" 表示只写，通常用于所有输出操作数的属性
* "+" 表示读写，只能被列为输出操作数的属性，否则编译会报错。

在输出操作数中，必须指定其中一个。  

![](https://gitee.com/linux-downey/bloc_test/raw/master/zhihu_picture/armv7/post_attr_char_pic.jpg)

从图中可以看出，除了最常应用到的 "r" 属性(使用通用寄存器处理操作数)，还有其他的很多特性，包括使用浮点寄存器
("f")，或者使用立即数("I")等等，对于 arm 和 thumb 指令集也有较大的区别。  




### clobber list
接下来我们来讨论 asm 表达式的第四部分，也就是 clobber list，clobber 的意思为破坏，在这里的意思是：这段汇编指令将会破坏哪些寄存器的值。   

这个问题看起来有点奇怪，嵌入汇编代码和 C 代码都是由 gcc 统一编译的，难道 gcc 不能分析出汇编代码中使用了哪些寄存器，而非要人为来指定？   

答案还真就是这样，在目前的 gcc 设计中，编译分为4个过程：预编译、编译、汇编、链接。  

其中，编译就是将 C 代码编译成汇编代码，而通用的汇编代码在这个过程是不会处理的，也就是说，嵌入汇编代码的解析只涉及到输入输出操作数的替换，对于不包含输入输出操作数的部分不会解析，所以在编译阶段，编译器不会知道嵌入汇编代码中静态地使用到哪些寄存器，而是自顾自地编译 C 代码，从而导致 C 代码和嵌入汇编代码操作到同一个寄存器，而出现错误。  
比如下面的代码：

```
void func(void)
{
    asm("mov lr,#1");
}
```

在嵌入汇编代码中，将 lr 的值修改为 1，当前函数返回的时候也就返回到 1 地址，不出意料，程序出现段错误：

```
Segmentation fault (core dumped)
```


解决办法是：将程序修改一下：

```
void func(void)
{
    asm("mov lr,#1":::"lr");
}
```

重新编译程序，func 可以正常执行并返回。  


为了进一步追求真相，我们来对比它们的反汇编代码，：

不添加 clobber list 的反汇编代码。
```
000083f4 <func3>:
    83f4:       b480            push    {r7}
    83f6:       af00            add     r7, sp, #0
    83f8:       f04f 0e01       mov.w   lr, #1
    83fc:       46bd            mov     sp, r7
    83fe:       f85d 7b04       ldr.w   r7, [sp], #4
    8402:       4770            bx      lr
```

添加 clobber list 的反汇编代码。

```
void func3(void)
{
    83f4:       b580            push    {r7, lr}
    83f6:       af00            add     r7, sp, #0
    83f8:       f04f 0e01       mov.w   lr, #1
}
    83fc:       bd80            pop     {r7, pc}
    83fe:       bf00            nop
```

对比可以看出，对于不将 "lr" 添加到 clobber list 中的代码，返回指令为 bx lr，因为 lr 被修改为 1，所以返回一定出错。  

而第二个代码则不一样，在函数调用之初，就将 lr 寄存器使用 push 指令保存到了栈上，在最后返回的时候再将栈上的原 lr 数据 pop 到 pc 指针中，其中 lr 的修改没有任何影响。  

这就相当于程序中通知编译器："我在程序中使用嵌入汇编代码修改了lr，你看着办吧"，得到这个信息的编译器就会采取一些备用措施来保证 lr 的修改不影响到程序的正常运行。这就是 clobber list 的作用。  

通常情况下，clobber list 对应着寄存器的修改，所以我们只需要将寄存器的名字作为参数添加到 clobber list 中，比如 "r0" "lr" 等，有两个特殊的参数需要关注，就是 "cc" 和 "memory"。  

"cc" 对应的并非是普通寄存器，而是 CPU 的状态寄存器，如果某些指令将状态寄存器修改了，需要在 clobber list 中添加 "cc" 来声明这个事情。

"memory" 对应内存操作，这从名称也可以看出，当 clobber list 中包含 "memory" 时，表示嵌入汇编代码会对内存进行一些操作，gcc 生成的代码会将特定的寄存器的值写回到内存中以保证内存中的值是最新的，这样做的原因是 gcc 经常会将内存数据缓存在寄存器中，如果不及时写回，嵌入汇编代码读到的内存就是原来的值。  

### volatile 关键字
在 C 语言中，对于共享的全局变量，我们总是会强调使用 volatile 关键字，以避免编译器自作主张地对数据进行优化(通常是寄存器缓存缓存)而导致的问题，在嵌入汇编中，同样存在优化问题，对于某些嵌入汇编指令，它可能没有输入输出，编译器会认为它对整个程序并不起任何作用，从而将这条指令"优化"(通常是删除)，volatile 和 \_\_volatile\_\_ 关键字就可以防止这种事情的发生，比如下面这条指令：

```assembly
asm __volatile__ ("mov r0,r0");
```

这种优化并非存在统一的标准，而是由编译器实现，对于不同的编译器完全可能有不同的实现，出于平台兼容性的考虑，对于某些平台可加某些平台可不加都会加上。   

比如对于 CPU 内部状态寄存器的操作，就不会有输入输出，通常都会加上。  






### 参考

[官方手册：[inline-arm-assembly](https://gcc.gnu.org/onlinedocs/gcc-9.3.0/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C)](https://gitee.com/linux-downey/bloc_test/blob/master/%E6%96%87%E6%A1%A3%E8%B5%84%E6%96%99/armv7-A-R%E6%89%8B%E5%86%8C.pdf)



[专栏首页(博客索引)](https://zhuanlan.zhihu.com/p/362640343)








# armv7-A系列10 - armv7 跳转指令以及指令集切换
由于arm使用的是精简指令集，相对于 x86 的汇编，指令编码要相对简单很多，每条 arm 指令都是 32 位而且操作都是地址对齐的，跳转指令是程序运行的核心部分，自然需要重点讲一讲。  

armv7 的跳转方式分为以下两种:



* b，bl 指令，指定地址进行跳转
* 设置 PC 指针的值实现跳转

同时，因为 armv7 同时支持 arm 和 thumb 指令集，所以在跳转时还会涉及到指令集的切换，在这一章中，我们将讨论这两个话题:跳转和指令集切换。  


## 跳转

### 跳转指令

标准的跳转指令有两种:b，bl，由此衍生出的 bx，blx，bnz 等等，b 和 bl 的区别非常简单: 



* b 表示直接跳转
* bl 先将下一条指令地址保存在 lr 中，然后执行跳转，这样有利于程序的返回，如果是是汇编调用 C 程序，在需要返回的情况下，只能使用 bl 指令，如果是汇编代码中的互相跳转，倒是都可以，因为返回到跳转点的方式有很多。   

除了标准跳转指令，还涉及到 armv7 指令集的一个特性:条件执行，几乎每条指令的最高四位的编码都带有条件指令部分，关于这个可以参考[arm状态寄存器](https://zhuanlan。zhihu。com/p/362687525)，所以由此衍生出来各种各样的条件跳转，比如 beq，bge，blcc 等，这些条件后缀可以根据该博客进一步详细了解，当然也可以参考 reference manual，这是最好的方法。这里就不再赘述了。   

需要注意的是，在编写跳转指令的时候，大多都是通过标号的形式进行跳转，很少会直接使用硬编码的地址，但是我们需要了解的是:程序的跳转是相对地址跳转而不是绝对地址跳转，也就是跳转的偏移值为 目标地址-当前地址。 而且因为指令编码的原因，并不是可以在 4G 的地址空间内随意跳转，不同的指令有不同的跳转范围，跳转指令的范围可以见下表:

![](https://gitee.com/linux-downey/bloc_test/raw/master/zhihu_picture/armv7/%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%E8%8C%83%E5%9B%B4%E8%A1%A8.jpg)

其中我们只需要关注 armv7-A 架构。  

至于为什么跳转指令不能自由地在整个 32 位地址空间内跳转，这涉及到指令的编码，可以参考[arm指令集以及编码。](https://zhuanlan。zhihu。com/p/362760953)

实际上跳转指令有很多种，比如:CBNZ， CBZ， CHKA， HB， HBL， HBLP， HBP， TBB 等等，但是这些并不常用，属于一些扩展功能，有兴趣的朋友可以去查看手册获取详细信息。  

### 基于 PC 的跳转
PC 指针的跳转原本是非常简单的，往 PC 中写一个特定的地址值，程序就会跳转到对应的地址处执行，这样的操作 arm 是支持的，但是在很多情况下，是基于当前 PC 指针的偏移地址进行跳转，这个问题就要稍微复杂一些。  


#### PC 指针的获取
PC 指针中存储的是下一条执行的指令，这是大多数资料中对 PC 寄存器的描述，但是随着硬件的发展，这个说法开始变得不那么正确了。  

这得从 CPU 的流水线机制说起，对于每一条指令，都需要经过取指、译码、执行的过程，在传统的机器上，这三个步骤是串行的，也就是执行一条指令并不仅仅是一个指令周期。  

于是硬件上引入了流水线机制，在同一个时钟周期，取指、译码、执行三个步骤同时进行，这三个步骤并不是同时针对一条指令，而是不同的三条指令，也就是当前指令正在执行，当前指令的下一条指令进行译码，同时取下下条指令，到下一个时钟周期下条指令就可以直接执行，这种三级流水线机制可以加速指令的运行，而 PC 指针则是指向取指的指令，所以在 arm 指令集下，PC 的值为 当前地址+8。Thumb 指令集下，PC 的值为 当前地址+4(即使thumb包含32位指令，依旧是+4)。  

最初的流水线通常是三级，即取指、译码、执行，随着硬件的发展，芯片厂商对于速度提升的欲望只会变本加厉，于是越来越多级别的流水线被加到芯片中，到后来的 5 级甚至 8 级流水线，以五级流水线为例，其流水线流程为：取指、译码、执行、访存、回写。 即使是这样，相对于当前执行的指令而言，PC 指针始终为 当前指令+8。  

既然流水线可以执行并行的运算，加速指令的执行，是不是流水线越多越好呢？其实也并非这样，在实际的程序中，往往会存在非常多的条件执行或者跳转指令，对于条件执行指令而言，流水线如何确定要执行哪个分支呢？  

其实是没有很好的办法来确定的，唯一的做法就是猜，但是这个猜不是瞎猜，而是根据之前指令执行的行为来推测需要将要执行的分支，这种技术叫分支预测，armv7 对分支预测有直接的支持，尽管这种分支预测有比较好的表现，但是一旦分支预测错误，就需要将整个流水线 flush，而重新填充整个流水线需要消耗多个指令周期，这时候流水线越长，分值预测失败所带来的开销就越大，所以对于流水线而言，一方面想办法提升分支预测的准确度，另一方面，也需要限制流水线的长度。  

扯得有点远了，再回过头来看 pc 指针，从这个角度来看，最好不要通过读取 pc 的做法来尝试获取当前指令地址，即使可以在某一个平台上对 pc 做修正，但是这种代码不具有很好的跨平台性能。


#### PC 指针的跳转
写 pc 指针并不会出现读 pc 指针的问题，在 thumb 指令集中，ADD 、 MOV、POP 等指令可以写 pc 执行跳转，写入 PC 的值将会被强制对齐，对齐的字节数根据对应的指令集而定，thumb下是半字，arm下是字，也就是最低位(或两位)将会被跳转指令忽略。

而在 arm 指令集中，很多通用指令可以写 pc 指针，比如：ADD、AND、ASR、BIC 等(具体列表参考手册)。

除了这些通用指令写 pc，还有一些专门用于跳转的指令默认操作的就是 pc 指针，比如 B、BL、BX、BLX 等，这些是一些复合指令，也就是说这些指令包含的操作可能不仅仅是对 pc 的操作，可能还隐含其它操作。




### 指令集切换
armv7 支持多种指令集，大的分类就是两种:Thumb 指令集和 arm 指令集。  

其中，Thumb 指令集分为多个版本:Thumb1， Thumb2，Thumb3，值得一提的是，随着指令集的发展，thumb 开始支持 32 位的指令，而不再是单纯的 16 位指令。使用 thumb 指令集的好处在于提升指令密度，减少内存占用，同时降低功耗。在博主测试的 4.20 版本和 6.x 版本的编译器上，C 函数默认编译为 thumb 指令集。   

arm 指令集分为两种:arm1 和 arm2 两个小版本。arm 指令集功能强大，执行效率较高，这是因为系统是 32 位的，每一条指令的执行都是支持 32 位的操作，使用 16 位的指令集并没有充分利用到系统的资源，这种限制自然体现在执行效率上。  


两种指令集各有各的好处，所以在不同的情况下使用不同的指令集是有必要的，这就涉及到了指令集的切换。  

指令集的切换主要是两种指令:bx 和 blx。  

因为指令集的切换有两个方向: thumb -> arm ， arm -> thumb，所以必然的，bx 和 blx 同时存在于 thumb 和 arm 指令集中。

#### bx

对于 thumb 下的 bx，它的表达式为: BX Rm， 即跳转到寄存器中保存的地址处。它的指令编码是这样的:

![](https://gitee.com/linux-downey/bloc_test/raw/master/zhihu_picture/armv7/thumb-bx%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81.png)

Rm 占用 4 个 bit，所以 Rm 的范围为 r0~r15。  

对于 arm 下的 bx，表达式是一样的，它的指令编码是这样的:

![](https://gitee.com/linux-downey/bloc_test/raw/master/zhihu_picture/armv7/arm%E4%B8%8B%E7%9A%84bx%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81.jpg)

同样的，Rm 占用 4 个 bit，与 thumb 下的 bx 不同的时， arm 指令集的 bx 支持条件执行，比如 bxz，bxne 等等。  

但是使用 bx 指令并不是无条件切换指令集，而是取决于跳转地址的最后一位，遵循以下的规则:



* 如果 Rm 中 bit[0] 为 0，处理器切换到或保持在 arm 指令集。

* 如果 Rm 中 bit[0] 为 1，处理器切换到或保持在 thumb 指令集。 

  

### blx
blx 的规则相对比 bx 要复杂，因为 blx 指令分为两种形式:



* blx register:即 bx Rm
* blx imm:参数为立即数。指定的地址或者是标号。  

对于 blx register 形式的指令而言，和 bx 是一致的，由寄存器中的最后一位决定，参考上面 bx 的用法。  

blx imm 的切换机制显得更直接一点，只要调用了 blx imm 指令，指令集就无条件切换， thumb->arm 或者 arm->thumb，对应的指令集编码为:

thumb 指令集 blx 编码:

![](https://gitee.com/linux-downey/bloc_test/raw/master/zhihu_picture/armv7/thumb%E4%B8%8B%E7%9A%84blx%20%E7%BC%96%E7%A0%81.jpg)

arm 指令集 blx 编码:

![](https://gitee.com/linux-downey/bloc_test/raw/master/zhihu_picture/armv7/arm%E4%B8%8B%E7%9A%84blx%E7%BC%96%E7%A0%81.jpg)

对于 32 位的 thumb 指令，跳转的目的地址组成为: imm32 = S:J1:J2:imm10H:imm10L:00，一共 25 位，所以跳转范围为 ±16MB。无条件跳转到 arm 指令集(实际上还涉及到 J1，J2，S 位的判断，以及 thumbEE 指令集，这种情况暂时不涉及，有兴趣的朋友可以查看手册获取详细信息)。  

32 位的 arm 指令的跳转目的地址组成为:imm32 = imm24:00，一共 26 位，所以跳转范围为 ±32 MB。无条件跳转到 thumb 指令集。  


### 通过 PC 指针跳转切换
除了最常用的 blx 和 bx ，还有一种指令集切换方式也经常用到，就是通过 PC 指针跳转切换，通过 PC 指针进行程序跳转在上文中我们已经有详细介绍，而指令集的切换同样是根据跳转地址的最低位来实现，与 bx 指令相同。  

我们看下面的示例:

```
main:
    adr r0，back       //获取 back 标号的地址
    push {r0}         //将 back 地址保存在栈上
    adr r0，foo        //获取 foo 标号的地址，当前处于 arm 指令集
    add r0，r0，#1      //将 foo 地址最后一位加1，表示切换到 thumb 指令集
    mov pc，r0         //跳转到 foo 地址
back:
    blx _exit         //退出

.thumb               //指定代码编译为 thumb 指令集
foo:
    pop {pc}         //将栈上保存的 back 标号地址赋值给 pc，即实现跳转，同时指令集切换为 arm

```


有一点需要注意的是，指令集的切换并不会影响到指令编译时指令集的选择，通俗地说就是，程序中跳转到目标地址，并从 arm 切换到 thumb，编译器并不会自动检测并将目标地址处的指令编译为 thumb 指令集，程序编译成哪种指令集是由伪汇编指令决定的，所以如果目标地址为 arm 指令编码，而切换到了 thumb 指令集，程序执行就会失败。   


## 小结
针对跳转指令以及指令集切换，总结如下:



* arm 下，PC 的值为 当前地址+8，thumb 下，PC 的值为 当前地址+4。
* 使用数据操作指令操作 PC 实现程序跳转时，目标地址的最后一位确定跳转后的指令集，0 表示 arm 指令集，1 表示 thumb 指令集。
* 使用 bx register 或者 blx register 时，register 中地址值的最后一位确定跳转后的指令集，0 表示 arm 指令集，1 表示 thumb 指令集。
* 使用 blx imm(imm表示立即数) 指令时，无条件切换指令集，当前是 arm，则切换到 thumb，反之亦然。  



### 参考

[armv7-A-R 参考手册](https://gitee.com/linux-downey/bloc_test/blob/master/%E6%96%87%E6%A1%A3%E8%B5%84%E6%96%99/armv7-A-R%E6%89%8B%E5%86%8C.pdf)



[专栏首页(博客索引)](https://zhuanlan.zhihu.com/p/362640343)

原创博客，转载请注明出处。
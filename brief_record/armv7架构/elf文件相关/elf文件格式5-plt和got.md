# elf 文件格式5 - plt 和 got
前面的章节中我们分析了静态链接以及 elf 文件中的目标文件、可执行文件，实际上对于程序的加载和链接过程还有一个重点以及难点：动态链接。  

在动态链接相关的文章中，主要涉及到的知识点有以下几个：

* 动态库的 elf 格式，针对动态库的 elf 文件有什么不同？
* 对于需要使用动态库的可执行文件，动态库相关的 section 以及其他信息在前面的章节一直都是一笔带过，在这一部分我们要详细探讨
* 可执行文件中对应动态库中接口的引用到底是如何完成的，从指令的角度进行分析。

这几点也是博主接下来要讲的。  


## elf 的文件格式
使用 gcc 编译动态库时，一般都是这样的指令：

```
gcc -fpic -shared foo.c -o libfoo.so  
```

-shared 表示编译动态库。

-fpic 表示生成位置无关代码，如果不指定这个参数，动态库是不能使用的，部分编译器甚至在编译的阶段就直接报错，而动态库的关键点就在这里。  

那么，什么是位置无关代码？为什么动态库要生成位置无关代码？  


### 动态链接

前面的文章说到，相对于静态库而言，动态库最大的特点在于库的链接过程在运行时而不是在编译时，那么，如何在运行时链接动态库就是个不得不面对的问题。   

同时，相对于静态链接而言，动态链接要解决的问题一个也不会少：

* 地址符号解析：为程序中只有声明和引用(调用)的符号在共享库中找到对应的定义，比如在 libc 中找到 printf 的定义。  
* 重定位：对上一步所找到的符号进行绑定，根据定义的实际内存位置修改指令中的地址引用，比如程序中调用了 printf，但是在程序的静态链接过程是没有办法确定 printf 的地址的，在动态链接时确定了之后就需要修改其引用值。  
* 空间和地址分配：动态链接和加载过程是相互交错的，程序的加载会将程序拷贝到内存对应的地址上，当程序所依赖的动态库还没有被加载到系统内存中时，需要使用动态链接器将动态库加载到内存中，这其中涉及到动态库的空间地址分配，加载动态库的顺序是反序的，也就是当程序 A 依赖动态库 B，而 B 依赖动态库 C，加载的顺序为：C->B->A。    

甚至，动态链接相对于静态链接有更多的限制，静态链接是对文本操作，动态链接针对的是内存，而内存的操作自然会涉及到一些权限问题，只有具有读写权限的 segment 才能进行修改，比如这时候 .text , .rodata 的数据已经不允许更改。

这些就是动态链接所面临的挑战。  




### 位置无关代码
如果你阅读过我之前的文章TODO，就能大概了解程序指令是如何运行的，程序的主体是指令和数据，在最后的链接阶段，链接器为每条指令和数据分配独立的地址空间，当指令要访问数据时，访问的是数据的绝对地址。  

对于动态库而言，一般都是单独存在的，在某个程序依赖它而它还没有被加载到内存中时，它的各个 segment 由加载器加载到内存中，有两个问题值得我们考虑：
* 动态库中的所有符号是否在编译时就确定了地址？
* 动态库的指令和数据的引用是否和可执行文件一样？

首先，来看第一个问题：动态库中的符号是否在编译时就确定了地址，答案自然是否定的。如果符号地址已经确定，那么肯定会出现多个不同的动态库出现地址冲突的情况。  

那可不可以先确定地址，出现了冲突再解决呢？答案也是可以的，但是一旦程序拥有一定的规模，依赖的动态库数量比较多，这种处理冲突带来的开销非常大，模块的依赖关系甚至会让事情变得更复杂。  

于是目前动态库的做法就是在编译时默认所有的符号都是从逻辑地址 0 开始，这一点和静态库一样，在链接器加载动态库的时候在指定区域找到一片空闲的地址，再将它作为一个整体加载到内存(动态库是独立存在的，而不像静态库那样，把多个静态库进行整合以节省空间)。   

动态库加载完成之后，动态库中的每个符号都有了对应的虚拟地址，这时候就可以将程序中那些未解析的符号和动态库对应的符号进行绑定，完成重定位过程，比如程序中使用了 printf 函数，程序加载了 libc 之后 printf 的地址就确定了下来，这时候就需要修改程序中对 printf 函数的引用。   

动态库中的符号解析和静态库中是一致的，但是重定位的操作是完全不同的，这也是动态库的关键特点所在，涉及到动态库中的 plt、got机制，将在后续的文章中专门讨论。  




再回到第二个问题，动态库的指令和数据的访问模式是否和可执行文件中访问模式一样？

上文说到，可执行文件/目标文件中，指令对于数据的引用是绝对地址引用，如果沿用这种数据访问模式，动态库中数据部分的加载地址是未知的，在动态库加载到内存中时，还需要对指令进行修正，但是指令部分的所在的 segment 是没有 write 权限的，所以无法修正，这个问题可以通过其它变通的办法解决，但是也会带来不小的开销。  

而问题的解决方案就是位置无关代码，位置无关代码的特点在于将该代码(包括数据)加载到内存的任何位置，都可以正常运行。位置无关代码的实现方式有两种，一种是没有数据引用的纯指令，自然可以在任何地址执行。

另一种就是使用 -fpic 编译出来的代码。对于同一个模块而言，指令和数据之间的偏移是固定的，加载到内存中也是将指令和数据作为一个整体进行加载，所以，指令对数据的引用可以是用相对地址而不是绝对地址，对数据地址的引用只需要加上一个固定的偏移地址即可(实现细节将在后续文章中讨论)。  

### 动态库的加载
动态库又名共享库，顾名思义，动态库可以在多个进程之间共享，也就是说，在真实的物理内存中只存在一份动态库的实体，可以被多个进程引用。  

动态库的加载有一定的复杂性，当在终端执行一个程序时，程序的加载就开始了。加载之初，加载器通过分析 elf 格式(.dynamic段)确定当前可执行文件是否依赖于共享库，答案通常是肯定的，然后通过 .interp 段获取到动态加载器在当前系统中的位置。  

动态链接器负责动态库的加载，通常的是 /lib.ld-linux-x.so.x，有意思的是，动态库链接器本身也是一个动态库，那么它是被谁加载的呢？答案是它同样是被自己加载，这个过程叫做自举，动态链接器作为一个动态库，其特殊之处在于程序的起始部分添加了一段特殊的加载代码。这个过程和内核的自解压有些类似，内核的 zImage 是经过压缩的镜像，该压缩镜像最开始部分的代码就是解压自身。  

动态链接器的自举完成之后，接着读取可执行文件的动态加载信息，其主要部分是 .synamic 段,而其他涉及到动态链接的诸如 .dynsym, .rel.dyn, .got ,.plt 等则涉及到具体的加载细节，通常情况下，一个程序并不仅仅依赖于一个动态库，可能会存在动态库之间的递归依赖，而动态库的加载顺序总是被依赖的动态库先加载，每个动态库加载完成之后，动态库中 .init 段部分的代码会被执行。  

当然，上述对于动态库加载的讨论都是基于该动态库目前还没被加载到内存中，对于内核而言，动态库的加载位置是唯一的，而且通常只需要一次，但是对于不同的进程而言，它可以被映射到不同的虚拟地址上，当一个程序启动时发现需要加载对应的动态库，首先会检查是否系统中已经加载该动态库，如果已经加载，仅仅是为动态库建立虚拟地址映射，如果没有加载，就需要在内核中通过动态链接器将对应的动态库加载到内核中，然后建立虚拟地址映射。  

需要注意的是，动态库中共享的只是代码、.rodata 等属于具有 R/E 属性的 segment 的段，对于可读写的数据部分，每个进程都拥有一个副本。  


## 动态库类型的 elf 文件
前面我们已经介绍过了 elf 文件中的目标文件和可执行文件，相对于这两种文件而言，动态库类型的文件有一些特点：

### elf header
使用 readelf -h 命令查看动态库的 elf 头，比较明显的差别在于：
* 文件类型不一样,动态库的类型为 DNY(Shared object file)。
* 从动态库中段的组成来看，它和可执行文件几乎是差不多的，同时包含了 .init,.fini,.init_array,.fini_array,.text 等段内容，同时也有 segment table，这两者最大的差别在于：动态库的重定位过程放到加载时完成，因此其每个段，每个 segment 对应的虚拟地址都是不确定的，逻辑上从 0  开始。  
* 动态库中的代码都是位置无关代码，这是由动态库共享的特性决定的，关于位置无关代码将在下文中详细讨论。   
* 静态链接中，符号表、重定位表、字符串表这些都是作为链接阶段的辅助，所以在加载过程中属于无用的信息，但是动态库中这些段需要辅助动态库进行运行时的符号解析以及重定位，在加载时同样会被加载到内存中。  

除了框架上的特点，其它的区别体现在其具体的段上，我们来看看动态库中有哪些特殊的段

## 动态库中与动态链接相关的 section

### .dynamic
.dynamic 是整个动态链接中最核心的部分，该 section 中保存了动态链接器所需要的符号基本信息，它对应的数据结构为：

```C
typedef struct {
  unsigned char	d_tag[4];		/* entry tag value */
  union {
    unsigned char	d_val[4];
    unsigned char	d_ptr[4];
  } d_un;
} Elf32_External_Dyn;
```
每一个动态链接的符号由一个类型值加上一个附加的联合体数值或者指针，每个符号占用 8 个字节，对于不同的 tag，其对应的数值或者指针有不同的含义，下面列举几个比较常用的 tag 类型：

* DT_NEEDED(1)：该 elf 文件需要链接的动态库，名称被保存在 .dynstr 中，d_ptr 中保存其名称在 .dynstr 中的偏移地址。  
* DT_HASH(4)：动态链接 hash 表的位置，d_ptr 表示地址
* DT_STRTAB(5)：动态链接字符串表的位置，d_ptr 表示地址
* DT_SYMTAB(6)：符号表的位置
* DT_RELA(7)：：重定位表 rela 的位置
* DT_RELASZ(8)：重定位表 rela 的 size，d_val 表示 size
* DT_STRSZ(10)：字符串表的长度
* DT_INIT(12)：初始化代码的地址
* DT_FINI(13)：结束代码的地址
* DT_REL(17)：重定位表 rel 的位置
* DT_RELSZ(18)：重定位表 rel 的 size，rel 和 rela 的区别在于：rela 相对于 rel 而言多了一个 addend(加数)，这个加数用于重定位的过程，因为 rel 将加数放在了需要重定位的内存位置作为占位符，而 rela 类型的对应内存位置为0.  
* DT_SYMTAB_SHNDX(34)：符号表的 section header 的 index。  

.dynamic 包含了动态库中所有基本信息，可以将其看成是动态库的文件头，readelf 也支持直接通过 -d 参数查看 .dynamic 段：


```
# readelf -d libfoo.so

Dynamic section at offset 0xf20 contains 24 entries:
  Tag        Type                         Name/Value
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
 0x0000000c (INIT)                       0x46c
 0x0000000d (FINI)                       0x604
 0x00000019 (INIT_ARRAY)                 0x8f14
 0x0000001b (INIT_ARRAYSZ)               4 (bytes)
 0x0000001a (FINI_ARRAY)                 0x8f18
 0x0000001c (FINI_ARRAYSZ)               4 (bytes)
 0x6ffffef5 (GNU_HASH)                   0x118
 0x00000005 (STRTAB)                     0x2d8
 0x00000006 (SYMTAB)                     0x178
 0x0000000a (STRSZ)                      222 (bytes)
 0x0000000b (SYMENT)                     16 (bytes)
 0x00000003 (PLTGOT)                     0x9000
 0x00000002 (PLTRELSZ)                   24 (bytes)
 0x00000014 (PLTREL)                     REL
 0x00000017 (JMPREL)                     0x454
 0x00000011 (REL)                        0x404
 0x00000012 (RELSZ)                      80 (bytes)
 0x00000013 (RELENT)                     8 (bytes)
 0x6ffffffe (VERNEED)                    0x3e4
 0x6fffffff (VERNEEDNUM)                 1
 0x6ffffff0 (VERSYM)                     0x3b6
 0x6ffffffa (RELCOUNT)                   3
 0x00000000 (NULL)                       0x0
```

### .dynsym, .dynstr
对于在链接阶段未解析的符号，就需要在动态链接阶段进行解析和重定位，这些未解析的符号被保存在 .dynsym 中，而对应的字符串被保存在 .dynstr，在动态链接阶段，链接器将会一一地在已加载的动态库中找到对应的符号定义，并对符号进行重定位。   

.dynsym 的数据类型为 SH_DYNSYM, 普通的 symtab 类型为 SHT_SYMTAB,这两者对应的数据结构有一些细小的内容上的差别，但是整体结构是一样的：

```
typedef struct {
  unsigned char	st_name[4];		/* Symbol name, index in string tbl */
  unsigned char	st_value[4];		/* Value of the symbol */
  unsigned char	st_size[4];		/* Associated symbol size */
  unsigned char	st_info[1];		/* Type and binding attributes */
  unsigned char	st_other[1];		/* No defined meaning, 0 */
  unsigned char	st_shndx[2];		/* Associated section index */
} Elf32_External_Sym;
```

而 .dynstr 是和 .dynsym 相关的以 '\0' 结尾的动态符号表字符串信息。   

### .rel.dyn, , rel.plt
dynamic 段和 plt 段的重定位信息，对应的类型为 SHT_REL，对应的数据结构为：

```
typedef struct {
  unsigned char r_offset[4];	/* Location at which to apply the action */
  unsigned char	r_info[4];	/* index and type of relocation */
} Elf32_External_Rel;
```
对每一个重定位项，保存了需要重定位的地址和重定位的详细信息。  

对于动态的重定位原则是：在编译过程中，所有的代码部分以及 .rodata 段都被添加到带有 R/E 属性中的 segment 中，同时还包括重定位的信息比如符号表、重定位表，这些都将被加载到内存的只读区域，因此是不能被修改的.所以重定位针对的只能是数据部分。   

其实也不难理解，动态库中的代码段、符号信息是所有进程共享的，需要保证这一部分稳定不变，如果这部分信息可以修改，则每个进程都要保留一份副本，那共享也就没有意义了。  

### .got 
动态链接过程中的重定位并不像静态链接那样方便，对于静态链接而言，重定位过程可以直接修改指令中对数据的引用地址，因为静态链接操作的是 elf 文本，而动态链接则做不到，因为这时候指令已经被加载到内存中，且映射为只读属性。  

有些朋友就有疑问了，为什么要强行把代码段的数据映射为只读属性，映射成读写属性不行吗，这样动态链接过程就可以直接修改指令了，实际上还真不行。一方面，映射为只读属性是出于保护代码不被修改的目的，另一方面，如果动态库 A 引用了动态库 B，在重定位过程中修改了动态库 A 中的指令部分，但是，动态库是进程之间共享的，为某一个进程修改动态库会导致其它进程的引用出错。  

那么问题来了，如果不能修改指令，那怎么完成重定位过程？毕竟指令中编码的地址是不能直接使用的。答案是通过数据部分进行一次跳转。     

对于所有的进程而言，动态库的数据部分是有独立的一份副本的，这也很好理解，程序的数据部分是读写属性的，对数据的操作由进程说了算，所以，在重定位过程中，既然不能修改代码部分，那么我们只能通过修改数据部分来完成重定位的过程。  

这种实现的机制使用了 GOT 表，全名为 global offset table，即全局偏移表。在执行的指令中，本来需要引用符号 A ，但是 A 存在于动态库中，链接过程并不知道它的地址，于是将 A 的地址部分改写为 GOT 表中某一项数据，在编译阶段 GOT 表中是没有真实数据的，但是在动态链接的加载阶段，动态链接器就可以将符号 A 的真实地址填写到 GOT 表中对应的数据项中，这样指令对 A 就产生了正确的引用。  

GOT 中每一个表项占用 4 个字节(32位)，表示运行时的符号的真实地址。  

对于函数而言，可以在加载阶段通过 GOT 表获取到函数的地址保存到寄存器中，然后跳转到该地址，同样可以实现加载时的重定位，但是在实际的指令重定位中，并不单单使用 GOT 表，还使用了另一个 PLT 表实现。  



### 延迟绑定 plt
相对于静态链接而言，动态链接的确非常灵活，随之也带来了一些性能的牺牲，毕竟将编译链接过程的重定位工作放到了运行时完成，可以想到，当我们在动态链接一个库时，以 libc 为例，需要先对其中的每个函数和全局变量的引用进行重定位，即使是那些没有用到的诸如错误处理的函数，这种情况下共享库越大，链接的时间越长，程序的启动时间也就越长，而且大多数的重定位都是没有必要的，对用户来说这通常是不能忍受的。  

于是，延迟绑定的概念被提出，延迟绑定的规则为只有在符号被真正引用时才进行重定位，而不是在刚开始就对所有的动态符号进行重定位，一方面加快了程序的启动，将整个动态加载时间分摊到程序运行期间，另一方面，对于共享库中没有用到的符号，不再进行重定位，节省了重定位的时间，随着共享库的发展更新，这种优势变得越来越明显。  

延迟绑定由 plt 表来实现，在 elf 文件中，plt 表和 got 表几乎是时时刻刻伴随着的，在上一段中说到因为运行时不能修改指令，所以通过数据部分的 got 表进行运行时符号真实地址的传递，而 plt 是一小段跳转指令，当程序中的指令引用到动态库中的函数时，执行顺序为：
* 指令跳转到 plt 表
* plt 表判断其对应的 got 表项是否已经被重定位
* 如果重定位完成，plt 代码跳转到目标地址执行
* 如果未重定位，调用动态链接器为当前的引用进行重定位，重定位完成之后再跳转。  

相对于使用单纯的 got 表实现跳转而言，plt 的好处在于所有需要重定位的指令跳转都保存在 plt 中，便于集中管理、索引，另一方面，plt 还实现了判断符号是否重定位并提供动态链接器的调用功能，这是延迟绑定技术的核心部分。   

### got 和 plt 实现延迟绑定

在上文中对于 GOT 的讲解中提到：got 中的表项都将在加载阶段由动态链接器进行填充，最后 got 中每一项的值都是所引用符号在内存中的真实地址，实际上的实现却要相对复杂一些。  

并不是所有的符号都在加载阶段都会被重定位，而是按需加载，即延迟绑定，那么，程序如何知道引用的 got 表项已经被重定位了呢？这里就涉及到 plt 和 got 表之间的配合。在 got 表中，并不是每一项都对应符号的引用，它的前三项被系统"征用"了，分别对应：
* got[0]：当前 elf 文件中 .synamic 段的地址
* got[1]：作为保留
* got[2]: 动态链接器的符号解析函数

除了前三项，后面的项才被一一用作符号重定位，对于外部函数(即外部跳转)的 got 表项而言，在编译阶段保存的是 .plt 表的起始位置，对于数据引用的 plt 表项而言，编译阶段的值为 0。   

接下来看看 plt，plt 的作用是为每一次模块外部的函数调用设置一小段跳转代码，在 arm 编译器的实现中，对于每一项外部跳转，对应 plt 中三条指令，和 got 类似，plt 的前面部分负责调用也被系统"征用"了，它负责保存动态链接器中的符号解析函数地址，后续的部分才是对应具体外部跳转的指令。   

在程序的编译阶段，plt 跳转指令表项和 got 表项就实现了绑定，其映射关系为：plt 第二段跳转指令对应 got 第四个表项，plt 第二段跳转指令对应 got 第五个表项，以此类推。  

了解了 plt 和 got 的结构，我们再来看看延迟绑定的整个流程：
* 程序调用了外部函数，跳转到对应的 plt 表项地址处执行。  
* plt 指令跳转到其绑定的 got 表项处
  * 如果该 got 表项已经进行过重定位，则该地址处保存的是目标函数的真实内存地址，跳转到函数执行。
  * 如果该 got 表项还没有进行过重定位，则该地址处保存的是 plt 表的首地址，即跳转到 plt 表开头的地址处执行，这一部分跳转代码的作用是调用动态链接器的符号解析函数。
  * 该解析函数查找符号的真实地址。并将该地址存储在对应的 got 表项中，完成函数的重定位过程，然后跳转到该函数执行，下次调用到该函数时就不再需要进行重定位。  

这就是动态链接时延迟绑定的实现。    


### .plt.got 和 .got.plt
博主最初参考的是 <<程序员的自我修养>> 这本书，在这本书中还提到整个动态库的延迟绑定过程还涉及到 .plt.got 和 .got.plt 段，但是我查看了 arm 平台下的系统共享库，并没有发现这两个段的存在。于是到其它平台去找，发现 x86 平台上的系统共享库中存在这两个段，而且经过分析发现,x86 中的 .plt.got 是针对 plt 代码的 got 表，只是将 arm 实现用的 .got 表统一实现分成了数据引用和函数引用，数据引用放在 got 中，函数引用(外部跳转)放在 .plt.got 中。  


### got 和 plt 实例分析

如果仅仅是讲讲概念，并不能对这个知识点建立深刻的印象，往往是回头就忘，所以我们还需要深入到实现细节中，一步步分析动态库中延迟绑定的实现细节，这样才能从原理上了解动态库的实现机制。  

因此，最好的方式就是通过编译一个动态库，再对其相应内容进行分析。  

动态库源代码还是我们之前用到的那个简单示例 foo.c：

```
#include <stdio.h>
void foo(void)
{
  printf("foo\n");
}
void bar(void)
{
  printf("bar\n");
}
```

并编译成动态库：

```
gcc -fpic -shared foo.c -o libfoo.so
```

接着，看到 libfoo.so 中的内容，通过 readelf 查看各个相关段的地址：

```
# readelf -S libfoo.so
There are 27 section headers, starting at offset 0x118c:

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  ...
  [ 8] .rel.plt          REL             00000454 000454 000018 08   A  3  10  4
  [10] .plt              PROGBITS        00000478 000478 000038 04  AX  0   0  4
  [18] .dynamic          DYNAMIC         00008f20 000f20 0000e0 08  WA  4   0  4
  [19] .got              PROGBITS        00009000 001000 000034 04  WA  0   0  4
  ...
```

通过 readelf 显示的信息可以看到，这三个段的地址以及 size，至于为什么要把 .rel.plt 拿到一起分析，因为这个段是 plt 代码的重定位表，涉及到 plt 的跳转。  

首先，查看 .rel.plt 的内容：

```
# hexdump -C -s 0x454 -n 24 libfoo.so  //-s 用于设置偏移量，-n 表示显示的数据量，
                                       //对应上文中 .rel.plt 的段信息：偏移地址为 0x454，size 为 0x18。
00000454  0c 90 00 00 16 03 00 00  10 90 00 00 16 05 00 00  |................|
00000464  14 90 00 00 16 06 00 00                           |........|
```
在前面的文章我们我们就分析过重定位表的数据结构，它包含 8 个字节，前四个字节表示需要重定位的地址，后四个字节表示重定位的相关信息，上述的 .rel.plt 包含三个重定位项，对应的地址分别为：0x900c，0x9010,0x9014.而这个地址可以看到，这个地址在 .got 段中，也就是对应 got 中的表项。    

接下来自然是看看 got 表中的内容：

```
# hexdump -C -s 0x1000 -n 52 libfoo.so
00001000  20 8f 00 00 00 00 00 00  00 00 00 00 78 04 00 00  | ...........x...|
00001010  78 04 00 00 78 04 00 00  00 00 00 00 00 00 00 00  |x...x...........|
00001020  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
...
```
got 表中每一个表项都是 4 字节(arm32下)，按照上文中的描述，第一项表示 .dynamic 的地址：0x8f20，对比没有错。第二项为保留，所以为0，第三项是动态链接器的符号解析函数，在编译阶段无法确定，需要在加载时填充，所以为 0 。  

真正的重定位表项从第四项开始，也就是地址 0x900c(文件内偏移地址为0x100c，实际虚拟地址为 0x900c，上述显示的是文件内偏移地址)，这正好对应了 .rel.plt 中第一个重定位表项，而需要重定位的外部跳转(函数)有三项，另两项地址为 0x9010,0x9014，和 .rel.plt 也是可以对应上的。  

可以发现，对于需要重定位的外部跳转(函数)符号，其地址上的值为 0x0478(上述表中0x100c地址处)，而这个 0x0478 正是 .plt 段的起始地址，也就是指向 plt 表头。 

这也验证了上面的说法：通过 plt 进行外部跳转(函数)时，plt 代码会直接跳转到对应 got 表项存储的地址处，如果这个地址没有经过重定位，就会跳回到 plt 表中的开头处，而 plt 表头部分的代码就是执行符号解析和重定位过程。  

我们可以看看 plt 部分，通过 objdump 查看反汇编代码：

```
...
00000478 <.plt>:
 478:   e52de004        push    {lr}            ; (str lr, [sp, #-4]!)
 47c:   e59fe004        ldr     lr, [pc, #4]    //取 488 处的值到 lr 中，即 0x00008b78
 480:   e08fe00e        add     lr, pc, lr      //将 lr 的值加上 pc 值，即 0x008b78 + 0x488 = 0x9000，对应got 表的虚拟地址
 484:   e5bef008        ldr     pc, [lr, #8]!   // 将 pc 赋值为 lr + 8，即 0x9008，对应 got 表中第二项，也就是跳转到动态链接器中符号解析函数
 488:   00008b78        .word   0x00008b78
 48c:   e28fc600        add     ip, pc, #0, 12    //获取当前 pc (0x494) 到 ip 寄存器中
 490:   e28cca08        add     ip, ip, #8, 20    //将 ip 寄存器中的值加上 0x8000，结果为 0x8494 
 494:   e5bcfb78        ldr     pc, [ip, #2936]!  //取 0x8494+2936 = 0x900c 地址处的值，也就是 got 表的第四项，并跳转
 ...                                              //后续对于 got 表的第五项、第六项是同样的操作
...
```

汇编代码看起来比较晦涩，直接看注释吧，解释得比较清楚了，如果要真正掌握这个过程，建议最好也一起动动手，这样印象才会更深刻。   



## got，plt 表的应用

got 表并不仅仅在动态库中使用，它同样应用在依赖于动态库的可执行文件中。即使是使用 -static 编译静态的可执行文件，也会使用到 got 表来实现跳转，got 和 plt 的使用并不限定于哪一种应用方式。本质上来说，对于所有不方便或者不能在编译阶段通过修改指令进行重定位的代码，都可以使用 got 表进行跳转。  

比如在位置无关代码中对模块全局变量的引用，就需要使用 got 表进行跳转。因为这个全局变量可能是定义在其它模块中，也可能是定义在当前模块中，如果不使用 got 表跳转，可以使用相对地址进行引用，同时该全局变量会被保存在 bss 或者 data 段中，但是对于定义在其它模块中的全局变量而言，该变量同时被保存在定义该变量的模块中的 bss 或者 data 段，当这两个模块被同一个程序使用时，这个变量就有两份定义，自然是会冲突的。    



参考：[官方文档](https://refspecs.linuxfoundation.org/ELF/zSeries/lzsabi0_zSeries/x2251.html)

# elf 文件格式5 - plt 和 got
前面的章节中我们分析了静态链接以及 elf 文件中的目标文件、可执行文件，实际上对于程序的加载和链接过程还有一个重点以及难点：动态链接。  

在动态链接相关的文章中，主要涉及到的知识点有以下几个：

* 动态库的 elf 格式，针对动态库的 elf 文件有什么不同？
* 对于需要使用动态库的可执行文件，动态库相关的 section 以及其他信息在前面的章节一直都是一笔带过，在这一部分我们要详细探讨
* 可执行文件中对应动态库中接口的引用到底是如何完成的，从指令的角度进行分析。

这几点也是博主接下来要讲的。  


## elf 的文件格式
使用 gcc 编译动态库时，一般都是这样的指令：

```
gcc -fpic -shared foo.c -o libfoo.so  
```

-shared 表示编译动态库。

-fpic 表示生成位置无关代码，如果不指定这个参数，动态库是不能使用的，部分编译器甚至在编译的阶段就直接报错，而动态库的关键点就在这里。  

那么，什么是位置无关代码？为什么动态库要生成位置无关代码？  


### 动态链接

前面的文章说到，相对于静态库而言，动态库最大的特点在于库的链接过程在运行时而不是在编译时，那么，如何在运行时链接动态库就是个不得不面对的问题。   

同时，相对于静态链接而言，动态链接要解决的问题一个也不会少：

* 地址符号解析：为程序中只有声明和引用(调用)的符号在共享库中找到对应的定义，比如在 libc 中找到 printf 的定义。  
* 重定位：对上一步所找到的符号进行绑定，根据定义的实际内存位置修改指令中的地址引用，比如程序中调用了 printf，但是在程序的静态链接过程是没有办法确定 printf 的地址的，在动态链接时确定了之后就需要修改其引用值。  
* 空间和地址分配：动态链接和加载过程是相互交错的，程序的加载会将程序拷贝到内存对应的地址上，当程序所依赖的动态库还没有被加载到系统内存中时，需要使用动态链接器将动态库加载到内存中，这其中涉及到动态库的空间地址分配，加载动态库的顺序是反序的，也就是当程序 A 依赖动态库 B，而 B 依赖动态库 C，加载的顺序为：C->B->A。    

甚至，动态链接相对于静态链接有更多的限制，静态链接是对文本操作，动态链接针对的是内存，而内存的操作自然会涉及到一些权限问题，只有具有读写权限的 segment 才能进行修改，比如这时候 .text , .rodata 的数据已经不允许更改。

这些就是动态链接所面临的挑战。  


### 位置无关代码
如果你阅读过我之前的文章TODO，就能大概了解程序指令是如何运行的，程序的主体是指令和数据，在最后的链接阶段，链接器为每条指令和数据分配独立的地址空间，当指令要访问数据时，访问的是数据的绝对地址。  

对于动态库而言，一般都是单独存在的，在某个程序依赖它而它还没有被加载到内存中时，它的各个 segment 由加载器加载到内存中，有两个问题值得我们考虑：
* 动态库中的所有符号是否在编译时就确定了地址？
* 动态库的指令和数据的引用是否和可执行文件一样？

首先，来看第一个问题：动态库中的符号是否在编译时就确定了地址，答案自然是否定的。如果符号地址已经确定，那么肯定会出现多个不同的动态库出现地址冲突的情况。  

那可不可以先确定地址，出现了冲突再解决呢？答案也是可以的，但是一旦程序拥有一定的规模，依赖的动态库数量比较多，这种处理冲突带来的开销非常大，模块的依赖关系甚至会让事情变得更复杂。  

于是目前动态库的做法就是在编译时默认所有的符号都是从逻辑地址 0 开始，这一点和静态库一样，在链接器加载动态库的时候在指定区域找到一片空闲的地址，再将它作为一个整体加载到内存(动态库是独立存在的，而不像静态库那样，把多个静态库进行整合以节省空间)。   

动态库加载完成之后，动态库中的每个符号都有了对应的虚拟地址，这时候就可以将程序中那些未解析的符号和动态库对应的符号进行绑定，完成重定位过程，比如程序中使用了 printf 函数，程序加载了 libc 之后 printf 的地址就确定了下来，这时候就需要修改程序中对 printf 函数的引用。   

动态库中的符号解析和静态库中是一致的，但是重定位的操作是完全不同的，这也是动态库的关键特点所在，涉及到动态库中的 plt、got机制，将在后续的文章中专门讨论。  


再回到第二个问题，动态库的指令和数据的访问模式是否和可执行文件中访问模式一样？

上文说到，可执行文件/目标文件中，指令对于数据的引用是绝对地址引用，如果沿用这种数据访问模式，动态库中数据部分的加载地址是未知的，在动态库加载到内存中时，还需要对指令进行修正，但是指令部分的所在的 segment 是没有 write 权限的，所以无法修正，这个问题可以通过其它变通的办法解决，但是也会带来不小的开销。  

而问题的解决方案就是位置无关代码，位置无关代码的特点在于将该代码(包括数据)加载到内存的任何位置，都可以正常运行。位置无关代码的实现方式有两种，一种是没有数据引用的纯指令，自然可以在任何地址执行。

另一种就是使用 -fpic 编译出来的代码。对于同一个模块而言，指令和数据之间的偏移是固定的，加载到内存中也是将指令和数据作为一个整体进行加载，所以，指令对数据的引用可以是用相对地址而不是绝对地址，对数据地址的引用只需要加上一个固定的偏移地址即可(实现细节将在后续文章中讨论)。  


## 动态库类型的 elf 文件
前面我们已经介绍过了 elf 文件中的目标文件和可执行文件，相对于这两种文件而言，动态库类型的文件有一些小的区别：

### elf header
使用 readelf -h 命令查看动态库的 elf 头，比较明显的差别在于：
* 文件类型不一样,动态库的类型为 DNY(Shared object file)。
* 动态库直接参与程序的加载和执行，所以动态库中也有 program headers，同时，动态库需要在加载时进行重定位，因此动态库中符号对应的虚拟地址仅仅是编译时的逻辑地址。 

## 动态库中与动态链接相关的 section

### .dynamic






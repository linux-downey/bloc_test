# elf 文件格式5 - plt 和 got
前面的章节中我们分析了静态链接以及 elf 文件中的目标文件、可执行文件，实际上对于程序的加载和链接过程还有一个重点以及难点：动态链接。  

在动态链接相关的文章中，主要涉及到的知识点有以下几个：

* 动态库的 elf 格式，针对动态库的 elf 文件有什么不同？
* 对于需要使用动态库的可执行文件，动态库相关的 section 以及其他信息在前面的章节一直都是一笔带过，在这一部分我们要详细探讨
* 可执行文件中对应动态库中接口的引用到底是如何完成的，从指令的角度进行分析。

这几点也是博主接下来要讲的。  


## elf 的文件格式
使用 gcc 编译动态库时，一般都是这样的指令：

```
gcc -fpic -shared foo.c -o libfoo.so  
```

-shared 表示编译动态库。

-fpic 表示生成位置无关代码，如果不指定这个参数，动态库是不能使用的，部分编译器甚至在编译的阶段就直接报错，而动态库的关键点就在这里。  

那么，什么是位置无关代码？为什么动态库要生成位置无关代码？  


### 动态链接

前面的文章说到，相对于静态库而言，动态库最大的特点在于库的链接过程在运行时而不是在编译时，那么，如何在运行时链接动态库就是个不得不面对的问题。   

同时，相对于静态链接而言，动态链接要解决的问题一个也不会少：

* 地址符号解析：为程序中只有声明和引用(调用)的符号在共享库中找到对应的定义，比如在 libc 中找到 printf 的定义。  
* 重定位：对上一步所找到的符号进行绑定，根据定义的实际内存位置修改指令中的地址引用，比如程序中调用了 printf，但是在程序的静态链接过程是没有办法确定 printf 的地址的，在动态链接时确定了之后就需要修改其引用值。  
* 空间和地址分配：动态链接和加载过程是相互交错的，程序的加载会将程序拷贝到内存对应的地址上，当程序所依赖的动态库还没有被加载到系统内存中时，需要使用动态链接器将动态库加载到内存中，这其中涉及到动态库的空间地址分配，加载动态库的顺序是反序的，也就是当程序 A 依赖动态库 B，而 B 依赖动态库 C，加载的顺序为：C->B->A。    

甚至，动态链接相对于静态链接有更多的限制，静态链接是对文本操作，动态链接针对的是内存，而内存的操作自然会涉及到一些权限问题，只有具有读写权限的 segment 才能进行修改，比如这时候 .text , .rodata 的数据已经不允许更改。

这些就是动态链接所面临的挑战。  




### 位置无关代码
如果你阅读过我之前的文章TODO，就能大概了解程序指令是如何运行的，程序的主体是指令和数据，在最后的链接阶段，链接器为每条指令和数据分配独立的地址空间，当指令要访问数据时，访问的是数据的绝对地址。  

对于动态库而言，一般都是单独存在的，在某个程序依赖它而它还没有被加载到内存中时，它的各个 segment 由加载器加载到内存中，有两个问题值得我们考虑：
* 动态库中的所有符号是否在编译时就确定了地址？
* 动态库的指令和数据的引用是否和可执行文件一样？

首先，来看第一个问题：动态库中的符号是否在编译时就确定了地址，答案自然是否定的。如果符号地址已经确定，那么肯定会出现多个不同的动态库出现地址冲突的情况。  

那可不可以先确定地址，出现了冲突再解决呢？答案也是可以的，但是一旦程序拥有一定的规模，依赖的动态库数量比较多，这种处理冲突带来的开销非常大，模块的依赖关系甚至会让事情变得更复杂。  

于是目前动态库的做法就是在编译时默认所有的符号都是从逻辑地址 0 开始，这一点和静态库一样，在链接器加载动态库的时候在指定区域找到一片空闲的地址，再将它作为一个整体加载到内存(动态库是独立存在的，而不像静态库那样，把多个静态库进行整合以节省空间)。   

动态库加载完成之后，动态库中的每个符号都有了对应的虚拟地址，这时候就可以将程序中那些未解析的符号和动态库对应的符号进行绑定，完成重定位过程，比如程序中使用了 printf 函数，程序加载了 libc 之后 printf 的地址就确定了下来，这时候就需要修改程序中对 printf 函数的引用。   

动态库中的符号解析和静态库中是一致的，但是重定位的操作是完全不同的，这也是动态库的关键特点所在，涉及到动态库中的 plt、got机制，将在后续的文章中专门讨论。  


再回到第二个问题，动态库的指令和数据的访问模式是否和可执行文件中访问模式一样？

上文说到，可执行文件/目标文件中，指令对于数据的引用是绝对地址引用，如果沿用这种数据访问模式，动态库中数据部分的加载地址是未知的，在动态库加载到内存中时，还需要对指令进行修正，但是指令部分的所在的 segment 是没有 write 权限的，所以无法修正，这个问题可以通过其它变通的办法解决，但是也会带来不小的开销。  

而问题的解决方案就是位置无关代码，位置无关代码的特点在于将该代码(包括数据)加载到内存的任何位置，都可以正常运行。位置无关代码的实现方式有两种，一种是没有数据引用的纯指令，自然可以在任何地址执行。

另一种就是使用 -fpic 编译出来的代码。对于同一个模块而言，指令和数据之间的偏移是固定的，加载到内存中也是将指令和数据作为一个整体进行加载，所以，指令对数据的引用可以是用相对地址而不是绝对地址，对数据地址的引用只需要加上一个固定的偏移地址即可(实现细节将在后续文章中讨论)。  

### 动态库的加载
动态库又名共享库，顾名思义，动态库可以在多个进程之间共享，也就是说，在真实的物理内存中只存在一份动态库的实体，可以被多个进程引用。  

首先，动态库


## 动态库类型的 elf 文件
前面我们已经介绍过了 elf 文件中的目标文件和可执行文件，相对于这两种文件而言，动态库类型的文件有一些小的区别：

### elf header
使用 readelf -h 命令查看动态库的 elf 头，比较明显的差别在于：
* 文件类型不一样,动态库的类型为 DNY(Shared object file)。
* 动态库直接参与程序的加载和执行，所以动态库中也有 program headers，同时，动态库需要在加载时进行重定位，因此动态库中符号对应的虚拟地址仅仅是编译时的逻辑地址。 

## 动态库中与动态链接相关的 section

### .dynamic
.dynamic 是整个动态链接中最核心的部分，该 section 中保存了动态链接器所需要的符号基本信息，它对应的数据结构为：

```C
typedef struct {
  unsigned char	d_tag[4];		/* entry tag value */
  union {
    unsigned char	d_val[4];
    unsigned char	d_ptr[4];
  } d_un;
} Elf32_External_Dyn;
```
每一个动态链接的符号由一个类型值加上一个附加的联合体数值或者指针，每个符号占用 8 个字节，对于不同的 tag，其对应的数值或者指针有不同的含义，下面列举几个比较常用的 tag 类型：

* DT_HASH(4)：动态链接 hash 表的位置，d_ptr 表示地址
* DT_STRTAB(5)：动态链接字符串表的位置，d_ptr 表示地址
* DT_SYMTAB(6)：符号表的位置
* DT_RELA(7)：：重定位表 rela 的位置
* DT_RELASZ(8)：重定位表 rela 的 size，d_val 表示 size
* DT_STRSZ(10)：字符串表的长度
* DT_INIT(12)：初始化代码的地址
* DT_FINI(13)：结束代码的地址
* DT_REL(17)：重定位表 rel 的位置
* DT_RELSZ(18)：重定位表 rel 的 size，rel 和 rela 的区别在于：rela 相对于 rel 而言多了一个 addend(加数)，这个加数用于重定位的过程，因为 rel 将加数放在了需要重定位的内存位置作为占位符，而 rela 类型的对应内存位置为0.  
* DT_SYMTAB_SHNDX(34)：符号表的 section header 的 index。  

.dynamic 包含了动态库中所有基本信息，可以将其看成是动态库的文件头，readelf 也支持直接通过 -d 参数查看 .dynamic 段：


```
# readelf -d libfoo.so

Dynamic section at offset 0xf20 contains 24 entries:
  Tag        Type                         Name/Value
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
 0x0000000c (INIT)                       0x46c
 0x0000000d (FINI)                       0x604
 0x00000019 (INIT_ARRAY)                 0x8f14
 0x0000001b (INIT_ARRAYSZ)               4 (bytes)
 0x0000001a (FINI_ARRAY)                 0x8f18
 0x0000001c (FINI_ARRAYSZ)               4 (bytes)
 0x6ffffef5 (GNU_HASH)                   0x118
 0x00000005 (STRTAB)                     0x2d8
 0x00000006 (SYMTAB)                     0x178
 0x0000000a (STRSZ)                      222 (bytes)
 0x0000000b (SYMENT)                     16 (bytes)
 0x00000003 (PLTGOT)                     0x9000
 0x00000002 (PLTRELSZ)                   24 (bytes)
 0x00000014 (PLTREL)                     REL
 0x00000017 (JMPREL)                     0x454
 0x00000011 (REL)                        0x404
 0x00000012 (RELSZ)                      80 (bytes)
 0x00000013 (RELENT)                     8 (bytes)
 0x6ffffffe (VERNEED)                    0x3e4
 0x6fffffff (VERNEEDNUM)                 1
 0x6ffffff0 (VERSYM)                     0x3b6
 0x6ffffffa (RELCOUNT)                   3
 0x00000000 (NULL)                       0x0
```

### .dynsym, .dynstr
对于在链接阶段未解析的符号，就需要在动态链接阶段进行解析和重定位，这些未解析的符号被保存在 .dynsym 中，而对应的字符串被保存在 .dynstr，在动态链接阶段，链接器将会一一地在已加载的动态库中找到对应的符号定义，并对符号进行重定位。  

### .got 
动态链接过程中的重定位并不像静态链接那样方便，对于静态链接而言，重定位过程可以直接修改指令中对数据的引用地址，因为静态链接操作的是 elf 文本，而动态链接则做不到，因为这时候指令已经被加载到内存中，且映射为只读属性。  

有些朋友就有疑问了，为什么要强行把代码段的数据映射为只读属性，映射成读写属性不行吗，这样动态链接过程就可以直接修改指令了，实际上还真不行。一方面，映射为只读属性是出于保护代码不被修改的目的，另一方面，如果动态库 A 引用了动态库 B，在重定位过程中修改了动态库 A 中的指令部分，但是，动态库是进程之间共享的，为某一个进程修改动态库会导致其它进程的引用出错。  

但是，对于所有的进程而言，动态库的数据部分是有独立的一份副本的，这也很好理解，程序的数据部分是读写属性的，对数据的操作由进程说了算，所以，在重定位过程中，既然不能修改代码部分，那么我们只能通过修改数据部分来完成重定位的过程。  








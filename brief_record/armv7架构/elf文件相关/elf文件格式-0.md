# elf 文件格式0 - 目标文件


## elf 文件格式总览
让我们来看看一个目标文件的 elf 格式总体布局是怎样的：TODO


就像一本书总会有目录前言一样，elf 文件在最开始的部分是一个文件头，文件头的作用就是整个文件的描述+目录，使得外部的程序通过读取文件头就可以获取整个文件的大致信息，比如文件类型、版本、对应的机器等。  

文件的第二部分是程序表 program header table，这是可执行文件相关的，我们将在下一节详细讨论这部分。  

第三部分是 sections，也就是我们经常提到的代码段、数据段所在的地方。  

最后一部分为段表，section header table，段表的作用是对文件中所有的段进行描述，段的起始地址，大小等信息。  

## 程序的链接与加载
在分析 elf 文件之前，我们需要了解 elf 文件的类型，elf 文件通常有三种类型：
* 二进制目标文件
* 可执行文件
* core dump 文件，这类文件是程序出错时产生的调试文件

对于二进制目标文件和可执行文件

## shdr(section header) 和 phdr(program header)

## 读取 elf 文件的软件


## 授人以鱼不如授人以渔
对于底层的分析而言，最好的方式是动手调试，看书往往只能建立一个整体的概念，尤其是在 linux 环境下工作，开源给我们带来了非常大的便利。   

上文中提到，linux 下有不同的命令可以解析 elf 文件并可视化地打印出来，你有没有想过，这些命令是如何做到能显示 elf 内部文件信息的呢？  

答案无非是它们可以读取并解析 elf 文件，那么，我们只需要拿到这些命令的源代码，找到文件的解析部分，elf 文件的所有细节可谓是尽收眼底。   

readelf 和 objdump 的源码位于 binutils 源码包中，[下载地址点这里](https://ftp.gnu.org/gnu/binutils/)，需要注意的是，参考 readelf.c , objdump.c 的实现即可。  

同时，除了看源码，还可以参考[官方文档](https://static.docs.arm.com/ihi0044/g/aaelf32.pdf)，参考官方文档的好处在于可以先建立一个完整的概念，但是需要注意的一点在于，需要特别注意文档的版本。  


## 示例代码
因为我们研究的是 elf 文件的整体框架，所以一个简单的示例就足够了，复杂的代码仅仅是增加了代码段的 size：

foo.c :
```
int param1;
int param2 = 0;
int param3 = 1;
int main()
{
    return 0;
}
```

在这个示例中，我们定义了三个全局变量，按照惯例，param1 和 param2 会被保存在 bss 段，因为它们没有被初始化或者初始化为 0 ，而 param3 会被保存在数据段，main 函数的实现则是在代码段中。   

将 C 程序编译为可执行文件：

```
gcc -c foo.c
```

生成可执行文件 foo.o ,使用 linux 下的 file 指令查看其文件类型：

```
file foo.o

```


## elf 文件头
对于不同的架构或者平台而言，elf 的格式上会有一些小的区别，比如对于 arm32 而言，elf 头是 48 字节，而 arm64 的 elf 头是 64 字节，在本章中我们主要针对 32 位平台进行分析。  






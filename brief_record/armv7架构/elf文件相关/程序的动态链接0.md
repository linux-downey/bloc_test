# 程序的动态链接0 - 动态库
在操作系统里面，动态库是被广泛使用的一种共享技术，相对于静态库提出的另一种程序库概念，又被称为共享库。  

从动态和共享这两个词可以看出动态库相对于静态库的两个特点：



* 动态链接，程序不会在编译时链接，而是在运行时进行链接
* 动态库可以被多个程序共享，在系统中只存在一份，尽管从物理地址上它只有一份，但是它可能被映射到不同的虚拟地址。  

从这一章开始我们就来分析动态库的相关概念。  




## 与静态库的对比
静态库代表的是一种简单粗暴的设计理念：将所有相关的程序编译链接到一个可执行文件中，这样相对于程序的加载和执行来说就非常简单了，将各个 segment 依据其属性为其分配对应的内存即可，其细节上要更复杂一些，但是总体来说工作量不大。简单是一个非常大的优势，但是静态库的缺点也非常明显：浪费空间、不方便升级维护和扩展。  

想象一下，将所有相关的程序编译到一个可执行文件中，这种几乎等同于"硬编码"的方式首先给人的感觉就是非常死板的，不论是从软件还是硬件上来看，模块化这个概念伴随着整个计算机的发展史，实际的发展也是遵循这个基本原则的，而静态库的使用正是 "反模块化"的一个异类。  

一个完整的应用程序中通常会包含一些共同的函数，比如 printf、strlen 等，静态库的方式可以让程序员实现代码上的复用，但是静态链接方式使得每个可执行文件中都包含这些公共函数的代码，每个程序加载到内存时都要为每个公共函数重新分配空间，作为一名合格的程序员来说，第一反应就应该是：这些公共的代码能不能在操作系统内存的角度上进行复用？    

静态链接的第二个问题，就是程序的升级维护问题，当我们用老版本的静态库发布了一个程序，在随后的一段时间内需要发布新的版本，或许是因为修复小bug，也可能是升级新功能，或者是业务变动将导致原版本的不适用。那么，我们要做的是将新的静态库发布给客户，客户使用新的静态库重新编译程序，将原程序替换为新程序。同样作为一名合格的程序员来说，你大概会问：我们能不能把需要升级维护的静态库从程序中剥离出来？  

一方面是复用，一方面是剥离，其实本质上就是追求库的模块化，而这个模块化的解决方案就是动态库，它的实现方式是这样的：

动态库的基本思想是将程序按照模块拆分成多个相对独立的部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接那样把所有的程序模块都连接成一个单独的可执行文件。  

动态库也是库的一种，外部程序可以使用动态库中的函数接口，对于静态库而言，在链接的符号解析和重定位过程会匹配所有的符号并找到它的实现，为其分配地址空间。而动态库不直接参与链接过程，但是程序在链接的过程中依旧需要指定动态库的位置，动态库将告诉编译器：这些符号在我的库里面，你就不用管它们的具体实现了。  

而对于那些找不到实现的符号，同时都没有在动态库中指定，链接器就会报 "undefined reference" 错误。  

至于具体是如何实现的，将在后续的文章中一一讨论。    



## 动态库的使用
在讨论其具体的实现机制之前，有必要先了解动态库到底是如何使用的，先对动态库的应用方式有一个大致的了解。  

### 动态库的编译
为了方便地演示，博主准备了一个简单的动态库示例：

```C
#include <stdio.h>
void foo(void)
{
        printf("foo\n");
}
void bar(void)
{
        printf("bar\n");
}
```
库中实现了两个函数接口：foo 和 bar，链接该库的外部程序可以直接调用。  

使用 gcc 将其编译成动态库：
```
gcc -fpic -shared foo.c -o libfoo.so 
```
编译增加了两个选项：-fpic 和 -shared。  

其中 -shared 表示生成动态库，-fpic 表示生成位置无关代码，关于位置无关代码我们将会后文中详细讨论。  

最终生成 libfoo.so, libxxx.so 是 linux 下动态库的标准命名。  



### 动态库的使用
编写一个简单的程序来引用动态库中的接口:

test_foo.c:
```C
void foo(void);
void bar(void);

int main(void)
{
        foo();
        bar();
        return 1;
}
```

这里偷了一个小懒，并没有以头文件的形式声明动态库的接口，而是直接在文件中声明引用的动态库函数。  

编译该 demo 程序：

```
gcc test_foo.c -L. -lfoo -o testfoo
```

正如上文所说，尽管链接过程不会将动态库中的接口链接到可执行文件中，但是还是需要指定需要链接的动态库，告诉链接器那些接口在动态库中，可以在链接阶段特殊处理。  

编译生成 testfoo 可执行文件，直接执行该可执行文件 ./testfoo ：

```
./testfoo: error while loading shared libraries: libfoo.so: cannot open shared object file: No such file or directory
```

发现执行会出错，通过分析报错信息可以知道，这是因为系统找不到动态库导致的执行错误。   

回到动态库的概念上来，上文中说到动态库是在程序执行阶段进行链接，所以，我们同样需要在程序加载运行的时候告诉系统，我们所提供的动态库在哪个地方，这样系统在执行程序时才能找到对应动态库完成动态链接。   



### 如何让系统找到动态库
一种方式是通过系统目录，将共享库放到系统目录中，对于可执行文件而言，其中记录了每个依赖的动态库名称，所以加载器可以由此去系统目录下寻找同名的动态库。  

一个系统中默认有以下存放共享库的位置：



* /lib
* /usr/lib

对于部分系统，/usr/local/lib 也支持。  

一般情况下，将指定的共享库放到系统目录下再进行编译，结果是在我们的预期之内的，但是有时候也会出现动态库没有更新或者没有使用指定版本的情况，这并不是系统的 bug，而是系统实现的机制，要了解这个问题的答案在于先搞清楚共享库的查找过程。  
使用 linux 的朋友们都知道，同一个系统中也可以存在多个不同的软件版本，linux 的做法是使用一个软链接，该软链接指向当前使用的软件版本(一般是系统中的最新版)，而软链接的名称为去除版本号的软件名，比如我们使用的 gcc，对应的系统可执行文件为 /usr/bin/gcc, 继续使用 ls -l 指令查看发现这个软链接指向 /usr/bin/gcc-4.8。    

对于动态库也是这样的情况，查看 /lib 或者 /usr/lib 目录下的动态库，通常可以看到这样的库版本:

```
...
lrwxrwxrwx 1 root root      15 May 23  2013 libacl.so.1 -> libacl.so.1.1.0
-rw-r--r-- 1 root root   22144 May 23  2013 libacl.so.1.1.0
-rw-r--r-- 1 root root   14208 Mar 27  2019 libanl-2.19.so
lrwxrwxrwx 1 root root      14 Mar 27  2019 libanl.so.1 -> libanl-2.19.so
...
```
使用软链接的方式来指定当前系统中使用的动态库，软链接的命名和软件中有点不一样，在动态库完整名称的基础上保留了 名称+主版本号，删除了次版本号和发布版本号。   

对于程序运行时动态库的查询，按照我们的理解就是在对应的系统目录下进行遍历，找到了就用，没找到就报错。实际上这种方式的效率是非常低的，如果按照这种方式，在一个大型系统上启动一个文件光加载动态库的过程都会十分缓慢，用户自然是不能接受的。如何解决这个问题呢？   

linux 系统中都有一个名为 ldconfig 的软件，这个软件的作用在于为共享库目录下的各个共享库创建、删除或者更新相应的软链接，保证每个软链接都能指向正确的共享库版本，此时加载器的操作对象就成了这些软链接，节省了确定版本的时间。  

同时，ldconfig 软件还会将系统当前的软链接收集起来，保存在 /etc/ld.so.conf 文件中，当动态链接器要查找共享库的时候，可以直接在该文件中查找，而且该文件经过特殊设计，非常方便字符串的查找，整个设计方案大大加速了共享库的查找过程。    
动态链接器除了查找 /etc/ld.so.conf 之后是否还会继续遍历 /lib,/usr/lib 目录这是由实现来决定的，从这个角度来说，只要我们修改了系统目录中的动态库，就应该使用 ldconfig 命令更新共享库的版本信息，即将最新的改动更新到 /etc/ld.so.conf 这个缓存文件中，这样才能确保万无一失。  




第二种方式就是使用环境变量的方式，动态库路径对应的环境变量名为：LD_LIBRARY_PATH, 将动态库存放的路径添加到环境变量中即可：

```
export LD_LIBRARY_PATH=$DIR:$LD_LIBRARY_PATH         // $DIR：动态库存放路径
```

设置完成之后再执行可执行程序，就可以得到正确的执行结果：

```
# ./testfoo

foo
bar
```



## 动态库的版本

对于动态库而言，可以非常方便地进行升级和维护，因为程序的开发和共享库的更新可以独立地进行，所以共享库的开发者会不停地更新共享库的版本，以修正共享库的 bug、升级新的功能或改进性能等。   

在理想的状态下，共享库会在更新共享库的同时保持与之前版本的兼容，实际上这很难做到，如果要保证完整的兼容性，就不能对接口有形式上的修改和删除行为，长此以往，动态库将会越来越大，包含的垃圾也会越来越多，一方面要求兼容性，另一方面希望去除共享库的冗余，这其实是矛盾的，而且这种矛盾无论在库上还是在系统接口上，都无法避免。  

于是共享库的更新分为两种：兼容更新和不兼容更新。  

兼容更新指所有的更新只是在原有的基础上添加一些内容，所有的原有接口都能保持不变。  

而不兼容更新指更新了原有的接口，使用该共享库原有的接口可能导致程序不能运行或者运行不正常。  


面对多个更新的版本，需要一个良好的版本管理机制，而版本管理的基础在于版本号的命名，linux 下有一套标准的版本命名方式，它规定共享库的命名方式如下：

```
libname.so.x.y.z
```

前缀是 lib，中间是库的名字，后接 .so, 这是库的标准命名方式，在使用 -l 指令执行库的链接时只需要提供库的名字。  

后面的 .x.y.z 表示版本号，"x" 表示主版本号，"y" 表示次版本号，"z" 表示发布版本号，三个版本号表示不同的含义。  

主版本号表示库的重大升级，主版本不同的库一般是不兼容的，依赖于旧版本库的程序如果需要使用新版本的特性需要重新编译。  
次版本号表示库的增量升级，通常是增加一些新的接口，原来的接口保持不变，在主版本相同的情况下，高的次版本的库兼容低次版本的库。  

发布版本号表示库中一些小的bug修正，性能的改进等等，一般不会添加任何新的接口，也不会修改接口。主次版本号相同，而发布版本号不同的库之间接口是相互兼容的。  

尽管标准已经制定，但是由于一些历史原因，某些库的版本号并没有严格地按照该标准进行命名，有些可能按照 libname.x.y.z.so 的方式进行命名，而有些库没有按照 .x.y.z 的等级进行划分，而是使用 .x 或者 .x.y 的形式，最常接触到的 libc 及其相关的库就是这样一个特例，使用 libc.x.y.so 这样的命令，这些库都可以在 /lib 和 /usr/lib 下看到，你可以看一下有哪些顽固分子。  

在 linux 中，不仅仅是库，官方软件的版本号都是以 .x.y.z 的方式进行发布，比如 gcc，busybox，linux 内核等，在学习它们之前非常有必要了解它们的版本机制。  





### 参考

[binutils源码](https://ftp.gnu.org/gnu/binutils/)

[arm elf 文档](https://static.docs.arm.com/ihi0044/g/aaelf32.pdf)

<<程序员的自我修养>>

---

[专栏首页(博客索引)](https://zhuanlan.zhihu.com/p/362640343)

原创博客，转载请注明出处。







# armv7-A系列-arm汇编以及常用指令  
随着计算机行业的发展，C/C++ 几乎都已经沦落为"低级语言"了，更别提最靠近底层的汇编了，在大家的印象中，汇编语言早已经半截入土，作为一门最靠近硬件的语言，在应用程序中确实早已经销声匿迹了，但是对于驱动工程师而言，还需要时不时地跟它打打交道，相对于 C/C++ 而言,汇编还是有它自己的优势的：  

首先，C 语言的执行是需要建立一定的环境的，在 C 语言环境建立之前，所有执行的代码只能是汇编指令，最典型的场景就是芯片的启动部分。  

即使是 C 语言的环境已经建立，对于某些系统级别的操作，也只能是由汇编语言实现，比如 CPU中断、MMU、进程调度时断点恢复。  

同时，作为最贴近硬件的语言，它的执行效率要往往比上层语言更高，在一些系统关键的、频繁执行的部分，可以由汇编语言实现。  

学习汇编，一方面了解计算机的运行原理，这算是程序员的内功，另一方面，也是一个驱动工程师的必经之路，因为系统级别的操作必然是要用到汇编的。  

在这一章节中，我们来讨论 arm 汇编以及它的常用指令，就目前而言，几乎没有哪个应用需要完全使用汇编编写，通常需要使用到的地方就是分析和修改系统级别的汇编指令，比如 Uboot启动代码、内核启动代码、中断跳转、进程调度、glibc启动代码等部分中的汇编指令，所以暂时没有必要去熟悉所有的汇编指令，只需要做到能看懂能修改，当然，做到这个也并不是很容易。  

## armv7 汇编通用规则
在 armv7 的汇编中，有一些通用的规则，因为汇编语言几乎是不可移植的，所以这些规则是 armv7 汇编指令所特有的。  


### 指令后缀
不知道你有没有碰到过这样的情况：在代码中看到某条汇编指令，不清楚它的意思，于是到 armv7 手册中查询，居然也查不到这条指令。这就是因为 armv7 指令集中的汇编指令在一些特定的情况下可以带有一些指令后缀，当然，不同的指令后缀有不同的含义。  

#### 条件执行
armv7 的 arm 指令集中每一条指令的最高四位为 cond 位，表示当前指令的"条件执行"，大部分指令都可以通过指示指令条件来决定当前指令是否执行，通常用作分支指令，而这种指定是否执行的方式就是添加条件执行的后缀，比如 beq，b 是一条跳转指令，而 eq 后缀表示只有当状态寄存器 CPSR 的 Z 位为 1 时才会执行当前指令。  

对于条件执行部分，具体的可以参考我的另一篇博客：TODO。

#### 更新 CPSR
默认情况下，大部分指令都不会更新处理器的状态寄存器 CPSR，但是对于这些指令，可以通过添加后缀 S 来影响 CPSR，比如 adds 指令，如果运算结果为负，CPSR 的 N 位将会被置为，对于其它的状态位也是同样的效果。  

后缀S 还有一个隐藏的动作，就是将 spsr 中的值更新到 cpsr 中。TODO

#### 指定指令的长度
armv7 支持多种指令集，对于 thumb 指令集而言，有 16 位指令和 32 位指令两种，Thumb1 只有 16 位，而 thumb2 扩展了 32 位的指令，对于同一个操作，比如 mov r0,#1 ，同时使用 16 位和 32 位的指令都可以实现，汇编器会选择 16 位的指令实现。  

如果添加后缀 .W(wide) 则强制使用 32 位指令，相对应的如果使用 .N(narrow)，则强制使用 16 位指令，16 位和 32 位指令在指令密度、功耗、执行效率等方面都有一些区别，在实际应用中可能因为这个因素而选择不同位数的指令。  

但是，如果强制使用 16 位的指令，但是该指令无法对该指令进行编码，比如寻址范围超出，就会报错。  

因为 arm 指令集都是 32 位的，如果在 arm 指令集中使用 .N 将会直接报错，而 .W 不会产生任何影响。  


### 立即数的合法性
对于一个 32 位或者 16 位的指令，是无法将一个 32 位的立即数装进指令的，所以这时候就需要一些技巧，就是从指令中划分出特定的一些位来表示立即数，通常是 12 位及以下，特殊指令会达到 16 位甚至以上，拿 12 位举例：

其中 8 位表示基数，其余 4 位乘以 2 表示循环位移的位数，8 位最多表示 0~0xff，而循环位移的位数为 0~30，范围可以覆盖到 4G，但是并不是完全覆盖，关于立即数的使用可以参考我的另一篇博客：TODO


## 伪汇编指令
汇编指令是系统定义的，直接对应处理器的硬件行为，比如 add 表示要调用处理器的加法器，而伪汇编指令针对编译器，表示我要做这个操作，但是我不方便做，所以麻烦汇编器帮我将这个操作翻译成具体的汇编指令，这就是伪汇编指令的含义，为了方便编程而产生，将具体的实现工作移交给汇编器。  

### 标号
标号是汇编程序中最常见的伪指令，标号由一串字符串组成，用于标识一个地址，这个地址等于标号后的第一条指令的地址，通常会被用在跳转指令中，如果不使用标号，就需要使用固定的跳转偏移地址，这是非常不方便的，因为标号的地址在汇编阶段是动态确定的。  

### 数据放置指令
以 armv7 的 arm 指令集来说，每条指令都是 4 字节，即一个 word，每次执行完当前的指令就会顺序地执行下一条指令，有时候会有需求将数据放在当前指令处，比如字符串、其它只读数据，就可以使用伪指令将数据放在特定的地址：
* .byte expression, .hword expression, .word expression,.quad，分别放置一个字节、双字节、四字节数据，而对于 64 位平台，word 为 8 字节。  
* .ascii string:放置一个字符串，可以放置多个字符串，以逗号分开

### 符号或数据导入导出

.extern symbol: 表示该符号是定义在别的源文件中，这和 C 语言中的 extern 作用是类似的。 
.globl symbol： .global 指令告诉汇编器这个符号是全局可见的，其它的源文件也可以使用。  
.local symbol: 定义局部符号，这个指令很少用，默认情况下就是局部符号，当同时使用 globl 和 local 时，总是最后一个有效，也就是这个指令可以用来 disable globl 符号。  
.set:设置一个符号的值，这种定义在形式上类似于 C 语言中的变量，和 C 中的变量不一样的是，它只作用于编译阶段，而不会对应运行时地址空间，因此更像是 C 中的宏。通过设置一个符号的值，在后续的代码中可以重复使用该符号的值。我们可以看下面的示例：

```
.set sym_set,0x100
mov r0,#sym_set
```
执行结果就是 r0 中保存了 0x100

.include "filename"：将包含的文件插入内容插入到当前的指令地址处，和 C 中的 #include 作用是一致的。 

同时，在汇编文件中，可以直接使用 #include，但是并不是汇编支持这种方式，而是在预编译阶段会对 #include 头文件包含进行处理。 

### 混合使用 C 语言特性
在汇编文件中，可以混合使用 C 语言

### 杂项指令
















# arm-linux 系统调用流程

在 linux 中,软硬件是有明显的分层的,出于安全或者是资源统筹考虑,硬件资源由内核进行统一管理,内核拥有绝对的权限,而用户空间无法直接访问硬件.在实际的应用中,用户进程总是无法避免需要操作到硬件,这个硬件可能是磁盘文件,USB接口等,这时候就需要向内核递交申请,让内核帮忙做硬件相关的事情,这个过程就由系统调用完成.  

无论从硬件还是从软件角度来说,用户空间与内核空间有一道无法轻易逾越的屏障,如果是简单地一分为二,事情并不会有多复杂,不幸的是,这两者不能简单地完全隔断,用户空间的大部分操作都需要通过内核来完成,就连简单的申请内存操作,用户空间都无法独立自主地做到,因为这涉及到物理内存的分配,而物理内存也是硬件的一种,所以在这道屏障上需要开一扇门,来进行内核与用户之间的交互,这道门也就是系统调用.  

用户空间的东西不能进入到内核中,内核中的东西自然也不能暴露到用户空间中,所有请求与回复的资源都只能通过传递的方式,而这种信息传递还需要通过严格的检查.这就像在监狱中,服刑人员只能向监管人员提出申请,让他帮忙代办一些事情,而不能提出申请自己亲自出去办某件事,监狱内和外部世界是有严格划分的.  

也就是说,用户程序执行系统调用时,由内核代替该进程去执行该用户原本没有权限执行的工作,比如磁盘操作,而用户程序等待内核的执行完成,再返回到该用户程序(实际情况会涉及到各进程的调度,为了理解方便这里简化了概念).该过程的另一种说法叫陷入内核.  

从形式上来说,系统调用看起来就跟普通的 API 一样,比如进程需要读磁盘上的文件,使用 read 接口,因为普通用户没有读磁盘的权限,所以需要通过系统调用让内核帮忙做这件事,在实际的编程中,每当我们使用 read 函数时,内核中的 sys_read 函数就会被调用,看起来 sys_read 是 read 函数中的一个子程序一样,但是实际上情况要复杂得多.  

read 函数处于用户空间,而 sys_read 处于内核空间,这两者明显不是调用与被调用的关系,而是一方请求另一方帮忙处理工作的过程,而 API 只是简单的程序调用而已,这两者的区别不言而喻.

在这一章中,我们将深入地讨论系统调用的执行过程,看看用户空间到底是如何通过系统调用这道门进入到内核,又是如何从内核返回的.   

本文是基于 armv7 平台架构的分析,自然需要对 arm 的体系架构有一定的了解,关于 armv7 的指令架构,可以参考我的这些博客 TODO.

## 预备知识
本文是基于 armv7 平台架构的分析,自然需要对 arm 的体系架构有一定的了解,关于 armv7 的指令架构,可以参考我的这些博客 TODO.

## EABI 和 OABI
ABI 是应用程序二进制接口,每个操作系统都会为运行在该系统下的应用程序提供应用程序二进制接口（Application Binary Interface，ABI）。ABI包含了应用程序在这个系统下运行时必须遵守的编程约定,对于 arm 的函数调用而言,它定义了函数调用约定,系统调用形式以及目标文件的格式等.  

在 arm 平台架构中,存在两种不同的 ABI 形式,OABI 和 EABI,OABI 中的 O 是 old 的意思,表示旧有的 ABI,而 EABI 是基于 OABI 上的改进,或者说它更适合目前大多数的硬件,OABI 和 EABI 的区别主要在于浮点的处理和系统调用,浮点的区别不做过多讨论,对于系统调用而言,OABI 和 EABI 最大的区别在于,OABI 的系统调用指令需要传递参数来指定系统调用号,而 EABI 中将系统调用号保存在 r7 中.  

所以在系统调用的源码实现中,尽管大多数情况下都是使用 EABI 的系统调用方式,也会保持对 OABI 的兼容,而 CONFIG_OABI_COMPAT 表示是否保持对 OABI 的兼容,大部分平台都没有定义,所以在本章的讨论中不包括 OABI 的部分.  

## 系统调用的接口
了解了系统调用的基本概念之后,我们同样需要知道,系统调用有哪些?  

系统调用由内核中定义的一个静态数组描述的,这个数组名为 sys_call_table,系统调用的数量由 NR_syscalls 这个宏描述,这些系统调用的定义在 entry-common.S 中:

```
syscall_table_start sys_call_table
#include <calls-eabi.S>
...
```
syscall_table_start 宏定义了 sys_call_table 符号,并使用 #include 包含了 calls-eabi.S 文件,如果你完全理解了 #include 这个预编译指令. 












# armv7-A系列- arm 指令集以及编码
尽管在日常的编程中基本涉及不到指令集层面的工作，即使是使用汇编语言也是经过了一层封装的指令集，但是我们肯定听过这么一个概念：arm 架构使用的是精简指令集，这是 arm 在功耗上的制胜关键，而功耗也是 arm 处理器的一个非常大的特点。  

那么，我们首先要弄清楚的几个概念就是：
* 什么是指令集？
* 什么是精简指令集？
* arm 使用什么指令集？


## 什么是指令集
对于这个问题，实际上要清晰地讲解这个问题需要涉及到相当多的数字电路知识，那样只会非常枯燥，而且博主的硬件水平也着实一般，所以我们就尝试抛开硬件细节，简单地聊聊这个概念。  

对于指令集的描述，学术化的说法是：CPU 的指令集是软件与 CPU 这两个层级之间的接口，而 CPU 自己，就是对于这一套 CPU 指令集的 "实例化"。   

通俗一点的说法是，指令集是一个规范，该规范告诉编译器该处理器支持什么样的操作以及如何操作，同时定义了一套编码方式，这套编码方式也就对应我们常说的机器码，编译器需要将汇编指令严格地按照该编码方式生成指令，即使是一个 bit 的错误也不接受。  

定义总是枯燥而难懂的，我们举一个相对简单的例子：首先，在处理器中，加减乘除的运算、内存的读写这些主要的功能都是由硬件通过搭建逻辑门电路实现的，对于硬件具体的实现，我们不去讨论，如果有兴趣，可以参考我的另一篇博客：CPU 中的加法是如何实现的 TODO。 

既然硬件实现了这么多的功能，那么我怎么区分并使用这些功能呢？就像每个人都有自己的名字，当我们要指派某个人做事时，只要给出名字+要做的事即可。  

对于硬件实现的功能也是一样，对于加减乘除，我们肯定会用不同的编码对其进行区分，比如加法对应 0000、减法对应 0001，以此类推，这样当我们在使用加法时，直接发出指令 0000 即可。同时，如果你要执行加法，自然需要输入两个加数，然后获取结果，所以，指令功能的编码+输入部分+输出部分+其它参数 就构成了一条指令编码，程序员编程自然不能直接使用编码，于是厂商就为其定制一条汇编指令来对应这个编码。  

作为一个简单的示例，我们来自创一条最简单的加法指令，我们就将其命名为 myadd，这个命名只针对编译器，首先，还是用 0000 表示加法功能的编码，使用 4 位表示加数，两个加数就占用 8 位，然后使用 4 位表示存储结果的地址，所以这条指令就是一条 16 位指令。它最多支持 16 条指令(0000~1111)，支持 16 以下的加法(0000~1111)，寻址地址范围也是 16(0000~1111)。   

好了，我们现在来使用它，首先来计算一个 4+5，把结果保存在 8 地址处，对于汇编指令形式为：

```
myadd #8,#4,#5    //myadd 第一个参数为结果地址、后续两个参数是加数
```

编译器编译出来的指令集编码为：0000 + 0100 + 0101 + 1000 = 0x0458, myadd #8,#4,#5 就是一条汇编指令，而 0x0458 就是这条指令对应的机器码，机器码是可以直接被处理器执行的，当我们将这条指令地址赋值给 PC 指针是，就可以在内存 8 地址处，看到加法指令的结果：9。  

每一条指令就是一个单独的操作，包含操作类型，被操作数或者被操作数的地址。  

而指令集，就囊括了这些指令，编码方式，严格来说，它并不仅仅是多条指令的集合。      

当然，实际的情况并不是如此，对于 arm 而言，加数和结果都是保存在寄存器中，而不是使用立即数，使用 4 个 bits 来指示寄存器的编码，r0 ~ r15，对于指令的编码还有一些其它的选项参数，不过，通过该示例我们可以大概了解指令、编码以及指令集的相关概念。  

## 什么是精简指令集
要了解精简指令集(RISC)，就得知道另一个相对的概念：复杂指令集(CISC)，这两种指令集是两种完全不同的 CPU 设计理念。    

早期的CPU全部是CISC架构，它的设计目的是要用最少的机器语言指令来完成所需的计算任务。比如对于乘法运算，在CISC架构的CPU上，您可能需要这样一条指令：MUL ADDRA, ADDRB就可以将ADDRA和ADDRB中的数相乘并将结果储存在ADDRA中。将ADDRA, ADDRB中的数据读入寄存器，相乘和将结果写回内存的操作全部依赖于CPU中设计的逻辑来实现。这种架构会增加CPU结构的复杂性和对CPU工艺的要求，但对于编译器的开发十分有利。比如上面的例子，C程序中的a*=b就可以直接编译为一条乘法指令。  

RISC架构要求软件来指定各个操作步骤。上面的例子如果要在RISC架构上实现，将ADDRA, ADDRB中的数据读入寄存器，相乘和将结果写回内存的操作都必须由软件来实现，比如：

```
MOV A, ADDRA; 
MOV B, ADDRB; 
MUL A, B; 
STR ADDRA, A
```

对于上面的示例而言，一条复杂指令对应 4 条精简指令，普遍情况下，一条复杂指令的功能相当于多条精简指令的集合,提供灵活的复杂指令集可以实现强大的功能，但是同时也意味着更复杂的硬件电路，从而其造价和各方面的成本也相应提高，虽然一条复杂指令所做的事可能需要多条精简指令才能完成，但是精简指令对于电路的重用率要高于复杂指令，所以对于实现同样的需求，精简指令集对应更简单的电路。  

但是，复杂指令集功能更强大意味着能做更多的事，对于实现同一个需求而言，一条复杂指令所起到的效果比多条精简指令集的组合通常来说效率是更高的，比如上面所举例提到的复杂指令集中可以直接内存操作，而精简指令集需要转到寄存器中执行，然后进行内存与寄存器之间数据的拷贝。按照这个理论来看的话，复杂指令集除了硬件电路更加复杂以外，其它的方面都应该要强于精简指令集的，但是实际上却并非如此。  

因为复杂指令集致力于设计更灵活的指令以达到更高的性能，硬件工程师采用的办法是不断增加可实现复杂功能的指令和多种灵活的编址方式，同时需要考虑兼容性，导致 CISC 计算机所含的指令数目非常多，一般 300 条以上，有的甚至超过 500 条，但是在实际的应用中发现，对一些典型的应用程序，其运算过程所使用到的 80% 的指令，只占一个处理器指令系统的 20%，而最频繁使用的指令通常是内存存取、加减等操作，(像if、while、for，变量定义等往往是程序中用得最多的，而这些只需要用到一些简单的指令)，所以，在这种应用背景下，大多数的复杂指令以及其搭配的硬件电路都是冗余的，但是却占用了很多资源。   

于是 RISC 的概念就被提出，其理念就是挑选出一些最常用的指令，组成一个指令集，而对于那些复杂的操作，则通过多条指令的组合来实现，这会增加编译器的难度，但是在硬件设计可以降低成本，同时因为硬件冗余的减少，也可以降低处理器的功耗(当然，这只是一方面)。所以，在及其看中成本和功耗的中低端嵌入式领域，arm 逐渐占据了市场主导权。  

## armv7 指令集
armv7 支持两种指令集，ARM 指令集和 Thumb 指令集，其中，Thumb 指令集包括 Thumb1、Thumb2 和 ThumbEE，Thumb2 和 ThumbEE 均是升级版的指令集，arm 和 thumb 两种指令集有以下的特点：
* Thumb 指令集有 16 bits 和 32 bits 两种类型，其对齐方式为 half word，即双字节对齐，两种指令集中的指令可以自由地混合使用，Thumb 指令集的优势在于它的 16 bits 形式，在实际的使用中，很多常见的操作都可以使用 16 bits 的 thumb 指令集完成，如果使用 arm 指令集，就会占用更多的指令内存。尽管对于稍复杂的指令操作，一条 32 bits 的指令效果可能对应多条 16 bits 的指令组合(这时候也可以使用 32 bits 的 thumb 指令，没有切换成本)，但是总体上 16 bits 指令代码密度是更高的。  
* arm 指令集总是 32 bits 的，指令边界需要四字节对齐，同时 32 bits 的指令集功能自然是更加强大的，至于为什么强大我们可以从后续的指令编码分析部分看出。  
* 从功耗上来说，thumb 指令集的功耗要低于 arm 指令集。  


### arm 指令集编码
对于 arm 指令集的编码，我们可以参考下图：TODO

这是对于 arm 指令集总体的划分：
* cond 部分表示条件执行，每条指令都可以带上执行条件，功能实现更加灵活，关于条件执行的细节部分可以参考我的另一篇博客：arm 状态寄存器TODO。
* op1 和 op 用于给不同的指令进行分类，也可以看成是作为区分指令编码的一部分。  

对于 op1 和 op，其值对应的关系是这样的：

```
op1    op    指令类型
00x    -     数据处理以及杂项指令
010    -     load/store word类型 或者 unsigned byte
011    0     同上
011    1     媒体接口指令
10x    -     跳转指令和块数据操作指令，块数据操作指令指 STMDA 这类，连续内存操作。
11x    -     协处理器指令和 svc 指令，包括高级的 SIMD 和浮点指令。  

```

除了 cond 、op1 和 op，指令编码的其它 24 位由具体的指令使用，因为指令对应的参数不同，所以需要占用的编码资源也不一样，所以 arm 指令编码方式为基准将指令分成上述的类别，下面我们简要地讨论 arm 指令集中一些常见的编码方式。  

### 立即数
在汇编指令中，我们经常会使用到立即数，也有非常多的指令支持立即数的使用，它的范围可以是 32 位的，比如：mov r0 #0xff00000000

问题就来了，指令编码总共就 32 位，它是如何将另一个 32 位的立即数包含到指令中的？  

事实上，立即数的范围确实是 32 位，但立即数的范围并不是完全覆盖 0～0xffffffff，通常使用指令中的 12 位来表示立即数，前八位表示立即数的"基数"，而后 4 位的值乘上 2 表示循环右移值，比如 0b000011110010，前八位的值是 0x0f，而后四位的值为 0x2，所以这个立即数的值为 0xf0 循环右移 2*2 = 4 位，结果为 0xf00000000。  

这也就衍生出了一个概念：有效立即数和无效立即数，对于某些数字是不能通过这种位移方式产生的，比如 0x11f，所以它是无效的立即数，使用无效立即数编译将会报错，在官方的手册中，对于有效的立即数定义是这样的：
* 上述通过位移产生的立即数
* 0x00xy00xy 形式的
* 0xxy00xy00 形式的
* 0xxyxyxyxy 形式的

其中 xy 表示 16 进制数，范围是 0x00 ~ 0xff。  

对于其它的立即数，都是无效立即数。  

```
博主在实际的测试中，发现与手册中描述不一致，在 arm-gcc 4.8 和 6.2 上，都不支持后面三种立即数形式，只支持第一种，编译器的实现和标准并不吻合。  

而且发现一个有意思的现象：mov r0,#0xfffffffe 这条指令是合法的，很明显可以看出 0xfffffffe 是一个非法的立即数，查看汇编代码才发现，不管选择哪个优化级别，编译器都会将这条指令替换为：mvn r0, #1 。mvn 表示将立即数取反再 mov，结果是一样的。从这可以看出，在实际情况下，我们还应该将编译器的优化考虑进去。  
```

那么，如何获取一个无效立即数呢？
在上文中提到，通常情况下指令中只有 12 位来表示立即数，但是对于某些特殊的指令，支持 16 位甚至更多的位来表示一个立即数，比如 arm2 指令集中，movw 表示将寄存器移动到寄存器的低 16 位，它支持 16 位的立即数，因此该立即数可以是任意的 16 位值，同时相对应的 movt 操作高 16 位，利用着两条指令的组合可以获取一个随意的 32 位立即数，这种做法是最常见的。  

另一种方法就是通过有效立即数的组合实现，比如：0x12000034，可以通过将 0x12000000 和 0x34 分别放在寄存器中，然后相加，就得到这个立即数，这种方式的组合可能需要多条指令完成。  

还有一种方式就是，将一个立即数保存在内存中，然后使用 ldr 指令将这个数从内存中加载到寄存器中，一般只需要两条指令，但是内存的访问速度要远慢于寄存器的操作，即使是高速缓存命中也有一些执行效率上的差距。  

后面的两种做法已经很少用了，通常是在 armv6 架构上使用得比较多。  

### 寄存器操作
arm 规定了数据只能在寄存器中处理，而不能直接操作内存，所以在 arm 指令中存在非常多的寄存器操作，因为 arm 只有 16 个寄存器，所以只需要使用 4 bits 来指定一个寄存器，所以通常一条指令中可以指定多个寄存器。比如：mov r0,,r1 。 

除了普通的寄存器操作，非常常见的还有移位寄存器,通过将寄存器中的值进行位移来获取一个目标值，这和使用立即数的效果是差不多的，寄存器值占 4 bits，位移参数占 3~4 bits，这对指令编码来说是足够的。  

当时对于 16 位的 thumb 指令集来说，情况就没有那么乐观了，如果你使用过 16 位的 thumb 指令集，就会发现，某些指令只能访问 CPU 的前 8 个寄存器，这是因为 thumb 指令集的编码不够用，当然，享受了代码密度和功耗的福利，自然要牺牲一些，毕竟，计算机中无处不充斥着权衡的艺术。  


### 位图
对于一些连续内存操作，通常是指定寄存器，就会需要使用到其它的指定方式，比如位图，比如 STMDA 指令，这条指令的参数可以是一个寄存器列表，依次将寄存器列表中的值保存到指定的连续地址，这时候用 4 bits 去表示每一个寄存器自然是不够的，处理方法是使用 16 个 bits，每一个 bit 代表一个寄存器，哪个寄存器需要被操作到，就将对应的 bit 置 1，这样就可以只使用 16 位来表示 16 个寄存器。  


其实看了这么多的指令编码，其本质上就是想办法使用 32 bits 编码实现 "一条指令的唯一识别+指令n个参数的表达+指令条件"。  



[知乎回答：CPU指令集](https://www.zhihu.com/question/20793038)
[RISC与CISC比较](https://blog.csdn.net/u010275850/article/details/46129071)
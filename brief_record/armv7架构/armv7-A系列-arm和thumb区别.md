# armv7-A系列- arm、thumb 指令集以及编码
尽管在日常的编程中基本涉及不到指令集层面的工作，即使是使用汇编语言也是经过了一层封装的指令集，但是我们肯定听过这么一个概念：arm 架构使用的是精简指令集，这是 arm 在功耗上的制胜关键，而功耗也是 arm 处理器的一个非常大的特点。  

那么，我们首先要弄清楚的几个概念就是：
* 什么是指令集？
* 什么是精简指令集？
* arm 使用什么指令集？


## 什么是指令集
对于这个问题，实际上要清晰地讲解这个问题需要涉及到相当多的数字电路知识，那样只会非常枯燥，而且博主的硬件水平也着实一般，所以我们就尝试抛开硬件细节，简单地聊聊这个概念。  

对于指令集的描述，学术化的说法是：CPU 的指令集是软件与 CPU 这两个层级之间的接口，而 CPU 自己，就是对于这一套 CPU 指令集的 "实例化"。   

通俗一点的说法是，指令集是一个规范，该规范告诉编译器该处理器支持什么样的操作以及如何操作，同时定义了一套编码方式，这套编码方式也就对应我们常说的机器码，编译器需要将汇编指令严格地按照该编码方式生成指令，即使是一个 bit 的错误也不接受。  

定义总是枯燥而难懂的，我们举一个相对简单的例子：首先，在处理器中，加减乘除的运算、内存的读写这些主要的功能都是由硬件通过搭建逻辑门电路实现的，对于硬件具体的实现，我们不去讨论，如果有兴趣，可以参考我的另一篇博客：CPU 中的加法是如何实现的 TODO。 

既然硬件实现了这么多的功能，那么我怎么区分并使用这些功能呢？就像每个人都有自己的名字，当我们要指派某个人做事时，只要给出名字+要做的事即可。  

对于硬件实现的功能也是一样，对于加减乘除，我们肯定会用不同的编码对其进行区分，比如加法对应 0000、减法对应 0001，以此类推，这样当我们在使用加法时，直接发出指令 0000 即可。同时，如果你要执行加法，自然需要输入两个加数，然后获取结果，所以，指令功能的编码+输入部分+输出部分+其它参数 就构成了一条指令编码，程序员编程自然不能直接使用编码，于是厂商就为其定制一条汇编指令来对应这个编码。  

作为一个简单的示例，我们来自创一条最简单的加法指令，我们就将其命名为 myadd，这个命名只针对编译器，首先，还是用 0000 表示加法功能的编码，使用 4 位表示加数，两个加数就占用 8 位，然后使用 4 位表示存储结果的地址，所以这条指令就是一条 16 位指令。它最多支持 16 条指令(0000~1111)，支持 16 以下的加法(0000~1111)，寻址地址范围也是 16(0000~1111)。   

好了，我们现在来使用它，首先来计算一个 4+5，把结果保存在 8 地址处，对于汇编指令形式为：

```
myadd #8,#4,#5    //myadd 第一个参数为结果地址、后续两个参数是加数
```

编译器编译出来的指令集编码为：0000 + 0100 + 0101 + 1000 = 0x0458, myadd #8,#4,#5 就是一条汇编指令，而 0x0458 就是这条指令对应的机器码，机器码是可以直接被处理器执行的，当我们将这条指令地址赋值给 PC 指针是，就可以在内存 8 地址处，看到加法指令的结果：9。  

而指令集，就囊括了这些指令，编码方式，严格来说，它并不仅仅是多条指令的集合。      

当然，实际的情况并不是如此，对于 arm 而言，加数和结果都是保存在寄存器中，而不是使用立即数，使用 4 个 bits 来指示寄存器的编码，r0 ~ r15，对于指令的编码还有一些其它的选项参数，不过，通过该示例我们可以大概了解指令、编码以及指令集的相关概念。  

## 什么是精简指令集
要了解精简指令集(RISC)，就得知道另一个相对的概念：复杂指令集(CISC)，这两种指令集是两种完全不同的 CPU 设计理念。    

早期的CPU全部是CISC架构，它的设计目的是要用最少的机器语言指令来完成所需的计算任务。比如对于乘法运算，在CISC架构的CPU上，您可能需要这样一条指令：MUL ADDRA, ADDRB就可以将ADDRA和ADDRB中的数相乘并将结果储存在ADDRA中。将ADDRA, ADDRB中的数据读入寄存器，相乘和将结果写回内存的操作全部依赖于CPU中设计的逻辑来实现。这种架构会增加CPU结构的复杂性和对CPU工艺的要求，但对于编译器的开发十分有利。比如上面的例子，C程序中的a*=b就可以直接编译为一条乘法指令。今天只有Intel及其兼容CPU还在使用CISC架构。

RISC架构要求软件来指定各个操作步骤。上面的例子如果要在RISC架构上实现，将ADDRA, ADDRB中的数据读入寄存器，相乘和将结果写回内存的操作都必须由软件来实现，比如：MOV A, ADDRA; MOV B, ADDRB; MUL A, B; STR ADDRA, A。这种架构可以降低CPU的复杂性以及允许在同样的工艺水平下生产出功能更强大的CPU，但对于编译器的设计有更高的要求。  

两种指令集其实对于不同的应用环境有不同的优劣，为什么以 arm 为代表的 RISC 架构可以在嵌入式领域占据主导地位呢？这主要是从实际应用的两方面来考虑：成本和功耗。   

提供灵活的复杂指令集可以实现强大的功能，但是同时也意味着更复杂的硬件电路，从而其造价和各方面的成本也相应提高，虽然一条复杂指令所做的事可能需要多条精简指令才能完成，但是精简指令对于电路的重用率要高于复杂指令，所以对于实现同样的需求，精简指令集对应更简单的电路。  

但是，复杂指令集功能更强大意味着能做更多的事，对于实现同一个需求而言，一条复杂指令所起到的效果比多条精简指令集的组合通常来说效率是更高的，比如上面所举例提到的复杂指令集中可以直接内存操作，而精简指令集需要转到寄存器中执行，然后进行内存与寄存器之间数据的拷贝。按照这个理论来看的话，复杂指令集除了硬件电路更加复杂以外，其它的方面都应该要强于精简指令集的，但是实际上却并非如此。  

因为复杂指令集致力于设计更灵活的指令以达到更高的性能，硬件工程师采用的办法是不断增加可实现复杂功能的指令和多种灵活的编址方式，同时需要考虑兼容性，导致 CISC 计算机所含的指令数目非常多，一般 300 条以上，有的甚至超过 500 条，但是在实际的应用中发现，对一些典型的应用程序，其运算过程所使用到的 80% 的指令，只占一个处理器指令系统的 20%，而最频繁使用的指令通常是内存存取、加减等操作，(像if、while、for，变量定义等往往是程序中用得最多的，而这些只需要用到一些简单的指令)，所以，在这种应用背景下，大多数的复杂指令以及其搭配的硬件电路都是冗余的，但是却占用了很多资源。   

于是 RISC 的概念就被提出，其理念就是挑选出一些最常用的指令，组成一个指令集，而对于那些复杂的操作，则通过多条指令的组合来实现，这会增加编译器的难度，但是在硬件设计可以降低成本，同时因为硬件冗余的减少，也可以降低处理器的功耗(当然，这只是一方面)。所以，在及其看中成本和功耗的中低端嵌入式领域，arm 逐渐占据了市场主导权。  



[知乎回答：CPU指令集](https://www.zhihu.com/question/20793038)
[RISC与CISC比较](https://blog.csdn.net/u010275850/article/details/46129071)
# 中断处理流程-汇编处理

arm CPU 对中断的处理开始于 irq line 的触发，如果中断没有被屏蔽，也就是  CPSR.I  bit 不为 1 时，程序的执行流会强制跳转到中断向量表的 IRQ 中断向量处，执行中断处理函数。 

在 non-secure 模式下，arm 中的中断向量表有两个位置选项，0x0 和 0xffff0000 ，通过 SCTLR.V bit 控制，一般都会配置为 0xffff0000 地址，这属于内核地址，处理起来更方便。 

硬件上，伴随中断跳转执行的动作还有：

* 处理器模式切换到 irq 模式(中断之前的模式可能是在 user 或者 svc 模式)，同时还伴随着状态寄存器的切换，从 user 模式切换到 irq 模式时，user 下的 apsr 寄存器会自动复制到 irq 模式下的 spsr 寄存器中，如果是 svc 到 irq 模式的切换，则是 svc 模式的 cpsr 复制给 irq 模式的 spsr 寄存器。总之，spsr 用于保存跳转前模式下的状态寄存器。 
  同时将 cpsr 寄存器设置为 irq 模式对应的 cpsr。

* 中断的返回地址保存在lr 寄存器中，注意是 irq 模式下的 lr 寄存器而不是原模式下的，毕竟原模式下的寄存器是需要保存并在中断返回时完整恢复的。
* irq 模式下的 cpsr 其它位也将被一一更新：
  * 低五位模式位切换为 irq 模式。
  * cpsr .i bit 被设置为 1，也就是发生中断跳转的那一刻，CPU 的中断也就被屏蔽了。 
  * 根据系统设置设置指令集选择位
  * 根据系统设置设置大小端
  * CPSR.IT bit 被清除
* PC 值被设置为对应向量表地址，对于 irq 中断而言，向量地址为 BASE + 0x18，每个向量占 4 个字节



## 从链接脚本开始

要知道向量表被放置在哪个位置，一个方法是去读取 cp15 协处理器的 SCTLR 寄存器，另一个更方便的方法呢，就是通过查看链接脚本。

```
	__vectors_start = .;
	.vectors 0xffff0000 : AT(__vectors_start) {
		*(.vectors)
	}
	. = __vectors_start + SIZEOF(.vectors);
	__vectors_end = .;
```

.vectors 正是保存向量表的 section，从链接脚本可以看出，linux 的向量表将会被放置在 0xffff0000 这个虚拟地址上，而实际的加载地址为 \_\_vectors_start，这个地址具体的地址取决于地址定位符 "." 的地址，这个地址会随着 section 的放置而自动增长，同时，在链接脚本中定义了 \_\_vectors_end 符号，用来记录向量表的终止地址。 

既然加载地址和虚拟地址(运行地址)不一致，当镜像加载到内核中时，软件上会将向量表从加载地址赋值到虚拟地址，这部分操作在 early_trap_init 中完成：

```c++
void __init early_trap_init(void *vectors_base)
{
    unsigned long vectors = (unsigned long)vectors_base;
	extern char __stubs_start[], __stubs_end[];
	extern char __vectors_start[], __vectors_end[];
    memcpy((void *)vectors, __vectors_start, __vectors_end - __vectors_start);
	memcpy((void *)vectors + 0x1000, __stubs_start, __stubs_end - __stubs_start);
    ...
}
```

在内核执行完该函数之后，向量表就放到了它应该放置的位置上。 

## 中断向量

在代码中全局搜索链接脚本中的 vectors section，就可以找到该段的定义处，也就是中断向量的定义处，在 arch/arm/kernel/entry-arm.S 中：

```assembly
	.section .vectors, "ax", %progbits
.L__vectors_start:
	W(b)	vector_rst
	W(b)	vector_und
	W(ldr)	pc, .L__vectors_start + 0x1000
	W(b)	vector_pabt
	W(b)	vector_dabt
	W(b)	vector_addrexcptn
	W(b)	vector_irq
	W(b)	vector_fiq
```

arm 中每个异常向量对应的地址宽度为 4 字节，因此除了最后一个 fiq 异常向量以外，其它所有的异常向量都只能在对应的向量表处放置一条跳转指令，对于 irq 而言，这条指令为 W(b)	vector_irq。 

W 实际是一个宏，表示 .w，W(b) 表示 b.w, .w 后缀表示强制将该指令编码为 32 位，相对应的还有 .n 后缀，表示强制编码为 16 位。  


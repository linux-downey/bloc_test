中断以及其它异常模式的栈在哪里？  

对于 svc 模式，内核基本上工作在这个模式下，这部分使用进程的内核栈。 

对于中断以及其它模式，实际上发生中断时，硬件跳转到中断向量表处，sp 也会随之跳转，中断的栈的初始化为：


struct stack {
	u32 irq[3];
	u32 abt[3];
	u32 und[3];
	u32 fiq[3];
} ____cacheline_aligned;

arch/arm/kernel/setup.c 中：

void notrace cpu_init(void)
{
	struct stack *stk = &stacks[cpu];
	__asm__ (
	"msr	cpsr_c, %1\n\t"
	"add	r14, %0, %2\n\t"
	"mov	sp, r14\n\t"
	"msr	cpsr_c, %3\n\t"
	"add	r14, %0, %4\n\t"
	"mov	sp, r14\n\t"
	"msr	cpsr_c, %5\n\t"
	"add	r14, %0, %6\n\t"
	"mov	sp, r14\n\t"
	"msr	cpsr_c, %7\n\t"
	"add	r14, %0, %8\n\t"
	"mov	sp, r14\n\t"
	"msr	cpsr_c, %9"
	    :
	    : "r" (stk),
	      PLC (PSR_F_BIT | PSR_I_BIT | IRQ_MODE),
	      "I" (offsetof(struct stack, irq[0])),
	      PLC (PSR_F_BIT | PSR_I_BIT | ABT_MODE),
	      "I" (offsetof(struct stack, abt[0])),
	      PLC (PSR_F_BIT | PSR_I_BIT | UND_MODE),
	      "I" (offsetof(struct stack, und[0])),
	      PLC (PSR_F_BIT | PSR_I_BIT | FIQ_MODE),
	      "I" (offsetof(struct stack, fiq[0])),
	      PLC (PSR_F_BIT | PSR_I_BIT | SVC_MODE)
	    : "r14");
}
这部分嵌入汇编切换到各种异常模式，为其设置对应的栈地址，最后又切换回 svc 模式。   

每种类型的栈占用 12 字节，处于中断模式处理的部分不多，因此这些空间也就够了，因为所有的其他模式又会跳到 svc 模式下进行真正的处理，arm 中断中 svc 模式是直接占用了内核栈空间。  

具体的架构相关的函数为  drivers/irqchip/irq-gic.c：
set_handle_irq(gic_handle_irq);
	handle_arch_irq = handle_irq;

在汇编层面调用了 handle_arch_irq 用于处理架构相关的中断处理。 

也就是通过 gic_handle_irq 来处理中断相关。  




gic 的处理代码:
1. CPU nIRQ 接收到中断,进入中断处理,会调用 gic 的中断处理代码.
2. gic 中断处理代码中,先读取 INT ACK 寄存器,读取这个寄存器也相当于 CPU ack 了这个中断,这个寄存器只用到了 bit0~bit12,高三位为 CPUID(SGI指定目标CPU),低10位为 INT ID,获取到 INT ID,这是硬件 ID,硬件 ID 到软件 ID 还有一个映射阶段,如果 gic 没有 pending 的 INT,返回 1023. 
3.如果 supports_deactivate 为真,表示 deactive 需要手动操作,就是把 INT ACK 寄存器里面的内容写到 EOI 寄存器中,当 EIO mode 为 1 时,这个操作会执行 priority drop,表示可以继续提交 CPU int,但是现在中断还没开,CPU 并不会受理.




























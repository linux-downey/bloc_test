# 中断的注册

在编写内核驱动时,有时候会需要使用到外设的中断功能,需要向内核注册中断处理程序,一方面是使能该中断,另一方面是注册中断发生时的回调函数,一般来说,注册中断使用得最多的接口是 request_irq,还有一种并不太常用的中断线程化处理方式,也就是将中断处理函数放到线程中执行而不是中断上下文中,以提高系统中某些实时进程的实时性. 



## 申请中断的接口

向内核申请中断,首先需要知道该外设对应的中断号,这个中断号通常由设备树提供,驱动 probe 程序中通过解析设备树的 interrupts 属性获取中断号,然后调用 request_irq:

```c++
static inline int __must_check
request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,const char *name, void *dev)
```

handle 参数是用户传入的中断回调函数

flags 参数用于设置中断的相关属性,相应的参数有:

* IRQF_SHARED:表明该中断是共享的,也就是一个中断线对应多个外设中断源,在中断处理时需要执行额外的识别工作.
* IRQF_TIMER:标记该中断属于 timer 类型的中断,方便内核进行特殊处理
* IRQF_PERCPU:percpu 类型的中断
* IRQF_NOBALANCING:表示当前中断不受 irqbalance 的影响,实际上是通过限制对该 irq 设置 affinity 来实现的,irqbalance 并不是内核中的策略,而是一个用户空间的 demon,通常应用在 x86 架构中.该 demon 根据 CPU 的负载以及所处的模式(performance 或者 power-save)来动态地将系统中的中断绑定到不同的 CPU,其实现方式也是通过读写应用空间的 /proc 下的接口,比如通过 /proc/interrupts 了解系统中的中断信息,通过 /proc/irq/N/smp_affinity 设置中断的亲和性. 
* IRQF_IRQPOLL:中断用于轮询,出于性能考虑,只有在共享中断中注册的第一个中断才设置.(这句话只是翻译了内核中的注释,但是我并不知道这个标志位具体是什么意思,走过路过的哪位了解的大神可以指导指导).
* IRQF_ONESHOT:只有当中断真正处理完成之后,才会再次开启中断,主要是应对中断线程化中的一些问题,后面会再提到.
* IRQF_NO_SUSPEND:表示在系统 suspend 的时候不要 disable 该中断,也就是说这个中断可以用来在系统休眠的时候用作系统的唤醒,但是也并不一定保证该中断能唤醒睡眠中的系统,还需要使能 irq 唤醒功能(enable_irq_wake),具体参见[内核文档](https://github.com/torvalds/linux/blob/master/Documentation/power/suspend-and-interrupts.rst)
* IRQF_FORCE_RESUME:在系统 resume 时 enable 该中断
* IRQF_NO_THREAD:中断不能被线程化
* IRQF_EARLY_RESUME:在系统 resume 的时候,该中断在早起被 resume 而不是在设备唤醒阶段

name 参数在中断处理的过程并不需要,只是用于在显示或者调试的时候方便识别中断

dev:也就是 dev_id,用于唯一标示一个中断,对于独立的中断通常设置为 NULL,主要针对共享中断,在共享中断的处理函数中通过 dev_id 判定具体的中断源,在中断 free 的时候也通过该 id 才能识别到具体要释放的中断源.

request_irq 的源码如下:

```c++
static inline int __must_check
request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
	    const char *name, void *dev)
{
	return request_threaded_irq(irq, handler, NULL, flags, name, dev);
}
int request_threaded_irq(unsigned int irq, irq_handler_t handler,
			 irq_handler_t thread_fn, unsigned long irqflags,
			 const char *devname, void *dev_id);
```

尽管注册中断和注册中断线程是完全不同的两种处理方式,但是在内核中将这两种处理方式放在一个函数中处理,对于 request_irq 注册中断而言,只需要提供中断的 handle,而不需要提供 thread_fn.

如果注册中断线程,调用 request_threaded_irq 接口,需要提供 thread_fn,而中断 handle 是可选的,如果不提供,则使用系统默认的 handle,如果提供,该 handle 会在中断上下文中执行,如果该 handle 被正确编写,再执行 thread_fn. 

 

## request_threaded_irq

request_threaded_irq 是注册中断的主要函数,该函数主要实现如下:

* 一些必要的检查工作,比如如果设置共享中断标志则必须提供 dev_id.又比如判断该中断是否能注册,如果该中断不是共享中断且已经被注册,就不能再次注册,返回失败. 

* 通过传入的 irq num,调用 irq_to_desc 函数获取到对应的 irq_desc,这个 irq_desc table 是在 GIC 驱动初始化阶段生成的,每一个有效的 irq num 都对应一个 irq desc,irq desc 这个结构记录(或连接)了一个 irq 的所有相关信息.

* 当 handle 和 thread_fn 都没有提供时,返回错误.
  如果只提供 thread_fn, handle 被赋值为系统默认的 irq_default_primary_handler,表示中断线程化的情况.
  如果只提供 handle,就是标准的注册中断 handle,handle 在中断上下文中被执行
  如果两者都被提供,中断线程会被创建,但是是否会将中断放到线程中执行取决于 handle 的实现. 

* 构建一个 irqaction 结构,irq desc 负责对整个中断的描述,而 irqaction 则针对用户注册中断部分的描述,该数据结构中包含了在注册中断时传入的信息:

  ```c++
  struct irqaction {
  	irq_handler_t		handler;
  	void			*dev_id;
  	struct irqaction	*next;
  	irq_handler_t		thread_fn;
  	struct task_struct	*thread;
  	unsigned int		irq;
  	unsigned int		flags;
  	unsigned long		thread_flags;
  	unsigned long		thread_mask;
  	const char		*name;
  	struct proc_dir_entry	*dir;
      ...
  }
  ```

  该结构中大部分成员都是传入的参数,有几个参数需要注意:

  * next: 通过 next 指针可以看出,对于内核中某一个 irq 中断,是可以注册多个 irqaction 的,也就是共享中断的情况,这些 irqaction 通过 next 指针连接.
  * dir : 对于被注册的中断,会在 /proc 目录下导出相应的接口,对应的目录为: /proc/irq/${IRQ_NUM},这个数据结构主要用于导出数据

* 执行 __setup_irq 函数,可以看出这个函数就是初始化一个 irq 的核心函数,传入的参数为 irq num,对应的 desc 以及新生成的 action 结构. 

request_threaded_irq 的源码就不贴了,有兴趣的可以自己去翻翻. 

## __setup_irq 初始化中断




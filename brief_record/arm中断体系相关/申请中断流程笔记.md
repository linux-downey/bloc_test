# request_irq

kernel/irq/manager.c 中。 

request_irq 其实就是直接调用了 request_threaded_irq，只是调用 request_irq 时 thread_fn 参数为 NULL，而直接调用 request_threaded_irq 会给定 thread_fn 参数，创建一个内核实时线程。 



在调用 request_irq 的时候，irq 参数实际上是手册中给出的，通常也是从设备树中解析出来的。 

# request_threaded_irq

desc = irq_to_desc(irq);

irq 和 desc 之间的映射关系有两种：

* 一种是静态的数组：

  ```c++
  struct irq_desc irq_desc[NR_IRQS] __cacheline_aligned_in_smp = {
  	[0 ... NR_IRQS-1] = {
  		.handle_irq	= handle_bad_irq,
  		.depth		= 1,
  		.lock		= __RAW_SPIN_LOCK_UNLOCKED(irq_desc->lock),
  	}
  };
  ```

  直接使用 irq num 作为下标建立 irq num 和 irq desc 的映射。 

  硬件实现上连续的 irq num 就使用这种

* 而有些硬件上不连续的 irq 就不大适合使用静态数组，毕竟会造成比较大的浪费，因此采用 radix tree 对 irq num 和 irq_desc 进行映射

总之，其本质就是要建立映射关系。   

---

_IRQ_NOREQUEST 用于标记当前 irq 有没有被申请过，share 类型的中断怎么说？

---

判断 handler，如果 handler 和 thread_fn 不能同时为空，如果 handler 为空 thread_fn 不为空，这是允许的，设置 handler 设置为 irq_default_primary_handler。 

该函数直接返回 IRQ_WAKE_THREAD，应该是在执行该中断时选择唤醒 irq thread。

---

申请一个 irqaction,并设置相关的参数，irqaction 是中断执行的关键部分，也是用户指定的这一部分。 

---

__setup_irq：关键的 irq 初始化部分都在这里：

如果在申请 irq 的时候没有同时指定 trigger_type，使用默认的 trigger type。

检查是否 nested






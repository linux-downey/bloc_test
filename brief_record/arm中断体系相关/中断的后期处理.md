# linux 中断应用层面的处理

中断发生的时候,硬件上直接执行跳转,跳转到中断向量表处执行中断代码,进入到 irq mode,紧接着又跳转到 svc 模式,在该模式下进行真正的中断处理行为,这些模式跳转以及上下文现场的处理都是晦涩难懂的汇编代码,做好相关的准备工作之后,执行 handle_arch_irq 函数,进入到 C 语言的世界. 

(注:本章节基于支持 GICv2 标准的中断控制器的 arm 平台进行讨论,后续不再强调)

## handle_arch_irq

handle_arch_irq 实际上是一个函数指针,看到 arch 字样就可以猜到,这是一个平台相关的函数,对于不同的平台,这个函数指针可以赋予不同的值,在支持 GICv2 的系统中,这个函数指针是在 GIC 驱动初始化的时候被设置的:

```
static int __init __gic_init_bases(struct gic_chip_data *gic,
				   int irq_start,
				   struct fwnode_handle *handle)
{
    ...
    set_handle_irq(gic_handle_irq);
    ...
}
```

set_handle_irq 设置 handle_arch_irq 等于 gic_handle_irq,也就是在中断发生之后,中断处理流程将会调用 gic_handle_irq 函数. 



## gic_handle_irq

先上代码:

```c++
static void __exception_irq_entry gic_handle_irq(struct pt_regs *regs)
{
	u32 irqstat, irqnr;
	struct gic_chip_data *gic = &gic_data[0];
	void __iomem *cpu_base = gic_data_cpu_base(gic);

	do {
		irqstat = readl_relaxed(cpu_base + GIC_CPU_INTACK);
		irqnr = irqstat & GICC_IAR_INT_ID_MASK;

		if (likely(irqnr > 15 && irqnr < 1020)) {
			handle_domain_irq(gic->domain, irqnr, regs);  ..............1
			continue;
		}
		if (irqnr < 16) {
			writel_relaxed(irqstat, cpu_base + GIC_CPU_EOI);
			...
			handle_IPI(irqnr, regs);                     ...............2
			continue;
		}
		break;
	} while (1);            
}
```



在 GIC 相关的文章中(TODO)了解到,GIC 支持三种中断:SGI,PPI,SPI.

 SGI 是软件触发的中断,通常用作 CPU 之间的通信,软件触发 SGI 时需要指定目标 CPU. 

PPI 是硬件触发的,不过是 CPU 独立的,最典型的例子就是每个 CPU 核的 tick timer,而 SPI 就是我们最常见的外部中断.  

内核中,针对 SGI 和 PPI/SPI 的处理是分开的,毕竟 SGI 中断只涉及到软件处理,处理起来相对简单,如果将 SGI 的处理也加入到 SPI 的处理框架中,会影响 SGI 的处理效率.

而对于 SPI 而言,需要考虑 GIC 的级联问题,当系统中存在多个 GIC 时,需要递归地进行处理.因此调用 handle_domain_irq,而 PPI 和 SPI 共用了处理部分.实际上在我看来,级联的子 GIC 不大可能会连接 PPI 中断,毕竟 percpu 的 bank 中断放在 secondary GIC 中看起来是很奇怪的.奇怪归奇怪,实现上是没问题的,因此 PPI 中断的处理放到 SPI 一起也是没太多问题.  

注1:在 arm linux 中,CPU 上使用的中断引脚只有 irq line,因此发生中断的时候,CPU需要知道中断源,中断源的信息记录在 GIC 的 GIC_CPU_INTACK 寄存器中,包括 CPU ID 和 interrupt ID,只有在 SGI 中断中 CPU ID 才是有意义的,这是 CPU interface 寄存器,也就是 percpu 的,可以通过 CPU ID num 获取当前 SGI 中断是由谁发送的. 

对于 PPI/SPI 中断,CPU ID 没有意义,因此只需要读取  GIC_CPU_INTACK 寄存器的低 10 位,获取 GIC 上发生中断的 hwirq, 如果 hwirq 大于 15 同时小于 1020,说明这是个外部的硬件中断(SPI/PPI),小于 16 表示这是 IPI 中断,需要区分处理.

注意到,发生中断时中断号的读取以及处理

hwirq 并不一定就是系统中的 irq 号,这其中需要经过相应的转换
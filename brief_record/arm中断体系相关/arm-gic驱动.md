# arm-gic 驱动
即使是一个简单的嵌入式系统,通常也支持多种类型的中断,比如 uart/DMA 等,而对于 arm 架构的 CPU 而言,硬件上只有两根低电平触发的中断线:IRQ 和 FIQ,对于 linux 而言,并没有使用 FIQ,而只是使用了 IRQ 一根中断线接收并处理中断请求.  

因此,多个外设中断与 CPU IRQ 中断线之间的桥梁就是中断控制器,对于 arm 处理器,arm 提供了专属的 arm 中断控制器,即 GIC.  

## gic 需要处理的问题
gic 主要的工作就是两个部分:
* 接收外设传递过来的中断
* 将外设中断传递给 CPU

抽象地描述总是很简单的,背后的实现却并不简单,这主要涉及到几个问题:
* 外部中断的数量非常多,如何对数量繁多的外部中断进行管理,解决中断的排序以及并发问题?
* 在多核架构中,CPU 的数量也不止一个,如何将多个中断分发给不同的 CPU?
* 每个 CPU 只有一个物理的 IRQ 引脚,对于 CPU 而言,触发中断也就是 IRQ 被拉低,但是它是不知道是目前触发的中断是哪一个外部中断的,如何让 CPU 识别并处理外部中断.  

## 硬件架构
还是那句老话,软件框架是基于硬件结构进行实现的,在了解 gic 之前,有必要先了解 gic 在系统中所处的位置,下面是 gic 在 cortex-A7 中的位置:TODO


下面是 gic 的一个硬件框图:TODO.  

首先,中断是一种硬件信号,因此 gic 针对每个存在的外部中断都提供了一个硬件控制引脚,当外部设备发生中断时,通过这个硬件上的引脚传递中断,同时中断控制器通过不同的引脚来区分发生中断的硬件.  

对于 CPU 端,接口分为两部分:
一个是去到 CPU 的硬件中断线,IRQ 或者 FIQ,vIRQ/vFIQ 是虚拟化扩展的部分,暂不讨论.  

另一个是系统总线,CPU 通过系统总线访问 gic 的内部寄存器,因此,gic 也是一个 memory map 类型的设备.尽管它和 uart 这些外设一样都是通过系统总线进行访问,但是 gic 是处理器内部实现的.  

所体现出来的区别就是,针对多核架构,gic 可以实现 bank 寄存器,bank 寄存器的概念在 CPU 体系架构中经常见到,也就是一个地址上对应多个寄存器的副本,比如对于在 0x800 地址上的寄存器,CPU0 和 CPU1 对这个地址上寄存器的访问结果是不同的,至于 gic 如何识别当前是哪个 CPU 在访问当前寄存器,这是由硬件进行识别的,处理器内部的 gic 提供该功能,而处理器之外的外设是不支持的.   








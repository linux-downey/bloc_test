# arm-gic 驱动
即使是一个简单的嵌入式系统,通常也支持多种类型的中断,比如 uart/DMA 等,而对于 arm 架构的 CPU 而言,硬件上只有两根低电平触发的中断线:IRQ 和 FIQ,对于 linux 而言,并没有使用 FIQ,而只是使用了 IRQ 一根中断线接收并处理中断请求.  

因此,多个外设中断与 CPU IRQ 中断线之间的桥梁就是中断控制器,对于 arm 处理器,arm 提供了专属的 arm 中断控制器,即 GIC.  

## gic 需要处理的问题
gic 主要的工作就是两个部分:
* 接收外设传递过来的中断
* 将外设中断传递给 CPU

抽象地描述总是很简单的,背后的实现却并不简单,这主要涉及到几个问题:
* 外部中断的数量非常多,如何对数量繁多的外部中断进行管理,解决中断的排序以及并发问题?
* 在多核架构中,CPU 的数量也不止一个,如何将多个中断分发给不同的 CPU?
* 每个 CPU 只有一个物理的 IRQ 引脚,对于 CPU 而言,触发中断也就是 IRQ 被拉低,但是它是不知道是目前触发的中断是哪一个外部中断的,如何让 CPU 识别并处理外部中断.  

## 硬件架构
还是那句老话,软件框架是基于硬件结构进行抽象的,在了解 gic 之前,有必要先了解 gic 在系统中所处的位置,下面是 cortex-A7 的硬件结构图:TODO

cortex-A7 是一个 4 核结构，具体的实现也可以是单核，不难从硬件结构图中看到，GIC 是所有 CPU 核心共享的器件，接收处理器外部(通常是外部)的中断信号，通过 SCU 单元将中断信息传递给各个 CPU 核，准确地说应该是各个 CPU 可以通过总线接口访问 gic，因为这是整个 cortex-A7 MPcore 的框图，并不针对 GIC，实际上 GIC 还有硬件的 IRQ 和 FIQ 信号连接到 GIC 上，GIC 通过硬件上的 IRQ/FIQ 传递中断信息。  

而具体中断相关的系统框图可以参考下面:TODO.  

首先,中断是一种硬件信号,因此 gic 针对每个存在的外部中断都提供了一个硬件控制引脚,当外部设备发生中断时,通过这个硬件上的引脚传递中断,同时中断控制器通过不同的引脚来区分发生中断的硬件.  

对于 CPU 端,接口分为两部分:
一个是去到 CPU 的硬件中断线,IRQ 或者 FIQ,vIRQ/vFIQ 是虚拟化扩展的部分,暂不讨论.  

另一个是系统总线,CPU 通过系统总线访问 gic 的内部寄存器,因此,gic 也是一个 memory map 类型的设备.尽管它和 uart 这些外设一样都是通过系统总线进行访问,但是 gic 是处理器内部实现的.  

所体现出来的区别就是,针对多核架构,gic 可以实现 bank 寄存器,bank 寄存器的概念在 CPU 体系架构中经常见到,也就是一个地址上对应多个寄存器的副本,比如对于在 0x800 地址上的寄存器,CPU0 和 CPU1 对这个地址上寄存器的访问结果是不同的，是各自的寄存器,至于 gic 如何识别当前是哪个 CPU 在访问当前寄存器,这是由硬件进行识别的,处理器内部的 gic 提供该功能,而处理器之外的外设(比如uart)是不支持的.   


## gicv2
arm 的 gic 有多个版本，最初的版本是 gicv1，这个版本拥有 gic 的大部分核心功能，包括中断分发、中断使能控制、优先级控制以及对多核的支持等等。gicv2 在 gicv1 的基础上增加了虚拟化扩展、中断分组、wakeup event 等功能，v3 版本增加了中断源数量和 CPU core 的支持，而 v4 进一步加强了对虚拟化的支持，v3 和 v4 主要针对 armv8 架构，通常应用在 cortex-A53/A57/A72 上。  

鉴于 gicv2 版本基本上已经包含了 gic 的大部分核心功能，同时我们也不关心虚拟化相关的内容，因此主要对 gicv2 进行介绍和分析。  

gicv2 是一个 gic 标准，按照惯例，标准只是规定了在具体的实现中哪些核心的部分需要符合规范，而哪些部分是可以由实现自由发挥的，针对 gicv2 标准的实现有 GIC-400 以及各个处理器中的实现。  

同时，gicv2 的实现针对的是整个 arm 硬件平台，并不针对硬件平台上的软件或者操作系统，对于不同的操作系统又存在不同的应用，比如 linux 中并不使用到 arm CPU 的 FIQ 中断，因此，针对 gic 以及其实现的分析，我们主要基于 linux 平台的实现，抛开诸如安全扩展、虚拟化扩展、FIQ 中断抢占等和 linux 不相关的内容。  


## gicv2 结构
正如上面所提到的,GIC 对下连接各路中断源,对上输出到 CPU,GIC 的硬件设计也分成相应的两部分:
* GIC distributor
* GIC CPU interface

distributor 翻译过来就是分发器,负责将中断源传递过来的中断进行分发,而 CPU interface 不言而喻,则是针对 CPU 的配置接口,在多核架构中,每个 CPU 对应一个 CPU interface,负责将 distributor 传递过来的中断传递给 CPU,同时和 CPU 进行系列的交互.因此,在 GIC 中,一个外部中断向上传递的流程为:中断产生源 -> GIC distributor -> GIC CPU interface -> CPU.   

下面是 GIC 内部的硬件框图(TODO):


在上文对中断源的描述中,只提到了外部中断,因为这是底层开发人员最熟悉,也是接触的最多的中断源,在 GIC 中称为 SPI,即 Shared Peripheral Interrupt(注意和 SPI 通信协议的区分),是所有 CPU 共享的中断,处理器外部的外设通常使用这些中断,比如 uart/i2c.  

有共享中断,那就有私有中断,私有中断有两种:
* Private Peripheral Interrupt (PPI):这些中断也对应硬件上的外设中断线,只不过这些中断是会被分发到指定的 CPU.  
* Software-generated interrupt (SGI):这是软件上配置的中断,这类型中断的触发是通过软件上写 gic 的寄存器实现的,同时这类中断也是指定 CPU 的.  

因此,在上面的硬件框图中,SPI 是共享的,而 SGI 和 PPI 是 percpu 类型的,而 SPI/PPI 具体连接哪些中断,由具体的实现来决定.  

### distributor
GIC 中的 distributor 是属于所有 CPU 共享的,主要控制中断的收集与分发,其具体实现的接口为:
* 全局地控制是否将中断源传递到 CPU interface.
* 控制单个中断线是否使能,如果不使能,对应中断线上产生的中断自然不会传递到 CPU interface.
* 设置每个中断的优先级,当出现中断源的并发时,向 CPU interface 传递优先级更高的中断
* 设置所有中断源传递的目标 CPU,可以指定某些中断只传递到特定的 CPU interface.
* 设置中断触发模式,是电平触发还是边沿触发
* 为每个中断配置为 Group0 或者 Group1,通常只有在实现了 secure 模式的处理器上才会区分 Group0 或者 Group1
* 传递 SGI 到特定的 CPU 核,可以是单个,也可以是多个.  
* 软件可以直接设置和清除外部中断的 pending bit,也就是软件也可以触发外部中断.  

#### 中断号
对于 GICv2,最多支持 1020 个中断源,这是规定的一个上限值,具体的数量需要看处理器以及 board 的实现,比如 cortex-A7 处理器中实现的 gic 只支持 480 个 SPI 中断,而实际基于 cortex-A7 实现的 imx6 只是使用了 128 个外设中断线.  

在标准的规定中,每个中断都对应一个 ID 号,ID0-ID15 用于 SGI 中断,ID16-ID31 用于 PPI 中断,而 ID32- 1019 属于共享的 SPI 中断.  

在多核中,对于硬件上的 PPI 中断,由 GIC 的 bank 寄存器控制,每个 PPI 线都只会对应一个特定的 CPU,PPI 对应哪些中断这是由处理器决定的,比如对于 cortex-A7 而言,PPI1 对应 Secure Physical Timer event,PPI2 对应 percpu 的 Non-secure Physical Timer event,从硬件上来看,



### CPU interface

## 中断上报流程




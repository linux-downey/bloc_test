## debmake
debmake的作用就是将一个纯粹的源码包debian化，具体的行为就是给源码包添加一些编译deb包时需要的配置文件。  

操作方式：

打包包可以使用tar -czvf 指令。

源码包的格式：$PKGNAME_$VERSION.orig.tar.gz
示例：debhello_1.0.0.orig.tar.gz

需要注意的是，PKGNAME中不要包含_，以免与版本号的识别产生冲突。  

使用debmake的操作：

        tar -xvf debhello_1.0.0.orig.tar.gz
        cd debhello_1.0.0
        debmake
在一般情况下，会在当前目录下生成一个debian文件夹，文件夹里面包含deb的配置文件(下文详解)。

但是，在ubuntu的16.14版本上可能会报错，

        I: set parameters
        Traceback (most recent call last):
        File "/usr/bin/debmake", line 28, in <module>
        debmake.main()
        File "/usr/lib/python3/dist-packages/debmake/__init__.py", line 104, in main
        para = debmake.para.para(para)
        File "/usr/lib/python3/dist-packages/debmake/para.py", line 44, in para
        debmail = os.getlogin() + '@localhost'

根据错误信息可知，是python3的para.py脚本中的os.getlogin()命令执行有问题，根据错误提示找到：/usr/lib/python3/dist-packages/debmake/para.py的44行，代码如下：

        def para(para):
        debmail = env('DEBEMAIL')
        if not debmail:
                debmail = os.getlogin() + '@localhost'
        debfullname = env('DEBFULLNAME')

然后进入python环境执行os.getlogin()，发现这条语句确实会报错。

第一个解决方案是：设置DEBEMAIL环境变量和DEBFULLNAME环境变量：

export DEBEMAIL="linux_downey@gmail.com"
export DEBFULLNAME="downey_boy"

这样这条语句就不会被执行

第二个解决方案：修改脚本，让它可以以另一种方式执行获得想要的结果
import os, pwd
os.getlogin = lambda: pwd.getpwuid(os.getuid())[0]


## deb包配置文件
配置文件的目录结构：

├── debian
│   ├── changelog
│   ├── compat
│   ├── control
│   ├── copyright
│   ├── patches
│   │   └── series
│   ├── README.Debian
│   ├── rules
│   ├── source
│   │   ├── format
│   │   └── local-options
│   └── watch
├── Makefile
└── src
    └── hello_world.c
DEBIAN目录下的文件为控制文件，描述整个文件包属性
其中changelog、control、copyright、rules是必须的，通常需要修改的也是这几个文件。

## control

        Source: debhello
        Section: unknown
        Priority: extra
        Maintainer: downeyboy <linux_downey@sina.com>
        Build-Depends: debhelper (>=9)
        Standards-Version: 3.9.6
        Homepage: <insert the upstream URL, if relevant>

        Package: debhello
        Architecture: any
        Multi-Arch: foreign
        Depends: ${misc:Depends}, ${shlibs:Depends}
        Description: auto-generated package by debmake
        This Debian binary package was auto-generated by the
        debmake(1) command provided by the debmake package.
源码包的名称
这个源码包对应的发行版的分类，可以使用unknown，分类为：main(自由软件)，non-free (非自由软件)以及 contrib (依赖于非自由软件的自由软件)
该软件包的优先级，软件包的优先级有：required、important、standard或者optional，常规优先级(不与其他包冲突)的包可以改为optional，extra这个选项已经被弃用了，可以用optional来代替。  
Build-Depends：表示该软件包编译时依赖的软件包，不包括build-essential这些默认安装的软件
Standards-Version：该软件包所依据的debian policy manual标准版本号
Homepage：上游代码的地址，可以将github源码的地址放在这里

Package：软件包的名称
Architecture：软件包的体系架构，根据二进制包的类型，通常是下列两种之一：
1. any：包含编译型语言编写的程序，生成的二进制包依赖于具体的体系结构
2. all：文本、图像或者脚本之类的独立于体系架构的

Depends：该软件包与其他软件包之间的依赖关系。其中有：
Depends：必须
recommends：非必须、但是推荐
suggests：装上能更方便地工作
pre-depends：依赖更强于Depends，必须安装了这里指定的包才能安装当前包
conflicts：冲突的包必须卸载了之后才能安装
breaks：当前包的安装会损坏某些包
replaces：替换其他软件包，列出的软件包中的文件会被当前软件包覆盖

所有这些条件遵循一定的语法，不同的项之间使用半角逗号分隔。


${misc:Depends}, ${shlibs:Depends}，包括未列出但常用的${perl:Depends}
dh_shlibdeps(1) 会为二进制包计算共享库依赖关系。它会为每个二进制包生成一份 ELF 可执行文件和共享库列表。 这个列表用于替换 ${shlibs:Depends}。

dh_perl(1) 会计算 Perl 依赖。它会为每个二进制包生成一个叫作 perl 或 perlapi 的依赖列表。这个列表用于替换 ${perl:Depends}。

一些 debhelper 命令可能会使生成的软件包需要依赖于某些其他的软件包。所有这些命令将会为每一个二进制包生成一个列表。这些列表将用于替换 ${misc:Depends} 
就是让工具自己去计算依赖，这样比较省事。

Description：写下一些自己的软甲包说明


这里只是修改一下：
priority、Description、homepage
如果在使用debmake时没指定邮箱和署名，同样需要修改。

## changelog
顾名思义，changelog的作用就是指明库的修改记录。它也是有一定的格式的。

格式是这样的：
        package (version) distribution(s); urgency=urgency
                [optional blank line(s), stripped]
                * change details
                more change details
                [blank line(s), included in output of dpkg-parsechangelog]
                * even more change details
                [optional blank line(s), stripped]
        -- maintainer name <email address>[two spaces]  date
自动生成的部分只需要修改distribution部分就可以了，其他部分酌情修改。


## copyright
在真实的软件包中，copyright是非常重要的声明，但是这里可以先不管。

## rules
这个rules文件相当于软件包的另一个Makefile，但是不同于源代码中的Makefile。这个文件是一个可执行文件。  

rules文件的规则，语法和Makefile非常像，其中每一个都定义了一个target以及其具体的操作，一个新的rule以自己的target进行声明来起头，后续的行以TAB开头，rules中target的执行是这样的：
debian/rules target
就执行了rules中的target项对应的操作。  

debmake会生成一个默认的rules文件：

        #!/usr/bin/make -f
        # You must remove unused comment lines for the released package.
        #export DH_VERBOSE = 1
        #export DEB_BUILD_MAINT_OPTIONS = hardening=+all
        #export DEB_CFLAGS_MAINT_APPEND  = -Wall -pedantic
        #export DEB_LDFLAGS_MAINT_APPEND = -Wl,--as-needed
        
        %:
            dh $@  
         
        #override_dh_auto_install:
        #   dh_auto_install -- prefix=/usr
        
        #override_dh_install:
        #   dh_install --list-missing -X.pyc -X.pyo

#!/usr/bin/make -f:表示这个可执行文件由/usr/bin/make来解析。  
在上述示例中唯一没有被注释的行是

        %：
                dh $@
其中的百分号意味着“任何 targets”， 它会以 target 名称作参数调用单个程序 dh，dh 命令是一个包装脚本，它会根据参数执行妥当的 dh_* 程序序列。
在上述的rules中，将会执行多个dh*命令，这些dh命令有一些预定义的行为，

rules中指定这些dh*命令部分建立在makefile的基础上，
比如：
dh_auto_build相当于调用make
dh_auto_install相当于调用make install

在使用的时候会使用到fakeroot。

在默认生成的rules文件中我们可以 

        #export DH_VERBOSE = 1
去掉#，以看到rules执行的过程。  



## 添加其他文件
通常，除了添加可执行文件到/usr/bin/中，还需要添加库到/usr/lib.
同样的，可以直接用Makefile中的install来指定。  

## 其他操作
preinst
postinst
prerm
postrm




使用sbuild，就可以进行编译工作了。
编译完成的deb包可以先使用dpkg -i来尝试安装。  


